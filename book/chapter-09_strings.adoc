== String-Parsing DSLs

> Words are, of course, the most powerful drug used by mankind.
-- Rudyard Kipling

In some cases, the host language doesn't allow to create the DSL syntax you would like. A string-parsing DSL gives you the freedom to write basically anything. One topic where traditional DSL categories are particularly bad is giving the user some leeway, e.g. concerning upper and lower case syntax, order of operations or the use of special characters like symbols. String-based DSLs can easily incorporate such leniency.

The downside is that these DSLs are hidden from the scrutiny of the compiler: There are no compile time checks, no hints for auto-completion etc., which means the user has to rely on the documentation. Another issue is writing the parser: Dissecting a string is usually more involved than collecting the data in other DSL types, although it is also no rocket science.

(((Regular Expressions)))

WARNING: Kotlin supports - like many languages - regular expressions, which can be seen as a kind of mini-parser. For small, isolated use cases they can be very convenient. However, employing them for larger problems can lead to code which is very hard to maintain, because this approach doesn't scale well. In my opinion, using regular expressions as full-blown "parsers" may be acceptable for prototypes and test environments, but not in production code.

=== Case Study: Forsyth–Edwards Notation

Before we dive into complicated problems requiring parsers, we will start with an easy example, where we need only a few string functions. If you don't play chess, you probably never heard of the https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation[Forsyth–Edwards Notation] (FEN):

.Forsyth–Edwards Notation
****
The Forsyth–Edwards Notation is a standard notation for describing the current position of pieces on a chessboard. It consists of a string of characters that represent the placement of the pieces, which are organized by rank and file. In FEN, uppercase letters are used to represent white pieces, and lowercase letters are used to represent black pieces. The digits 1-8 are used to represent empty squares, and a forward slash is used to separate ranks. FEN also includes information about:

* which player has the next move
* castling availability
* en passant capture availability
* number of half-moves without check or pawn moves (for the 50- or 75-move rule)
* number of moves played so far
****

Rows are separated by `/` and pieces have the usual names used in chess notation (like "Q" for a queen), plus "P" for pawn. To keep the string short, empty squares are written with a kind of run-length encoding, e.g. 3 empty fields are represented by a 3. The castling rights are given by "k" for king-side and "q" for queen-side, again upper-case for white and lower-case for black. If nobody can castle, a `-` is written instead. The en-passant field contains either a square like `b3` or again a `-`.

A FEN looks like this: `rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2`. If you put the rows one below the other, and expand the numbers to empty fields, you can "see" the board position:

[source,text]
----
rnbqkbnr
pp.ppppp
........
..p.....
....P...
.....N..
PPPP.PPP
RNBQKB.R
----

This is the `Position` class we want to create using a FEN string:

[source,kotlin]

----
enum class Piece(val symbol: String) {
    WhitePawn("P"), WhiteRook("R"), WhiteKnight("N"),
    WhiteBishop("B"), WhiteQueen("Q"), WhiteKing("K"),
    BlackPawn("p"), BlackRook("r"), BlackKnight("n"),
    BlackBishop("b"), BlackQueen("q"), BlackKing("k"),
}

enum class Color(val symbol: String) {
    Black("b"),
    White("w")
}

data class Position(
    val pieces: Map<String, Piece>,
    val toMove: Color,
    val castling: List<Piece>,
    val enPassant: String,
    val fiftyMoves: Int,
    val move: Int
) {

    private fun boardFen() =
        (8 downTo 1).joinToString("/") { row ->
            ('a'..'h').joinToString("") { col ->
                pieces["$col$row"]?.symbol ?: "1"
            }
        }.fold("") { acc, ch ->
            if (acc.isNotEmpty() && acc.last().isDigit() && ch == '1')
                acc.dropLast(1) + (acc.last() + 1)
            else acc + ch
        }

    private fun castlingFen() = when {
        castling.isEmpty() -> "-"
        else -> castling.joinToString("") { it.symbol }
    }

    fun FEN() = "${boardFen()} ${toMove.symbol} " +
            "${castlingFen()} $enPassant $fiftyMoves $move"
}
----

The class contains already a function for generating a FEN - this is not required, but it makes testing much easier.

.Round-trip Tests
****
When you have code that transforms forth and back between different formats, it is convenient to write round-trip tests: You're providing test data for the "easier" format, transform it to the other one(s) and back, and compare it with the original. Comparing data in the same format is simpler and safer than comparing different ones - often just a string comparison is sufficient.
****

Now we can write the DSL function for parsing a FEN:

[source,kotlin]
----
fun readFEN(fenString: String): Position = fenString
    .split(" ")
    .let { part ->
        Position(
            pieces = getPieces(part[0]),
            toMove = getToMove(part[1]),
            castling = getCastling(part[2]),
            enPassant = part[3],
            fiftyMoves = part[4].toInt(),
            move = part[5].toInt()
        )
    }

private fun getPieces(piecesStr: String) = piecesStr
    .fold("") { acc, ch ->
        acc + if (ch.isDigit()) ".".repeat(ch.toString().toInt()) else ch
    }
    .split("/")
    .reversed()
    .mapIndexed { rowIndex, row ->
        row.mapIndexedNotNull { colIndex, ch ->
            values().find { it.symbol == ch.toString() }
                 ?.let { "${'a' + colIndex}${rowIndex + 1}" to it }
        }
    }
    .flatten()
    .toMap()

private fun getToMove(toMoveStr: String) = when (toMoveStr) {
    "w" -> Color.White
    "b" -> Color.Black
    else -> error("Unknown color symbol '$toMoveStr'")
}

private fun getCastling(castlingStr: String) = castlingStr
    .mapNotNull { ch ->
        when (ch) {
            'K' -> WhiteKing
            'k' -> BlackKing
            'Q' -> WhiteQueen
            'q' -> BlackQueen
            else -> null
        }
    }
----

The `readFEN()` function calls some helper functions for the different parts, and assembles the `Position` class. Most of the sanity checks were omitted for better readability. In easy cases like this, it is probably overkill to write a parser or to use a parser library. The hardest part was to read the piece positions correctly, and this took just a few lines.

[#chemicalEquationsAsString]
=== Case Study: Chemical Equations as Strings

Writing a DSL for chemical equations is challenging using Kotlin syntax, because the concise notation doesn't naturally lend itself to be easily expressed using language features. That's why using the string parsing approach seems like a good fit. If you are curious how a hybrid DSL for chemicals could look like, you can skip ahead to <<chapter_11.adok#chemicalEquationsAsHybrid,Chapter 11 - Hybrid DSLs>>.

For our case study, we won't cover the full notation, e.g. we won't support writing ions or bonds. An example of a simple chemical equation in standard notation would be `3Ba(OH)~2~ + 2H~3~PO~4~ -> 6H~2~O + Ba~3~(PO~4~)~2~`. Of course, in scope of a DSL subscripts and special symbols are not very practical, so the target syntax would look more like `3Ba(OH)2 + 2H3PO4 -{zwsp}> 6H2O + Ba3(PO4)2`. To express such an equation, we use the following code:

[source,kotlin]
----
sealed interface Part

data class Element(val symbol: String, val subscript: Int) : Part {
    override fun toString() = when (subscript) {
        1 -> symbol
        else -> symbol + subscript
    }
}

data class Group(val parts: List<Part>, val subscript: Int) : Part {
    override fun toString() = when (subscript) {
        1 -> parts.joinToString("", "(", ")")
        else -> parts.joinToString("", "(", ")") + subscript
    }
}

data class Molecule(val coefficient: Int, val parts: List<Part>) {
    override fun toString() = when (coefficient) {
        1 -> parts.joinToString("")
        else -> "$coefficient${parts.joinToString("")}"
    }
}

data class Equation(val leftSide: List<Molecule>, val rightSide: List<Molecule>, val reversible: Boolean = false) {
    override fun toString() = leftSide.joinToString(" + ") +
            (if (reversible) " <-> " else " -> ") +
            rightSide.joinToString(" + ")
}
----

An `Element` contains a chemical symbol, like `"H"` (hydrogen) or `"Ba"` (barium), and optionally a subscript, which is counting the number of atoms. A feature of the chemical notation is that you can also define groups like `"(OH)~2~"` in a molecule, which is why we need the `Group` class as well. A group can contain not only elements, but also other groups.

A `Molecule` is a collection of elements or groups (which we subsume under a `Part` interface), and can also have a coefficient in front. An equation consists of two sides and either an arrow `-{zwsp}>` or - in case of reversible reactions - a double arrow `<{zwsp}-{zwsp}>` in the middle. Both sides consist either of a single molecule or a "sum" of molecules.

The code and overwrites the `toString()` methods in order to give the output in chemical notation. Note that lists were used instead of varargs, because data classes don't allow varargs in their primary constructor.

This chart summarizes the structure of our model classes:

[ditaa,"chemicalEquationAsString"]
.Model for Chemical Equations
....

         +--------------+
         |   Chemical   |
         |              |
         |   Equation   |
         +---+------+---+
             |1     |1
        LHS  |      |  RHS
             vn     vn
         +--------------+
         |   Molecule   |
         |              |
         | e.g. 2CH3OH  |
         +------+-------+
                |1
                |
                vn
         +--------------+
         |   Molecular  |
         |              +<--+
         |     Part     |   |1
         +-+----------+-+   |
           |          |     |
           |is-a  is-a|     |n
    +------+--+    +--+-----+-+
    | Element |    |  Group   |
    |         |    |          |
    | e.g. H2 |    |e.g. (OH)2|
    +---------+    +----------+

....

The equation mentioned above for making barium phosphate could be written like this:

[source,kotlin]
----
val Ba = Element("Ba")
val Ba3 = Element("Ba", 3)
val O = Element("O")
val O2 = Element("O", 2)
val O4 = Element("O", 4)
val H2 = Element("H", 2)
val H3 = Element("H", 3)
val P = Element("P")

val bariumHydroxide = Molecule(3, listOf(Ba, Group(listOf(O, H), 2)))
val phosphoricAcid = Molecule(2, listOf(H3, P, O4))
val water = Molecule(6, listOf(H2, O))
val bariumPhosphate = Molecule(1, listOf(Ba3, Group(listOf(P, O4), 2)))

val equation = Equation(
    listOf(bariumHydroxide, phosphoricAcid),
    listOf(water, bariumPhosphate),
    false)

println(equation)
//3Ba(HO)2 + 2H3PO4 -> 6H2O + Ba3(PO4)2
----

==== Writing a parser for Chemical Equations

If you never worked with parsers, it can be a little confusing. Writing them by yourself is not really difficult, but boring and tedious, so most of the time using a library will be the better choice. Nevertheless, I think it is instructive to see how a simple parser works, so a naive manual implementation is presented first, before utilizing a parser combinator library.

First, we need some general code for a rudimentary parser. We start from a common interface `ParseResult`, as we also have to cover the case when parsing a certain element fails. Real-world implementations would include useful information in this `Failure` class, but for our use case, we will leave this class empty. We then need a class `Success` to hold the current successful parsing result, together with current location we are working on. For the location, we simply use the remaining string - more performance-oriented implementations typically use just the index of the input string. Overall, these classes have a lot in common with Java's `Optional` class:

[source,kotlin]
----
sealed interface ParseResult<out T> {

    infix fun or(that: () -> ParseResult<@UnsafeVariance T>): ParseResult<T>

    fun <U> flatMap(body: (T, String) -> ParseResult<U>): ParseResult<U>

    fun filter(cond: (T) -> Boolean): ParseResult<T>
}

class Failure<T> : ParseResult<T> {

    override fun or(that: () -> ParseResult<T>): ParseResult<T> = that()

    override fun <U> flatMap(body: (T, String) -> ParseResult<U>) = Failure<U>()

    override fun filter(cond: (T) -> Boolean): ParseResult<T> = this

    override fun toString() = "Failure"
}

data class Success<T>(val value: T, val remaining: String) : ParseResult<T> {

    override fun or(that: () -> ParseResult<T>): ParseResult<T> = this

    override fun <U> flatMap(body: (T, String) -> ParseResult<U>): ParseResult<U> =
        body(value, remaining)

    override fun filter(cond: (T) -> Boolean): ParseResult<T> = when {
        cond(value) -> this
        else -> Failure()
    }
}
----

Then we have some helper functions for reading parse results, and for generating lists from individual results:

[source,kotlin]
----
fun <T> successWhen(cond: Boolean, body: () -> Pair<T, String>): ParseResult<T> =
    when {
        cond -> body().run { Success(first, second) }
        else -> Failure()
    }

fun <T> ParseResult<T>.successOrNull(): Success<T>? = when (this) {
    is Success -> this
    else -> null
}

fun <T> sequence(start: ParseResult<T>, step: (String) -> ParseResult<T>): ParseResult<List<T>> =
    Success(
        generateSequence(start.successOrNull()) { last ->
            step(last.remaining).successOrNull()
        }.toList(), ""
    ).filter {
        it.isNotEmpty()
    }.flatMap { list, _ ->
        Success(list.map { it.value }, list.last().remaining)
    }
----

Now that we have some minimal parsing support in place, we can start with working on the equation parsing. Note that we assume there are no whitespaces in the formula, because handling them everywhere is painful, and we can easily filter them out at top level.

First, all the element names must be known:

[source,kotlin]
----
private val elements = setOf(
    "H", "He", "Li", "Be", "B", "C", "N", "O", // etc.
)
----

Next, we need functions who can recognize given patterns and natural numbers:

[source,kotlin]
----
fun parsePattern(string: String, pattern: String): ParseResult<String> = when {
    string.startsWith(pattern) ->
        Optional.of(pattern to string.substring(pattern.length))
    else -> Optional.empty()
}

fun parseNum(string: String): ParseResult<Int> =
    Optional.of(
        string.takeWhile { it.isDigit() }.length
    ).filter { digitCount ->
        digitCount > 0
    }.map { digitCount ->
        string.substring(0, digitCount).toInt() to string.substring(digitCount)
    }
----

The easiest function is `parsePattern()`, which tries to find a given prefix in the string. `parseNum()` is slightly more involved, as it needs to determine the number of digits first. With one exception (the function `findElement()`), all functions don't read directly from the string, but use these two low level functions and combine the results in certain ways - that's why this approach is known as "parser combinator".

The first example for this "assembling" is the function for reading the equation arrow, which can be either `-{zwsp}>` or `<{zwsp}-{zwsp}>`:

[source,kotlin]
----
fun parseArrow(string: String): ParseResult<String> =
    parsePattern(string, "<->")
        .or { parsePattern(string, "->") }
----

Reading an element is not difficult, the only pitfall is that two-letter symbols must be checked before the one-letter symbols, else the function would just find `H` in a string starting with `He`.

WARNING: It is a common problem that two parsers could match for the same input. Usually the parser reading the longer prefix is the one you want to execute, so you have to make sure to evaluate it first.

[source,kotlin]
----
fun parseElement(string: String): ParseResult<Element> =
    findElement(string, 2).or {
        findElement(string, 1)
    }.flatMap { symbol, s ->
        parseNum(s).flatMap { subscript, s1 ->
            Success(Element(symbol, subscript), s1)
        } or {
            Success(Element(symbol, 1), s)
        }
    }

fun findElement(string: String, charCount: Int): ParseResult<String> =
    successWhen(elements.contains("$string!!".take(charCount))) {
        "$string!!".take(charCount) to string.drop(charCount)
    }
----

First, the `findElement()` function tries to find elements, first with two, and then - if this was unsuccessful - with one character. Artificially prolonging the string with some characters that definitely won't match (here `!`) avoids a possible `IndexOutOfBoundException`. The `map` block in `parseElement()` attempts to find a trailing number. If the number is found, it is used to construct the element, else the default subscript of 1 is used.

Now the groups can be tackled:

[source,kotlin]
----
fun parsePart(string: String): ParseResult<Part> =
    Failure<Part>() or { parseElement(string) } or { parseGroup(string) }

fun parseGroup(string: String): ParseResult<Group> =
    parsePattern(string, "(").flatMap { _, s1 ->
        sequence(parsePart(s1)) { remaining ->
            parsePart(remaining)
        }
    }.flatMap { parts, remaining ->
        parsePattern(remaining, ")")
            .flatMap { _, s3 -> Success(parts, s3) }
    }.flatMap { parts, s ->
        parseNum(s).flatMap { subscript, s1 ->
            Success(Group(parts, subscript), s1)
        } or {
            Success(Group(parts, 1), s)
        }
    }
----

The `parsePart()` method reads either an element or a group. The chain starts with an `Failure<Part>`, which is a trick to avoid casts for the more specialized return types of `parseElement()` and `parseGroup()`. The `parseGroup()` looks first for an opening parenthesis. Then it tries to read as many parts as possible, but at least one. After this, it looks for a closing parenthesis. The final `map()` call handles an optional subscript for the whole group, similar to `parseElement()`.

Now everything is in place to assemble a molecule:

[source,kotlin]
----
fun parseMolecule(string: String): ParseResult<Molecule> =
    (parseNum(string) or { Success(1, string) })
        .flatMap { coefficient, s ->
            sequence(parsePart(s)) { remaining ->
                parsePart(remaining)
            }.flatMap { parts, remaining ->
                Success(Molecule(coefficient, parts), remaining)
            }
        }
----

First, the function looks for a possible coefficient in front, else it uses 1 as default. Then it tries to read as many element or group parts as possible. If some parts were found, the molecule is build, else the parser fails.

This is the parser for gathering the left- and right-hand side of the equation:

[source,kotlin]
----
fun parseSide(string: String): ParseResult<List<Molecule>> =
    sequence(parseMolecule(string)) { remaining ->
        parsePattern(remaining, "+")
            .flatMap { _, s2 -> parseMolecule(s2) }
    }
----

The function generates a list of molecules, while requiring that there is always a `+` in between. Now the parser for the whole equation can be written as follows:

[source,kotlin]
----
fun parseEquation(string: String): ParseResult<Equation> =
    parseSide(string).flatMap { lhs, s1 ->
        parseArrow(s1).flatMap { arrow, s2 ->
            parseSide(s2).flatMap { rhs, s3 ->
                Success(Equation(lhs, rhs, arrow == "<->"), s3)
            }
        }
    }
----

It just reads the left-hand side, the arrow symbol, the right-hand side, and combines them. Now the only missing part is a `equation()` function, which is the only part of our DSL which will be exposed to the user:

[source,kotlin]
----
fun equation(string: String): Equation? =
    parseEquation(string.replace(" ", ""))
        .successOrNull()
        ?.let { result ->
            result.value.takeIf { result.remaining.isEmpty() }
        }
----

This function removes all spaces from the input string, calls the parser, checks that no "unparsed" string is left, and returns the result or null. Now we can write e.g. `equation("3Ba(OH)2 + 2H3PO4 -> 6H2O + Ba3(PO4)2")`, which is as concise at it can get for an internal DSL.

As mentioned in the last chapter, a "real" chemical equation looks more like `3Ba(OH)~2~ + 2H~3~PO~4~ -> 6H~2~O + Ba~3~(PO~4~)~2~`, and with a few simple modifications, we could allow this syntax as well. Generally speaking, allowing the syntax of a String-based DSL to be more lenient is relatively easy, while other DSL categories often struggle with this kind of flexibility.

As already stated, writing such a parser manually isn't difficult. However, using a library has many advantages: It improves readability and maintainability, the code is easier to debug, you get more information when the parsing failed, and the library is usually better tested than our manual code.

To give you an impression how using a parser library looks like, I rewrote the example code using the https://github.com/h0tk3y/better-parse[better-parse] project, which is an example for the parser-combinator approach:

[source,kotlin]
----
val equationGrammar = object : Grammar<Equation>() {
    val ws by regexToken("\\s+", ignore = true)
    val reactsTo by literalToken("->")
    val reversibleTo by literalToken("<->")
    val plus by literalToken("+")
    val leftPar by literalToken("(")
    val rightPar by literalToken(")")
    val num by regexToken("\\d+")
    val symbol by token { cs, from ->
        when {
            elements.contains("$cs##".substring(from, from + 2)) -> 2
            elements.contains("$cs##".substring(from, from + 1)) -> 1
            else -> 0
        }
    }

    val arrow: Parser<Boolean> by (reactsTo asJust false) or
            (reversibleTo asJust true)
    val number: Parser<Int> by (num use { text.toInt() })
    val element: Parser<Element> by (symbol and optional(number))
        .map { (s, n) -> Element(s.text, n ?: 1) }
    val group: Parser<Group> by (skip(leftPar) and
            oneOrMore(parser(this::part)) and
            skip(rightPar) and
            optional(number))
        .map { (parts, n) -> Group(parts, n ?: 1) }
    val part: Parser<Part> = element or group
    val molecule: Parser<Molecule> = (optional(number) and oneOrMore(part))
        .map { (n, parts) -> Molecule(n ?: 1, parts) }
    val side: Parser<List<Molecule>> = separated(molecule, plus)
        .map { it.terms }
    override val rootParser: Parser<Equation> by (side and arrow and side)
        .map { (lhs, a, rhs) -> Equation(lhs, rhs, a) }
}

// calling an example string
val eq = equationGrammar.parseToEnd("3Ba(OH)2 + 2H3PO4 -> 6H2O + Ba3(PO4)2")
----

Going into the details of this specific library is beyond the scope of this book, the important point is how much using a parser-combinator library can improve readability. However, you can still recognize the same pieces of grammar, which are assembled in a similar way as in our original code.

=== Conclusion

String-based DSLs allow to provide a very idiomatic syntax, and can also give the user some leeway by being more lenient than other DSL types. The price to pay is a lack of compile-time checks, less tooling support (e.g. autocomplete features), and from the implementation side the complexity and overhead involved with parsing, and the difficulty to extend them later.

==== Preferable Use Cases

* Creating data
* Transforming data
* Define operations
* Execute actions
* Generating code
* Testing

==== Rating

* image:2_sun.png[] - for Simplicity of DSL design
* image:5_sun.png[] - for Elegance
* image:4_sun.png[] - for Usability
* image:5_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* allows almost any syntax
* it is easy to allow for some leniency
* very flexible and extendable
* parser libraries help to write readable parser code

|* no compile time checks
* no tooling support like code suggestions or autocomplete when using the DSL
* writing parsers must be learned
* having a dependency on a parser library
* difficult to extend at a later point in time
* hard to combine with other DSL types
|===
