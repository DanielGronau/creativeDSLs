== String-Parsing DSLs

In some cases, the host language doesn't allow to create the DSL syntax you would like. A string-parsing DSL gives you the freedom to write basically anything. One topic where traditional DSL categories are particularly bad is giving the user some leeway, e.g. concerning upper and lower case syntax, order of operations or the use of special characters like symbols. String-based DSLs can easily incorporate such leniency.

The downside is that these DSLs are hidden from the scrutiny of the compiler: There are no compile time checks, no hints for auto-completion etc., which means the user has to rely on the documentation. Another issue is writing the parser: Dissecting a string is usually more involved than collecting the data in other DSL types, although it is also no rocket science.

(((Regular Expressions)))

WARNING: Kotlin supports - like many languages - regular expressions, which can be seen as a kind of mini-parser. For small, isolated use cases they can be very convenient. However, employing them for larger problems can lead to code which is very hard to maintain, because this approach doesn't scale well. In my opinion, using regular expressions as full-blown "parsers" may be acceptable for prototypes and test environments, but not in production code.

=== Case Study: Forsyth–Edwards Notation

Before we dive into complicated problems requiring parsers, we will start with an easy example, where we need only a few string functions. If you don't play chess, you probably never heard of the https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation[Forsyth–Edwards Notation] (FEN):

.Forsyth–Edwards Notation
****
The Forsyth–Edwards Notation is a standard notation for describing the current position of pieces on a chessboard. It consists of a string of characters that represent the placement of the pieces, which are organized by rank and file. In FEN, uppercase letters are used to represent white pieces, and lowercase letters are used to represent black pieces. The digits 1-8 are used to represent empty squares, and a forward slash is used to separate ranks. FEN also includes information about:

* which player has the next move
* castling availability
* en passant capture availability
* number of half-moves without check or pawn moves (for the 50- or 75-move rule)
* number of moves played so far
****

Rows are separated by `/` and pieces have the usual names used in chess notation (like "Q" for a queen), plus "P" for pawn. To keep the string short, empty squares are written with a kind of run-length encoding, e.g. 3 empty fields are represented by a 3. The castling rights are given by "k" for king-side and "q" for queen-side, again upper-case for white and lower-case for black. If nobody can castle, a `-` is written instead. The en-passant field contains either a square like `b3` or again a `-`.

A FEN looks like this: `rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2`. If you put the rows one below the other, and expand the numbers to empty fields, you can "see" the board position:

[source,text]
----
rnbqkbnr
pp.ppppp
........
..p.....
....P...
.....N..
PPPP.PPP
RNBQKB.R
----

This is the `Position` class we want to create using a FEN string:

[source,kotlin]

----
enum class Piece(val symbol: String) {
    WhitePawn("P"), WhiteRook("R"), WhiteKnight("N"),
    WhiteBishop("B"), WhiteQueen("Q"), WhiteKing("K"),
    BlackPawn("p"), BlackRook("r"), BlackKnight("n"),
    BlackBishop("b"), BlackQueen("q"), BlackKing("k")
}

enum class Color(val symbol: String) {
    Black("b"), White("w")
}

data class Position(
    val pieces: Map<String, Piece>,
    val toMove: Color,
    val castling:List<Piece>,
    val enPassant: String,
    val fiftyMoves: Int,
    val move: Int) {

    private fun piecesFen() =
        (8 downTo 1).map {row ->
            var count = 0
            ('a' .. 'h').map { col ->
                val piece = pieces["$col$row"]
                when {
                    piece != null && count == 0 -> piece.symbol
                    piece != null && count != 0 ->
                        "$count${piece.symbol}".also { count = 0 }
                    col == 'h' -> "${count + 1}"
                    else -> "".also { count++ }
                }
            }.joinToString ("")
        }.joinToString ("/")

    private fun castlingFen() = when {
        castling.isEmpty() -> "-"
        else -> castling.map { it.symbol }.joinToString("")
    }

    fun FEN() = "${piecesFen()} ${toMove.symbol} " +
        "${castlingFen()} $enPassant $fiftyMoves $move"
}
----

The class contains already a function for generating a FEN - this is not required, but it makes testing much easier.

.Round-trip Tests
****
When you have code that transforms forth and back between different formats, it is convenient to write round-trip tests: You're providing test data for the "easiest" format, transform it to the other one(s) and back, and compare it with the original. Comparing data in the same format is easier and safer than comparing different ones - often even a simple string comparison is sufficient.
****

Now we can write the DSL function for parsing a FEN:

[source,kotlin]
----
fun readFEN(s: String): Position {
    operator fun <E> List<E>.component6(): E = this[5]
    val (piecesStr,
        toMoveStr,
        castlingStr,
        enPassantStr,
        fiftyMovesStr,
        movesStr) = s.split(" ")
    val pieces = mutableMapOf<String, Piece>()
    piecesStr.split("/").mapIndexed { index, row ->
        var count = 0
        row.forEach { ch ->
            when {
                ch.isDigit() -> count += ch.toString().toInt()
                else -> pieces["${"abcdefgh"[count]}${8 - index}"] =
                    Piece.values().find {
                        it.symbol == ch.toString()
                    }!!.also { count++ }
            }
        }
    }
    val toMove = Color.values().find { it.symbol == toMoveStr }!!
    val castling = when (castlingStr) {
        "-" -> emptyList()
        else -> castlingStr
            .map { ch ->
                Piece.values().find {
                    it.symbol == ch.toString()
                }!!
            }
    }
    return Position(
        pieces,
        toMove,
        castling,
        enPassantStr,
        fiftyMovesStr.toInt(),
        movesStr.toInt()
    )
}
----

The `component6()` function is needed as Kotlin supports only the destructuring of lists for up to five elements, but we need six (in the next line). The rest of the function deals with the parts individually, and creates the `Position` class. I omitted sanity checks for better readability.

In easy cases like this, it is probably overkill to write a parser or to use a parser library. The hardest part was to read the piece positions correctly, and this took just a few lines.

=== Case Study: Chemical Equations as Strings

In the last chapter, a hybrid DSL for chemical formulas was implemented, but the result wasn't as concise as a chemist would hope for. Wouldn't it be nice to just write `"2CH3OH -{zwsp}> (CH3)2O + H2O"` as a string, and be done with it?

Of course, that string must be evaluated, or in other words, we need to write a parser. There are many approaches to do this, and a lot of theory concerning different types of parsers, and efficient ways to implement them.

If you never worked with parsers, it can be a little confusing. Writing them by yourself is not really difficult, but boring and tedious, so most of the time using a library will be the better choice. Nevertheless, I think it is instructive to see how a simple parser works, so a naive manual implementation is presented first, before utilizing a parser combinator library.

First, the element names must be known:

[source,kotlin]
----
private val elements = setOf(
    "H", "He", "Li", "Be", "B", "C", "N", "O", // etc.
)
----

All the parser functions will have a similar return type, so this alias is used for convenience:

[source,kotlin]
----
typealias ParseResult<T> = Optional<Pair<T, String>>
----

What does this mean? Well, trying to parse information from a string can be successful or not. In this example, an empty `Optional` is returned when the parser got no result, but serious implementations often use more elaborate failure classes, which give detailed information about why and where the operation failed. When the parsing rule could be applied successfully, it is not enough to keep track of the result, but also of the remaining string (or the new position inside the original string). That's why a `Pair` is used in the alias.

We will assume that the input string is free of whitespaces, which can be already enforced by the top-level function calling the parser. Here are the two most basic functions:

[source,kotlin]
----
fun parsePattern(string: String, pattern: String): ParseResult<String> = when {
    string.startsWith(pattern) ->
        Optional.of(pattern to string.substring(pattern.length))
    else -> Optional.empty()
}

fun parseNum(string: String): ParseResult<Int> =
    Optional.of(
        string.takeWhile { it.isDigit() }.length
    ).filter { digitCount ->
        digitCount > 0
    }.map { digitCount ->
        string.substring(0, digitCount).toInt() to string.substring(digitCount)
    }
----

The easiest function is `parsePattern()`, which tries to find a given prefix in the string. `parseNum()` is slightly more involved, as it needs to determine the number of digits first. Except `parseElement()`, all other functions don't read directly from the string, but use these two and combine the results in certain ways - that's why this approach is known as "parser combinator". The first example for this "assembling" is the function for reading the equation arrow, which can be either `-{zwsp}>` or `<{zwsp}-{zwsp}>`:

[source,kotlin]
----
fun parseArrow(string: String): ParseResult<String> =
    parsePattern(string, "<->")
        .or { parsePattern(string, "->") }
----

Reading an element is not difficult, the only pitfall is that two-letter symbols must be checked before the one-letter symbols, else the function would just find `H` in a string starting with `He`.

WARNING: It is a common problem that two parsers could match for the same input. In most cases, the parser reading the longer prefix is the one you want to execute, so you have to make sure to evaluate it first.

[source,kotlin]
----
fun parseElement(string: String): ParseResult<Element> =
    findElement(string, 2).or {
        findElement(string, 1)
    }.map { (symbol, s) ->
        parseNum(s).map { (subscript, s1) ->
            Element(symbol, subscript) to s1
        }.orElseGet {
            Element(symbol, 1) to s
        }
    }

fun findElement(string: String, charCount: Int): ParseResult<String> =
    Optional.of(
        "$string##".substring(0, charCount)
    ).filter {
        elements.contains("$string##".substring(0, charCount))
    }.map { symbol ->
        symbol to string.substring(charCount)
    }
----

First, the `findElement()` function tries to find elements, first with two, and then - if this was unsuccessful - with one character. Prolonging the string with some characters (here `#`) avoids a possible `IndexOutOfBoundException`. The `map` block in `parseElement()` attempts to find a trailing number. If the number is found, it is used to construct the element, else the default subscript of 1 is used.

Now the groups can be tackled:

[source,kotlin]
----
fun parsePart(string: String): ParseResult<Part> =
    Optional.empty<Pair<Part, String>>()
        .or { parseElement(string) }
        .or { parseGroup(string) }

fun parseGroup(string: String): ParseResult<Group> =
    parsePattern(string, "(").map { (_, s1) ->
        generateSequence(parsePart(s1).orElse(null)) { (_, s2) ->
            parsePart(s2).orElse(null)
        }.toList()
    }.filter {
        it.isNotEmpty()
    }.flatMap { parts ->
        parsePattern(parts.last().second, ")").map { (_, s3) ->
            parts.map { it.first } to s3
        }
    }.map { (parts, s) ->
        parseNum(s).map { (subscript, s1) ->
            Group(parts, subscript) to s1
        }.orElseGet {
            Group(parts, 1) to s
        }
    }
----

The `parsePart()` method reads either an element or a group. The chain starts with an empty, but typed `Optional`, which is a trick to avoid casts for the more specialized return types of `parseElement()` and `parseGroup()`. The `parseGroup()` looks first for an opening parenthesis. Then it tries to read as many parts as possible. The `filter()` method ensures that an empty group `()` is not accepted. After this, it looks for a closing parenthesis. The final `map()` call handles an optional subscript, just like in `parseElement()`.

Now everything is there to assemble a molecule:

[source,kotlin]
----
fun parseMolecule(string: String): ParseResult<Molecule> =
    parseNum(string).or {
        Optional.of(1 to string)
    }.flatMap { (coefficient, s) ->
        Optional.of(
            generateSequence(parsePart(s).orElse(null)) { (_, s1) ->
                parsePart(s1).orElse(null)
            }.toList()
        ).filter {
            it.isNotEmpty()
        }.map { parts ->
            Molecule(coefficient, parts.map { it.first }) to
                parts.last().second
        }
    }
----

First, the function looks for a possible coefficient in front, else it uses 1 as default. Then it tries to read as many element or group parts as possible. If some parts were found, the molecule is build, else the parser fails.

This is the parser for gathering the left- and right-hand side of the equation:

[source,kotlin]
----
fun parseSide(string: String): ParseResult<List<Molecule>> =
    Optional.of(
        generateSequence(parseMolecule(string).orElse(null)) { (_, s1) ->
            parsePattern(s1, "+")
                .flatMap { (_, s2) -> parseMolecule(s2) }
                .orElse(null)
        }.toList()
    ).filter {
        it.isNotEmpty()
    }.map { list ->
        list.map { it.first } to list.last().second
    }
----

The function generates a sequence of `Pair<Molecule, String>` (while requiring that there is a `+` between the molecules), and converts it to a list. The `filter()` checks that the list is not empty, and the last `map()` call brings the return value in the right shape.

Now the parser for the whole equation can be written as follows:

[source,kotlin]
----
fun parseEquation(string: String): ParseResult<Equation> {
    return parseSide(string).flatMap { (lhs, s1) ->
        parseArrow(s1).flatMap { (arrow, s2) ->
            parseSide(s2).map { (rhs, s3) ->
                Equation(lhs, rhs, arrow == "<->") to s3
            }
        }
    }
}
----

It just reads the left-hand side, the arrow symbol, the right-hand side, and combines them. Now the only missing part is a `equation()` function, which is the only part of our DSL which will be exposed to the user:

[source,kotlin]
----
fun equation(string: String) = parseEquation(string.replace(" ", ""))
    .filter { it.second.isEmpty() }
    .map { it.first }
----

This function removes all spaces from the input string, calls the parser, checks that no "unparsed" string is left, and returns the result wrapped in an `Optional`. Again, an empty `Optional` indicates that some kind of error occurred. Now we can write e.g. `equation("3Ba(OH)2 + 2H3PO4 -> 6H2O + Ba3(PO4)2")`, which is as concise at it can get for an internal DSL.

As mentioned in the last chapter, a "real" chemical equation looks more like `3Ba(OH)~2~ + 2H~3~PO~4~ -> 6H~2~O + Ba~3~(PO~4~)~2~`, and with a few simple modifications, we could allow this syntax as well. Generally speaking, allowing the syntax of a String-based DSL to be more lenient is relatively easy, while other DSL categories often struggle with this kind of flexibility.

As already stated, writing such a parser manually isn't difficult. However, using a library has many advantages: It improves readability and maintainability, the code is easier to debug, you get more information when the parsing failed, and the library is usually better tested than our manual code.

To give you an impression how using a parser library looks like, I rewrote the example code using the https://github.com/h0tk3y/better-parse[better-parse] project, which is an example for the parser-combinator approach:

[source,kotlin]
----
val equationGrammar = object : Grammar<Equation>() {
    val ws by regexToken("\\s+", ignore = true)
    val reactsTo by literalToken("->")
    val reversibleTo by literalToken("<->")
    val plus by literalToken("+")
    val leftPar by literalToken("(")
    val rightPar by literalToken(")")
    val num by regexToken("\\d+")
    val symbol by token { cs, from ->
        when {
            elements.contains("$cs##".substring(from, from + 2)) -> 2
            elements.contains("$cs##".substring(from, from + 1)) -> 1
            else -> 0
        }
    }

    val arrow: Parser<Boolean> by (reactsTo asJust false) or
            (reversibleTo asJust true)
    val number: Parser<Int> by (num use { text.toInt() })
    val element: Parser<Element> by (symbol and optional(number))
        .map { (s, n) -> Element(s.text, n ?: 1) }
    val group: Parser<Group> by (skip(leftPar) and
            oneOrMore(parser(this::part)) and
            skip(rightPar) and
            optional(number))
        .map { (parts, n) -> Group(parts, n ?: 1) }
    val part: Parser<Part> = element or group
    val molecule: Parser<Molecule> = (optional(number) and oneOrMore(part))
        .map { (n, parts) -> Molecule(n ?: 1, parts) }
    val side: Parser<List<Molecule>> = separated(molecule, plus)
        .map { it.terms }
    override val rootParser: Parser<Equation> by (side and arrow and side)
        .map { (lhs, a, rhs) -> Equation(lhs, rhs, a) }
}

// calling an example string
val eq = equationGrammar.parseToEnd("3Ba(OH)2 + 2H3PO4 -> 6H2O + Ba3(PO4)2")
----

Going into the details of this specific library is beyond the scope of this book, the important point is how much using a parser-combinator library can improve readability. However, you can still recognize the same pieces of grammar, which are assembled in a similar way as in our original code.

=== Conclusion

String-based DSLs allow to use a very idiomatic syntax. The price to pay for this is a lack of compile-time checks and the complexity and overhead involved with parsing.

==== Preferable Use Cases

* Creating data
* Transforming data
* Define operations
* Execute actions
* Generating code
* Testing

==== Rating

* image:2_sun.png[] - for Simplicity of DSL design
* image:5_sun.png[] - for Elegance
* image:4_sun.png[] - for Usability
* image:5_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* allows almost any syntax
* very flexible and extendable
* parser libraries help to write readable parser code

|* no compile time checks
* no IDE support like code suggestions or autocomplete when using the DSL
* writing parsers must be learned
* dependency on a parser library
* hard to combine with other DSL types
|===
