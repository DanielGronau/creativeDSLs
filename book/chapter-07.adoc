== Loan Pattern DSL

The Loan Pattern DSL type is Kotlin's common answer to the Builder Pattern, and covers the same use cases. Instead of having a mutable builder using method chaining, we have a mutable builder class exposing its members using the Loan Pattern. The main ingredients to make it work are extension methods and the trailing lambda syntax.

In this chapter, we will first write a more convenient replacement for the `HttpRequest.Builder` presented in the last chapter. Next, we discuss and example for a chained loan pattern. If you have control over the business class you want to construct, you can use a library like AutoDSL to generate a DSL for you. We will explore this in the second part of this chapter.

=== Case Study: HttpRequest

As already shown in the last chapter, `HttpRequest` comes already with a builder, which looks like this:

[source,kotlin]
----
val request = HttpRequest.newBuilder(URI.create("https://acme.com:9876/products"))
    .GET()
    .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
    .header("Accept-Encoding", "gzip, deflate")
    .timeout(Duration.ofSeconds(5L))
    .build()
----

This doesn't look too bad, but there is some noise in form of the `newBuilder()` and `build()` calls, and the other method calls are actually assignments in disguise. The question is how we can improve this in Kotlin.

My suggestion for a better syntax looks like this:

[source,kotlin]
----
val request = httpRequest("https://acme.com:9876/products") {
    method = GET
    headers {
        "Content-Type" .. "application/x-www-form-urlencoded; charset=UTF-8"
        "Accept-Encoding" .. "gzip, deflate"
    }
    timeout = 5 * SECONDS
}
----

There are no more `newBuilder()` and `build()` calls, the assignments are assignments, headers became their own section and the duration can be calculated. For convenience, you have now the choice whether to specify the web-address as `String` or `URI` (the example shows only `String`).

As you might have guessed, `httpRequest` is a method employing the Loan Pattern: It initializes a builder class, exposes it as a receiver, and takes care of the final `build()` call. Also note how it takes care of a mandatory field (in our case the address) by requiring it as an explicit argument. We have two versions of the function, depending on how the address is specified:

[source,kotlin]
----
fun httpRequest(uri: URI, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(uri).apply(block).build()

fun httpRequest(address: String, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(URI.create(address)).apply(block).build()
----

The builder contains some mutable fields, and a `build()`-Method to construct the `HttpRequest`:

[source,kotlin]
----
typealias HttpMethod = Pair<String, BodyPublisher?>

class HttpRequestBuilder(var uri: URI) {

    var method: HttpMethod? = null
    var timeout: Duration? = null
    var expectContinue: Boolean? = null
    var version: HttpClient.Version? = null
    private val headers = mutableMapOf<String, String>()

    ...

    fun build(): HttpRequest =
        with(HttpRequest.newBuilder(uri)) {
            // set the values
            // ...
            this.build()
        }

    ...
}
----

The `headers` field can't be set directly, because we want to use a nested structure here. The `headers()` method works analogous to the `httpRequest()` method, and exposes the inner `Headers` class, which in turn enables to fill the `headers` field. The range operator `..` was chosen to collect the key-value-pairs because it looks like `:`. As discussed in the fourth chapter, we don't want that you can see all the `HttpRequestBuilder` fields from its inner class `Headers`, and that's why we use te `@DslMarker` mechanism to limit the scope inside of `Headers`.

[source,kotlin]
----
@DslMarker
annotation class HttpRequestDsl

@HttpRequestDsl
class HttpRequestBuilder(var uri: URI) {
    ...
    private val headers = mutableMapOf<String, String>()
    ...
    fun headers(block: Headers.() -> Unit) {
        Headers().apply(block)
    }
    ...
    @HttpRequestDsl
    inner class Headers {
        operator fun String.rangeTo(value: String) {
            this@HttpRequestBuilder.headers[this@rangeTo] = value
        }
    }
   ...
}
----

Next, there are some cfields and methods required in order to simplify seting the HTTP method. However, you can still define your own ones, e.g. `method = "OPTION" to someBodyPublisher`:

[source,kotlin]
----
typealias HttpMethod = Pair<String, BodyPublisher?>

class HttpRequestBuilder(var uri: URI) {

    var method: HttpMethod? = null
    ...
    val GET: HttpMethod = "GET" to null
    val DELETE: HttpMethod = "DELETE" to null
    fun PUT(bp: BodyPublisher): HttpMethod = "PUT" to bp
    fun POST(bp: BodyPublisher): HttpMethod = "POST" to bp
    ...
}
----

In order to simplify the definition of a `Duration`, there are some operator overloading functions defined. Note that these are only visible inside of `HttpRequestBuilder`, so name clashes can be avoided.

[source,kotlin]
----
class HttpRequestBuilder(var uri: URI) {
    ...
    operator fun Long.times(unit: TemporalUnit): Duration =
        Duration.of(this, unit)

    operator fun Int.times(unit: TemporalUnit): Duration =
        Duration.of(this.toLong(), unit)
}
----

And that's almost it, we covered everything except some details of the `build()` method. Here is the complete code:

[source,kotlin]
----
fun httpRequest(uri: URI, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(uri).apply(block).build()

fun httpRequest(uri: String, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(URI.create(uri)).apply(block).build()

typealias HttpMethod = Pair<String, BodyPublisher?>

@DslMarker
annotation class HttpRequestDsl

@HttpRequestDsl
class HttpRequestBuilder(var uri: URI) {

    var method: HttpMethod? = null
    var timeout: Duration? = null
    var expectContinue: Boolean? = null
    var version: HttpClient.Version? = null
    private val headers = mutableMapOf<String, String>()

    val GET: HttpMethod = "GET" to null
    val DELETE: HttpMethod = "DELETE" to null
    fun PUT(bp: BodyPublisher): HttpMethod = "PUT" to bp
    fun POST(bp: BodyPublisher): HttpMethod = "POST" to bp

    fun headers(block: Headers.() -> Unit) {
        Headers().apply(block)
    }

    fun build(): HttpRequest =
        with(HttpRequest.newBuilder(uri)) {
            headers.forEach { (key, value) -> header(key, value) }
            timeout?.let { timeout(it) }
            expectContinue?.let { expectContinue(it) }
            version?.let { version(it) }
            method?.let {
                when (method) {
                    GET -> GET()
                    DELETE -> DELETE()
                    else -> method(method!!.first, method!!.second)
                }
            }
            this.build()
        }

    @HttpRequestDsl
    inner class Headers {
        operator fun String.rangeTo(value: String) {
            this@HttpRequestBuilder.headers[this@rangeTo] = value
        }
    }

    operator fun Long.times(unit: TemporalUnit): Duration =
        Duration.of(this, unit)

    operator fun Int.times(unit: TemporalUnit): Duration =
        Duration.of(this.toLong(), unit)
}
----

=== Chained Loan Pattern

It is possible to have a chained version of the Loan Pattern, but it depends on the use case whether it looks better than the chained Builder Pattern. I would argue that in case of the SQL DSL from the last chapter the chained version wouldn't be an improvement. Here is how it could look like:

[source,kotlin]
----
SELECT {
    +"p.firstName"
    +"p.lastName"
    +"p.income"
}.FROM {
    "Person" AS "p"
    JOIN {
        "Address" AS "a"
        ON("p.addressId","a.id")
    }
}.WHERE {
   "p.age > 20" AND "p.age <= 40" AND "a.city = 'London'"
}
----

I don't provide an implementation, as there is not much new to learn. The code is very similar to the one from the previous section, with the addition of some infix functions, which were covered in chapter 5.

=== AutoDSL

As this kind of DSL is very common, and its structure is quite predictable, it shouldn't come as a surprise that there exist libraries for deriving such DSLs automatically. At this point we will cover the https://github.com/F43nd1r/autodsl[AutoDSL] library.

WARNING: Please make sure to use the right GitHub project. There is an older library called "AutoDsl", which was the inspiration for the project covered here. Unfortunately, it is no longer maintained, and doesn't work for Kotlin 1.4 or newer.



=== Conclusion

The Loan Pattern DSLs have several advantages over the classic Builder Pattern style, and became very common in Kotlin. There are sill

[cols="2a,2a"]
|===
|Pros |Cons

|* easy to read, especially for nested constructions
* very flexible and intuitive
* can be autogenerated (e.g. using https://github.com/F43nd1r/autodsl[AutoDSL])


|* behavior is harder to control than for the Builder Pattern
* safe usage can't be always guaranteed
* might be difficult to use from Java client code
|===