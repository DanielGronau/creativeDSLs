== Loan Pattern DSLs

The Loan Pattern DSL type is Kotlin's common answer to the Builder Pattern, and covers the same use cases. Instead of having a mutable builder using method chaining, we have a mutable builder class exposing its members using the Loan Pattern. The main ingredients to make it work are extension methods and the trailing lambda syntax.

In this chapter, we will first write a more convenient replacement for the `HttpRequest.Builder` presented in the last chapter. Next, we discuss and example for a chained loan pattern. If you have control over the business class you want to construct, you can use a library like AutoDSL to generate a DSL for you. We will explore this in the second part of this chapter.

=== Case Study: HttpRequest

As already shown in the last chapter, `HttpRequest` comes already with a builder, which looks like this:

[source,kotlin]
----
val request = HttpRequest.newBuilder(URI.create("https://acme.com:9876/products"))
    .GET()
    .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
    .header("Accept-Encoding", "gzip, deflate")
    .timeout(Duration.ofSeconds(5L))
    .build()
----

This doesn't look too bad, but there is some noise in form of the `newBuilder()` and `build()` calls, and the other method calls are actually assignments in disguise. The question is how we can improve this in Kotlin.

Here is a suggestion for an improved syntax:

[source,kotlin]
----
val request = httpRequest("https://acme.com:9876/products") {
    method = GET
    headers {
        "Content-Type" .. "application/x-www-form-urlencoded; charset=UTF-8"
        "Accept-Encoding" .. "gzip, deflate"
    }
    timeout = 5 * SECONDS
}
----

There are no more `newBuilder()` and `build()` calls, the assignments are assignments, headers have their own subsection and durations can be calculated. For convenience, you have now the choice whether to specify the web-address as `String` or `URI` (the example shows only `String`).

As you might have guessed, `httpRequest` is a method employing the Loan Pattern: It initializes a builder class, exposes it as a receiver, and takes care of the final `build()` call. Also note how it takes care of a mandatory field (in our case the address) by requiring it as an explicit argument. We have two versions of the function, depending on how the address is specified:

[source,kotlin]
----
fun httpRequest(uri: URI, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(uri).apply(block).build()

fun httpRequest(address: String, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(URI.create(address)).apply(block).build()
----

The builder contains some mutable fields, and a `build()`-Method to construct the `HttpRequest`:

[source,kotlin]
----
typealias HttpMethod = Pair<String, BodyPublisher?>

class HttpRequestBuilder(var uri: URI) {

    var method: HttpMethod? = null
    var timeout: Duration? = null
    var expectContinue: Boolean? = null
    var version: HttpClient.Version? = null
    private val headers = mutableMapOf<String, String>()

    ...

    fun build(): HttpRequest =
        with(HttpRequest.newBuilder(uri)) {
            // set the values
            // ...
            this.build()
        }

    ...
}
----

The `headers` field can't be set directly, because we want to use a nested structure here. The `headers()` method works analogous to the `httpRequest()` method, and exposes the inner `Headers` class, which in turn enables to fill the `headers` field. The range operator `..` was chosen to collect the key-value-pairs because it looks like `:`. As discussed in the fourth chapter, we don't want that you can see all the `HttpRequestBuilder` fields from its inner class `Headers`, and that's why we use te `@DslMarker` mechanism to limit the scope inside of `Headers`.

[source,kotlin]
----
@DslMarker
annotation class HttpRequestDsl

@HttpRequestDsl
class HttpRequestBuilder(var uri: URI) {
    ...
    private val headers = mutableMapOf<String, String>()
    ...
    fun headers(block: Headers.() -> Unit) {
        Headers().apply(block)
    }
    ...
    @HttpRequestDsl
    inner class Headers {
        operator fun String.rangeTo(value: String) {
            this@HttpRequestBuilder.headers[this@rangeTo] = value
        }
    }
   ...
}
----

Next, there are some fields and methods required in order to simplify setting the HTTP method. However, you can still define your own ones, e.g. `method = "OPTION" to someBodyPublisher`:

[source,kotlin]
----
typealias HttpMethod = Pair<String, BodyPublisher?>

class HttpRequestBuilder(var uri: URI) {

    var method: HttpMethod? = null
    ...
    val GET: HttpMethod = "GET" to null
    val DELETE: HttpMethod = "DELETE" to null
    fun PUT(bp: BodyPublisher): HttpMethod = "PUT" to bp
    fun POST(bp: BodyPublisher): HttpMethod = "POST" to bp
    ...
}
----

In order to simplify the definition of a `Duration`, there are some operator overloading functions defined. Note that these are only visible inside of `HttpRequestBuilder`, so name clashes can be avoided.

[source,kotlin]
----
class HttpRequestBuilder(var uri: URI) {
    ...
    operator fun Long.times(unit: TemporalUnit): Duration =
        Duration.of(this, unit)

    operator fun Int.times(unit: TemporalUnit): Duration =
        Duration.of(this.toLong(), unit)
}
----

And that's almost it, we covered everything except some details of the `build()` method. Here is the complete code:

[source,kotlin]
----
fun httpRequest(uri: URI, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(uri).apply(block).build()

fun httpRequest(uri: String, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(URI.create(uri)).apply(block).build()

typealias HttpMethod = Pair<String, BodyPublisher?>

@DslMarker
annotation class HttpRequestDsl

@HttpRequestDsl
class HttpRequestBuilder(var uri: URI) {

    var method: HttpMethod? = null
    var timeout: Duration? = null
    var expectContinue: Boolean? = null
    var version: HttpClient.Version? = null
    private val headers = mutableMapOf<String, String>()

    val GET: HttpMethod = "GET" to null
    val DELETE: HttpMethod = "DELETE" to null
    fun PUT(bp: BodyPublisher): HttpMethod = "PUT" to bp
    fun POST(bp: BodyPublisher): HttpMethod = "POST" to bp

    fun headers(block: Headers.() -> Unit) {
        Headers().apply(block)
    }

    fun build(): HttpRequest =
        with(HttpRequest.newBuilder(uri)) {
            headers.forEach { (key, value) -> header(key, value) }
            timeout?.let { timeout(it) }
            expectContinue?.let { expectContinue(it) }
            version?.let { version(it) }
            method?.let {
                when (method) {
                    GET -> GET()
                    DELETE -> DELETE()
                    else -> method(method!!.first, method!!.second)
                }
            }
            this.build()
        }

    @HttpRequestDsl
    inner class Headers {
        operator fun String.rangeTo(value: String) {
            this@HttpRequestBuilder.headers[this@rangeTo] = value
        }
    }

    operator fun Long.times(unit: TemporalUnit): Duration =
        Duration.of(this, unit)

    operator fun Int.times(unit: TemporalUnit): Duration =
        Duration.of(this.toLong(), unit)
}
----

=== AutoDSL

As this kind of DSL is very common, and its structure is quite predictable, it shouldn't come as a surprise that there exist libraries for deriving such DSLs automatically. At this point we will cover the https://github.com/F43nd1r/autodsl[AutoDSL] library, which has to be added as an annotation processor (either via kapt or KSP). To do this, please follow the description on the GitHub project page.

WARNING: Please make sure to use the right GitHub project. There is an older library called "AutoDsl", which was the inspiration for the project covered here. Unfortunately, it is no longer maintained, and doesn't work for Kotlin 1.4 or newer.

Remember all the work we put into `HttpRequestBuilder` in the last section? Let's see what we can get "for free" instead. Note that we can't annotate the `HttpRequest` class itself, so we are auto-generating a builder class, and hence have to call the `build()` method at the end. Usually, for our own classes we wouldn't do this, but annotate them directly.

[source,kotlin]
----
typealias HttpMethod = Pair<String, HttpRequest.BodyPublisher?>

val GET: HttpMethod = "GET" to null
val DELETE: HttpMethod = "DELETE" to null
fun PUT(bp: HttpRequest.BodyPublisher): HttpMethod = "PUT" to bp
fun POST(bp: HttpRequest.BodyPublisher): HttpMethod = "POST" to bp

@AutoDsl
data class Header(val key: String, val value: String)

@AutoDsl
data class HttpRequestBuilder(
    val uri: URI,
    val method: HttpMethod = GET,
    val timeout: Duration? = null,
    val expectContinue: Boolean? = null,
    val version: HttpClient.Version? = null,
    @AutoDslSingular("header")
    val headers: List<Header> = listOf()
) {
    fun build(): HttpRequest =
        with(HttpRequest.newBuilder(uri)) {
            headers.forEach { (key, value) -> header(key, value) }
            timeout?.let { timeout(it) }
            expectContinue?.let { expectContinue(it) }
            version?.let { version(it) }
            method.let {
                when (method) {
                    GET -> GET()
                    DELETE -> DELETE()
                    else -> method(method.first, method.second)
                }
            }
            this.build()
        }
}
----

It can't get much simpler than that: All classes which should be included in the DSL are marked with the `@AutoDsl` annotation, and when there are lists that should be specified element-wise and not as a whole, you add an `@AutoDslSingular` annotation containing the name of the helper method.

If you compile the project using IntelliJ IDEA, you should find the generated classes `HeaderDsl` and `HttpRequestBuilderDsl` somewhere in the `target/generated-sources/...` folder, depending on how you integrated the AutoDSL processor, and how you setup your project).

The example call from the previous section would now like this:

[source,kotlin]
----
val request = httpRequestBuilder {
    uri = URI.create("https://acme.com:9876/products")
    method = GET
    header {
        key = "Content-Type"
        value = "application/x-www-form-urlencoded; charset=UTF-8"
    }
    header {
        key = "Accept-Encoding"
        value = "gzip, deflate"
    }
    timeout = Duration.ofSeconds(5)
}.build()
----

Granted, the code isn't quite as comfortable and concise, but it comes close, and looks definitely nicer and more intuitive than a traditional builder. AutoDSL also checks that mandatory fields like `uri` are set, and throws an `IllegalStateException` otherwise.

=== Chained Loan Pattern

It is possible to have a "chained" version of the Loan Pattern, but it depends on the use case whether it looks better than the chained Builder Pattern. I would argue that in case of the SQL DSL from the last chapter the chained version wouldn't be an improvement. Here is how it could look like:

[source,kotlin]
----
val query = SELECT {
    +"p.firstName"
    +"p.lastName"
    +"p.income"
}.FROM {
    "Person" AS "p"
    JOIN {
        "Address" AS "a"
        ON("p.addressId","a.id")
    }
}.WHERE {
    +"p.age > 20"
    +"p.age <= 40"
    +"a.city = 'London'"
}.build()
----

The code to implement this DSL could look like this (sanity checks were omitted for brevity):

[source,kotlin]
----
fun SELECT(body: SelectBody.() -> Unit) =
    SelectClause(SelectBody().apply(body).columns)

class SelectBody {
    val columns = mutableListOf<String>()
    operator fun String.unaryPlus() { columns += this }
}

class SelectClause(val columns : List<String>) {
    fun FROM(body: FromBody.() -> Unit) =
        FromBody().apply(body).let{
            FromClause(columns, it.tableName, it.joinClauses)
        }
}

typealias NameWithAlias = Pair<String, String?>

class FromBody {
    var tableName: NameWithAlias = "" to null
    val joinClauses  = mutableListOf<Triple<NameWithAlias, String, String>>()

    operator fun String.unaryPlus() { tableName = this to null }
    infix fun String.AS(that: String) { tableName = this to that }

    fun JOIN(body: JoinBody.() -> Unit) {
        JoinBody().apply(body).also {
            joinClauses += Triple(it.tableName, it.firstColumn, it.secondColumn)
        }
    }
}

data class FromClause(
    val columns: List<String>,
    val tableName: NameWithAlias,
    val joinClauses: List<Triple<NameWithAlias, String, String>>
) {
    fun WHERE(body: WhereBody.() -> Unit) =
        WhereClause(columns, tableName, joinClauses, WhereBody().apply(body).conditions)
    fun build() = build(columns, tableName, joinClauses, listOf())
}

class JoinBody {
    var tableName: NameWithAlias = "" to null
    var firstColumn = ""
    var secondColumn = ""

    operator fun String.unaryPlus() { tableName = this to null }
    infix fun String.AS(that: String) { tableName = this to that }

    fun ON(firstColumn: String, secondColumn: String) {
        this.firstColumn = firstColumn
        this.secondColumn = secondColumn
    }
}

class WhereBody {
    val conditions = mutableListOf<String>()
    operator fun String.unaryPlus() { conditions += this }
}

data class WhereClause(
    val columns: List<String>,
    val tableName: NameWithAlias,
    val joinClauses: List<Triple<NameWithAlias, String, String>>,
    val conditions: List<String>
) {
    fun build() = build(columns, tableName, joinClauses, conditions)
}

private fun build(
    columns: List<String>,
    tableName: NameWithAlias,
    joinClauses: List<Triple<NameWithAlias, String, String>>,
    conditions: List<String>
): String {
    // as in chapter 6
}
----

It is important to have different classes for the body of a clause, and the result. So the receiver for the `SELECT` function is the `SelectBody` class, but the result of the call is a `SelectClause`. This is because we want to be able to call different functions in both classes, e.g. the `SelectBody` allows to add columns, but `SelectClause` can call the `FROM` function. It would be very confusing and unsafe to have this functionality in a single class.

Also, the explicit call to the `build()` function is necessary in this example, because we don't know if the chain should be stopped after the FROM or after the WHERE. In use cases where there is only one possible exit point, the `build()` call could be performed internally.

=== Builder Type Inference

In some cases, the compiler can improve its type inference by inspecting the method calls inside the trailing lambda block. Since Kotlin 1.7.0, this feature is enabled by default, but in older versions you can turn in on using the  `-Xenable-builder-inference` compiler option. There is no real drawback using this feature, but if you want to look into the details, you can check out the https://kotlinlang.org/docs/using-builders-with-builder-inference.html[Kotlin Documentation - Using builders with builder type inference].

=== Conclusion

The Loan Pattern DSLs have several advantages over the classic Builder Pattern style, and became very common in Kotlin. It really shines when dealing with nested structures, but struggles a bit, when the operations inside the block become a little more involved than simple assignments.

==== Preferable Use Cases

* Creating data
* Transforming data
* Execute actions
* Generating code
* Testing

==== Rating

* image:4_sun.png[] - for Simplicity of DSL design
* image:4_sun.png[] - for Elegance
* image:4_sun.png[] - for Usability
* image:5_sun.png[] - for Application Scope

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* easy to read, especially for nested constructions
* very flexible and intuitive
* can be autogenerated (e.g. using https://github.com/F43nd1r/autodsl[AutoDSL])


|* behavior is harder to control than for the Builder Pattern
* safe usage can't be always guaranteed
* might be difficult to use from Java client code
|===