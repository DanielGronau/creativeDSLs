== Introduction

=== What is a DSL?

> A Domain-Specific Language (DSL) is a computer language that's targeted to a particular kind of problem, rather than a general purpose language that's aimed at any kind of software problem.
-- Martin Fowler, Domain-Specific Languages Guide

The intention for writing a DSL is to make a certain domain more accessible, to make it easier to read and write, to avoid mistakes, and sometimes to follow established standards or conventions (e.g. SQL for database access, or mathematical notation). The target audience for DSLs can be the authors themselves, library users, or people who have domain knowledge, but do usually no or just a little programming. Sometimes it is sufficient when experts can read and understand a DSL, in order to check correctness or to give feedback.

Typical use cases for DSLs include modelling business logic, e.g. trades for a financial company, and help communicating at the boundaries of the system, which includes database access, serialization, web connectivity or UI. Then there are DSLs that "calculate" something in some sense. Other common applications for DSLs are testing and logging. There are DSLs for code generation, or even for writing DSLs.

=== Internal and External DSLs

This books discusses DSLs which are embedded into Kotlin, and are therefore limited to the existing expressions of the language. These are _internal DSLs_ (or "embedded DSLs"). One major advantage is that these DSL don't need special treatment, there are no extra steps needed like reading and parsing files, so they fit seamless with the rest of the code. An edge case are DSLs realized entirely inside strings, the way e.g. regular expressions work: While they are technically internal DSLs, they feel and behave more like external DSLs, because the "embedding" in the language is very shallow.

One disadvantage of internal DSLs is the limitation of the syntax inherited by the host language. Kotlin allows great freedom for DSL design, especially compared to Java. Nevertheless, it is still possible that the language is not expressive enough to design the DSL you need. In this case _external DSLs_ are an option: They have their own rules and syntax, and require lexers, parsers etc. This leads to a larger overhead compared to internal DSLs. However, writing external DSLs has become much easier recently by new libraries and frameworks, and improved tooling.

=== ((Code Generation)) for Internal DSLs

A common problem in DSL design is combinatorial explosion: Take for example a DSL for physical quantities, and all the possible results when multiplying or dividing them. In order to achieve a pleasing syntax, but avoid illegal conversions you might have to write lots of boilerplate code. In such cases, code generation can help to get the job done, even if it seemed hopeless at the first glance.

There are also libraries creating DSLs for you. If you need a well-known style of DSL, you just have to describe what you need (e.g. by annotating your business classes accordingly), and the library will generate the DSL code for you. An example for this approach is https://github.com/F43nd1r/autodsl[AutoDSL for Kotlin]

=== Common use cases for DSLs

While it is hard to get a clear-cut separation between the different types of use cases, it is still helpful to have these. In particular, every DSL category has use cases it can model better than others. Here is a list:

* Creating data
* Transforming data
* Define operations
* Execute actions
* Generating code
* Testing
* Logging

=== DSL Design Principles

There are a few general principles an internal DSL should follow:

* *Conciseness*: The DSL syntax should be shorter than the original one
* *Consistency*: The DSL syntax should stick to a certain style, similar tasks should require a similar syntax
* *Coverage*: The DSL needs to cover the problem domain, there should be no gaps, but also no overreach into other areas
* *Usability*: The DSL should be easy, safe and intuitive to use
* *Modularity*: If it makes sense to use a part of the DSL on its own, it should be easy to do so
* *Openness*: The DSL should interact well with non-DSL code, and should allow custom extensions where it makes sense
* *Maintainability*: The DSL code should be easy to read and to maintain

=== Kotlin and DSLs

At this point, it makes sense to discuss the relationship of the Kotlin language itself  with DSLs. The language has a very clean and readable syntax, and is often more expressive than Java. Many language features seem to lead naturally to DSLs, there is no clear boundary between "everyday code" and DSLs, and I'm sure this is a conscious design choice. I think this concept plays a big role in the success of the language, especially as it allows to adapt and improve existing Java code very easily and organically by creating miniature DSLs on the fly.

