== Real-World DSL Examples

> Few things are harder to put up with than the annoyance of a good example.
> -- Mark Twain

In this chapter, we will look at some interesting and successful DSLs, characterize them, look at interesting details, and maybe even suggest some improvements. I encourage you to take a closer look at these projects and learn how they build coherent DSLs with sometimes seemingly "impossible" features.

=== KotlinPoet

(((KotlinPoet)))
https://square.github.io/kotlinpoet/[KotlinPoet]footnote:[KotlinPoet: https://square.github.io/kotlinpoet] is a source code generator for Kotlin, and the sister project to JavaPoet. We used it in Chapter 12 to generate sources for operations on physical quantities, for example.

The library closely follows the syntax of JavaPoet, which is written in Java, and I think this was the right decision. The builder pattern works quite well for this purpose. This is the introductory example on the KotlinPoet homepage:

[source,kotlin]
.https://square.github.io/kotlinpoet Hello World Example
----
class Greeter(val name: String) {
  fun greet() {
    println("""Hello, $name""")
  }
}

fun main(vararg args: String) {
  Greeter(args[0]).greet()
}
----

[source,kotlin]
.https://square.github.io/kotlinpoet Code Generation of the Example
----
val greeterClass = ClassName("", "Greeter")
val file = FileSpec.builder("", "HelloWorld")
  .addType(
    TypeSpec.classBuilder("Greeter")
      .primaryConstructor(
        FunSpec.constructorBuilder()
          .addParameter("name", String::class)
          .build()
      )
      .addProperty(
        PropertySpec.builder("name", String::class)
          .initializer("name")
          .build()
      )
      .addFunction(
        FunSpec.builder("greet")
          .addStatement("println(%P)", "Hello, \$name")
          .build()
      )
      .build()
  )
  .addFunction(
    FunSpec.builder("main")
      .addParameter("args", String::class, VARARG)
      .addStatement("%T(args[0]).greet()", greeterClass)
      .build()
  )
  .build()

file.writeTo(System.out)
----

If KotlinPoet were a standalone library, I would rather use a Loan Pattern DSL instead:

[source,kotlin]
----
val greeterClass = ClassName("", "Greeter")
val exampleFile = file("", "HelloWorld") {
    clazz("Greeter") {
        primaryConstructor = constructor {
            parameter("name", String::class)
        }
        property("name", String::class) {
            initializer("name")
        }
        function("greet") {
            statement("println(%P)", "Hello, \$name")
        }
    }
    function("main") {
        parameter("args", String::class, VARARG)
        statement("%T(args[0]).greet()", greeterClass)
    }
}
----

I think the Loan Pattern style is easier to read because it shows the nested structures more clearly. As mentioned above, there were good reasons to stick with the builder pattern approach, but it would be nice to have the option to use something closer to my suggestion.

=== Gradle .kts

(((Gradle)))
https://gradle.org/[Gradle]footnote:[Gradle: https://gradle.org](((Gradle))) is an amazing build system. Unlike descriptive approaches like the XML-based https://maven.apache.org[Apache Maven]footnote:[Apache Maven: https://maven.apache.org](((Apache Maven))), the build process is "programmable", which gives the user a lot of flexibility.

However, the original Gradle implementation was written in Groovy(((Groovy))) - at the time probably the best choice for writing an expressive DSL in the Java ecosystem. Unfortunately, the Groovy language comes with its own set of problems. It is a scripted language with a weak type system, and as a result, IDE features such as autocompletion, content assistance, source navigation, quick documentation, and refactoring support are limited.

To address these issues, the Gradle team decided to provide an alternative DSL based on Kotlin script (.kts). Obviously, the new DSL should look very similar to the old Groovy style to make the transition as smooth as possible. I think the Kotlin DSL was a resounding success in this regard. Here is a comparison, taken from the https://docs.gradle.org/current/userguide/migrating_from_groovy_to_kotlin_dsl.html[Gradle User Guide: Migrating build logic from Groovy to Kotlin]footnote:[Gradle Migration: https://docs.gradle.org/current/userguide/migrating_from_groovy_to_kotlin_dsl.html]:

[source,groovy]
.Groovy
----
plugins {
    id 'java-library'
}
dependencies {
    implementation 'com.example:lib:1.1'
    runtimeOnly 'com.example:runtime:1.0'
    testImplementation('com.example:test-support:1.3') {
        exclude(module: 'junit')
    }
    testRuntimeOnly 'com.example:test-junit-jupiter-runtime:1.3'
}
----

[source,kotlin]
.Kotlin Script
----
plugins {
    `java-library`
}
dependencies {
    implementation("com.example:lib:1.1")
    runtimeOnly("com.example:runtime:1.0")
    testImplementation("com.example:test-support:1.3") {
        exclude(module = "junit")
    }
    testRuntimeOnly("com.example:test-junit-jupiter-runtime:1.3")
}
----

At first glance, it is hard to tell which is which. There are parts of the DSLs that deviate more, but then it looks more like a conscious decision to clean up and standardize the syntax than a limitation of the language.

The Kotlin script DSL itself mainly uses the Loan pattern. There are two notations for defining dependencies: The example shows the "string notation", which is a string parsing DSL. Alternatively, you can use the "map notation", which looks like this: `implementation(group = "com.example", name = "lib", version = "1.1")`.

In my opinion, Gradle is a good example of how Kotlin DSLs can help modernize an already established and successful solution without causing major disruptions.

=== Kotest

(((Kotest)))
https://kotest.io/[Kotest]footnote:[Kotest: https://kotest.io] is a widely used testing framework for Kotlin, and it is interesting to compare it with the most popular Java testing framework, which is https://junit.org/junit5/[JUnit]footnote:[JUnit: https://junit.org/junit5](((JUnit))).

First of all, Kotest provides a plethora of different https://kotest.io/docs/framework/testing-styles.html[testing styles]footnote:[Kotest - Testing Styles: https://kotest.io/docs/framework/testing-styles.html] (called "specs"), and is much less opinionated in this regard than JUnit. For the sake of brevity, I'll use `StringSpec` for the following examples:

[source,kotlin]
.https://kotest.io/docs/framework/testing-styles.html#string-spec
----
class MyTests : StringSpec({
    "strings.length should return size of string" {
        "hello".length shouldBe 5
    }
})
----

Unlike JUnit, the individual tests are not functions in the body of the test class, but expressions within the lambda argument of the respective `...Spec` superclass. This design makes Kotest very flexible and allows dynamic test creation:

[source,kotlin]
----
class LogicTest : StringSpec({

    val xorTable = listOf(
        Triple(true, true, false),
        Triple(true, false, true),
        Triple(false, true, true),
        Triple(false, false, false)
    )

    for((x, y, z) in xorTable) {
       "'$x' xor '$y' should be '$z'" {
           x xor y shouldBe z
       }
    }
})

// Runs 4 tests successfully:
// 'true' xor 'true' should be 'false'
// 'true' xor 'false' should be 'true'
// 'false' xor 'true' should be 'true'
// 'false' xor 'false' should be 'false'
----

Of course, you can do something similar in JUnit by using the `@ParameterizedTest` annotation instead of `@Test`, and if you need even more flexibility, there is a `DynamicTest.dynamicTest()` method that takes a lambda argument. The difference, however, is that Kotest doesn't require special constructs in such cases, but allows the user to take advantage of existing language features. Obviously, doing more with less helps to reduce the <<#congnitive_load,cognitive load>> (((Cognitive Load))) while learning to use the framework.

Kotest can be categorized as <<#quasi_lingual_dsls,quasi-lingual DSL>>(((Quasi-Lingual DSLs))), where many parts mimic natural language:

[source,kotlin]
.https://kotest.io/docs/framework/exceptions.html
----
val exception = shouldThrow<IllegalAccessException> {
   // code in here that you expect to throw an IllegalAccessException
}

exception.message should startWith("Something went wrong")
----

=== MockK

(((MockK)))
Mocking, spying, stubbing, and argument capture are essential for writing concise and expressive unit tests. In Java, libraries such as https://site.mockito.org/[Mockito]footnote:[Mockito: https://site.mockito.org/] are very popular, but face some challenges when dealing with Kotlin language features such as objects, top-level functions, and coroutines.

https://mockk.io/[MockK] is an amazing mocking framework for Kotlin, and features a very intuitive hybrid DSL. Here is a very simple example from the documentation:

[source,kotlin]
.https://mockk.io/
----
val car = mockk<Car>()

every { car.drive(Direction.NORTH) } returns Outcome.OK

car.drive(Direction.NORTH) // returns OK

verify { car.drive(Direction.NORTH) }

confirmVerified(car)
----

The library has already been mentioned in <<#quasi_lingual_dsls,Chapter 12>> as an example of a quasi-lingual DSL(((Quasi-Lingual DSLs))), and blends well with quasi-lingual testing frameworks such as Kotest.

=== better-parse

(((better-parse)))
Better-parse is the parser-combinator library we used in <<#parser_library,Chapter 9.2.2>>. It features a succinct hybrid DSL, which gives you a lot of flexibility. Here is one of the example parsers of the project:

[source,kotlin]
.https://github.com/h0tk3y/better-parse/blob/master/demo/demo-jvm/src/main/kotlin/com/example/BooleanExpression.kt
----
sealed class BooleanExpression

object TRUE : BooleanExpression()

object FALSE : BooleanExpression()

data class Variable(
    val name: String
) : BooleanExpression()

data class Not(
    val body: BooleanExpression
) : BooleanExpression()

data class And(
    val left: BooleanExpression,
    val right: BooleanExpression
) : BooleanExpression()

data class Or(
    val left: BooleanExpression,
    val right: BooleanExpression
) : BooleanExpression()

data class Impl(
    val left: BooleanExpression,
    val right: BooleanExpression
) : BooleanExpression()

object BooleanGrammar : Grammar<BooleanExpression>() {
    val tru by literalToken("true")
    val fal by literalToken("false")
    val id by regexToken("\\w+")
    val lpar by literalToken("(")
    val rpar by literalToken(")")
    val not by literalToken("!")
    val and by literalToken("&")
    val or by literalToken("|")
    val impl by literalToken("->")
    val ws by regexToken("\\s+", ignore = true)

    val negation by -not * parser(this::term) map { Not(it) }
    val bracedExpression by -lpar * parser(this::implChain) * -rpar

    val term: Parser<BooleanExpression> by
        (tru asJust TRUE) or
        (fal asJust FALSE) or
        (id map { Variable(it.text) }) or
        negation or
        bracedExpression

    val andChain by leftAssociative(term, and) {
        a, _, b -> And(a, b)
    }
    val orChain by leftAssociative(andChain, or) {
        a, _, b -> Or(a, b)
    }
    val implChain by rightAssociative(orChain, impl) {
        a, _, b -> Impl(a, b)
    }

    override val rootParser by implChain
}

fun main(args: Array<String>) {
    val expr = "a & (b1 -> c1) | a1 & !b | !(a1 -> a2) -> a"
    println(BooleanGrammar.parseToEnd(expr))
}
----

The grammar is defined within an object as a sequence of token definitions and parsers that build upon each other. An interesting aspect of this DSL is that it relies heavily on property delegation. This allows the tokens and parsers to be stored in lists behind the scenes, making it much easier for the library to work with them.

An interesting problem is how to handle recursive parser definitions. In the example in Chapter 9.2.2, a "molecular part" could be either an "element" or a "group", but a group itself consists of parts. The library solves this in an elegant way by allowing to refer to parsers via their property reference:

[source,kotlin]
----
val equationGrammar = object : Grammar<Equation>() {
    ...
    val element: Parser<Element> by (symbol and optional(number))
        .map { (s, n) -> Element(s.text, n ?: 1) }

    val group: Parser<Group> by (skip(leftPar) and
            oneOrMore(parser(this::part)) and
            skip(rightPar) and
            optional(number))
        .map { (parts, n) -> Group(parts, n ?: 1) }

    val part: Parser<Part> = element or group
    ...
}
----

Calling `parser(this::part)` allows you to "break the cycle". I suspect that this is one reason - besides performance considerations - why the DSL uses an object as its context, rather than the more common trailing lambda syntax. While there are certainly ways to make a recursive definition work in Loan Pattern DSLs, this is clearly a more straightforward solution. This is a good example of why creativity and out-of-the-box thinking are so important when writing DSLs.

=== Konform-kt

(((Konform-kt)))
https://github.com/konform-kt/konform[Konform-kt]footnote:[Konform-kt: https://github.com/konform-kt/konform] is a library for data validation. The resulting validation object contains a list of issues of the given data structure, allowing each problem to be precisely located.

The DSL relies heavily on the Loan Pattern, allows different types of nesting to "drill down" into the data structure, and provides many predefined constraints. Here is an example from the documentation:

[source,kotlin]
.from https://github.com/konform-kt/konform
----
data class Person(val name: String, val email: String?, val age: Int)

data class Event(
    val organizer: Person,
    val attendees: List<Person>,
    val ticketPrices: Map<String, Double?>
)

val validateEvent = Validation<Event> {
    Event::organizer {
        // even though the email is nullable
        // you can force it to be set in the validation
        Person::email required {
            pattern(".+@bigcorp.com") hint
                "Organizers must have a BigCorp email address"
        }
    }

    // validation on the attendees list
    Event::attendees {
        maxItems(100)
    }

    // validation on individual attendees
    Event::attendees onEach {
        Person::name {
            minLength(2)
        }
        Person::age {
            minimum(18) hint "Attendees must be 18 years or older"
        }
        // Email is optional but if it is set it must be valid
        Person::email ifPresent {
            pattern(".+@.+\..+") hint
                "Please provide a valid email address (optional)"
        }
    }

    // validation on the ticketPrices Map as a whole
    Event::ticketPrices {
        minItems(1) hint "Provide at least one ticket price"
    }

    // validations for the individual entries
    Event::ticketPrices onEach {
        // Tickets may be free in which case they are null
        Entry<String, Double?>::value ifPresent {
            minimum(0.01)
        }
    }
}
----

Even without knowing the library, you can probably tell what conditions will be checked and what output you can expect. The DSL has a very consistent structure and descriptive naming conventions. If a condition is not met, you can provide your own using the `hint` infix function, but you don't have to, as there are already sensible default messages available. Even though Konform-kt doesn't use any features we haven't already covered, there is a lot to learn from how the DSL presents itself to the user and what makes it pleasant to use.

=== Arrow

(((Arrow)))
https://arrow-kt.io[Arrow]footnote:[Arrow: https://arrow-kt.io]  is a huge collection of features that promote functional programming in Kotlin, such as working with coroutines, error handling, immutable types, and much more. There is far too much content to cover here, but to give you a very basic example, here is how the library improves working with nullable types. Very often you see Kotlin code like this, which is hard to read due to various null checks:

[source,kotlin]
.https://arrow-kt.io/learn/typed-errors/nullable-and-option/
----
fun sendEmail(params: QueryParameters): SendResult? =
  params.userId()?.let { userId ->
    findUserById(userId)?.email?.let { email ->
      sendEmail(email)
    }
  }
----

Arrow provides the `nullable` DSL, which avoids nesting, and simplifies null checking:

[source,kotlin]
.https://arrow-kt.io/learn/typed-errors/nullable-and-option/
----
fun sendEmail(params: QueryParameters): SendResult? = nullable {
  val userId = ensureNotNull(params.userId())
  val user = findUserById(userId).bind()
  val email = user.email.bind()
  sendEmail(email)
}
----

I think you will agree that this code is much easier to read. The idea of "flattening" monadic computations comes from Haskell (as "do notation") and can also be found in Scala (as "comprehensions"). It is great that Arrow brings a similar feature to Kotlin - not only for nullable types, but also for `Either`, `Result` and `Option`.

However, there is much more to explore in Arrow, both for your daily coding and as inspiration for writing idiomatic DSLs.

=== Conclusion

Exploring well-written DSLs can be a great source of inspiration. Frankly, a significant number of Kotlin DSLs currently available "get the job done" but lack an engaging and enjoyable user experience. Such DSLs often rely heavily on a limited set of language features and miss the opportunity for a more exploratory approach, resulting in a dull and uninspired feel. The examples presented in this chapter should inspire you to strive for more, for DSLs that are creative, intuitive, and fun to use.

