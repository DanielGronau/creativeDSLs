== Modeling State Transitions in DSLs

DSLs often need to model complex state transitions that occur during the execution of the program, or for constructing objects in stages. In this chapter, we will explore three different techniques for modeling such use cases, how to choose the right technique, and how to use these techniques in conjunction with other patterns such as the Builder and Loan pattern.

In order to allow a good comparison between the implementations, we will write a DSL for building SQL queries using the different approaches. As the SQL language is very complex, we have to limit our example to queries using just `SELECT`, `FROM`, `WHERE` and `GROUP BY` clauses, and use simple `String` arguments (for a serious SQL-DSL implementation check out https://www.jooq.org/[jOOQ]). The following state diagram gives an overview of the allowed transitions:

[ditaa,"sql-queries"]
.Simplified Select SQL Query
....
/--------\  /-------\
| Start  |  | JOIN  |
\---+----/  \---+---/
    |         ^ | /--------------------\
    |         | | |                    |
    v         | v |                    v
/--------\  /-+---+-\  /-------\  /----------\
| SELECT +->| FROM  +->| WHERE +->| GROUP BY |
\--------/  \---+---/  \---+---/  \----+-----/
                |          |           |
                v          v           v
            /--------------------------------\
            |             Finish             |
            \--------------------------------/
....

The final DSL will allow to write basic SQL queries like this:

[source,kotlin]
----
val queryAll = select("p.firstName", "p.lastName", "p.income")
    .from("Person", "p")

val queryJoin = select("p.firstName", "p.lastName", "p.income")
    .from("Person", "p")
    .join("Address", "a").on("p.addressId","a.id")
    .where("p.age > 20")
    .and("p.age <= 40")
    .and("a.city = 'London'")

val queryGroupBy = select("min(p.income)", "max(p.income)", "avg(p.income)")
    .from("Person", "p")
    .where("p.age > 20")
    .groupBy("p.income")
----

While this example code is using a builder pattern syntax, we will also discuss how a loan pattern implementation of the same functionality could look like.

=== The 'Separate Classes' Approach

The first approach is straight-forward: Every state is represented by a separate class, which is independent of all other classes. While this is conceptually very simple, the main drawback is that all the collected data have to be transferred between the classes representing the states. Often it is more convenient and readable to pass a dedicated data holder object around, instead of using several parameters.

In order to implement the SQL query DSL, first we need two helper classes and the data holder class:

[source,kotlin]
----
data class NameWithAlias(
    val name: String,
    val alias: String? = null
) {

    override fun toString(): String = when (alias) {
        null -> name
        else -> "$name AS $alias"
    }
}

data class TableJoin(
    val nameWithAlias: NameWithAlias,
    val column1: String,
    val column2: String
)

data class QueryData(
    val columns: List<String>,
    val tableName: NameWithAlias,
    val joinClauses: List<TableJoin> = emptyList(),
    val whereConditions: List<String> = emptyList(),
    val groupByColumns: List<String> = emptyList()
)
----

Then we can write the SELECT part, which is straightforward:

[source,kotlin]
----
fun select(vararg columns: String) = SelectClause(*columns)

class SelectClause(vararg val columns: String) {

    fun from(tableName: String, alias: String? = null) =
        FromClause(
            QueryData(
                columns = columns.asList(),
                tableName = NameWithAlias(tableName, alias)
            )
        )
}
----

There is no `build()` method, the only way forward is going into the `FromClause`, which is a bit more involved, as there might be multiple tables joined together:

[source,kotlin]
----
data class FromClause(val queryData: QueryData) {

    fun join(tableName: String, alias: String? = null) =
        JoinClause(queryData, NameWithAlias(tableName, alias))

    fun where(condition: String) =
        WhereClause(queryData.copy(
            whereConditions = listOf(condition)
        ))

    fun groupBy(vararg groupByColumns: String) =
        GroupByClause(queryData.copy(
            groupByColumns = groupByColumns.toList()
        ))

    fun build() = build(queryData)
}
----

From here, you can go to a `JoinClause`, which mimics the SQL syntax by permitting to write something like `fromClause.join("Address","a").on("p.addressId", "a.id")`. The other exit points lead to a `WhereClause` or a `GroupByClause`. Additionally, the `FromClause` has a `build()` method, because the `WHERE` and `GROUP BY` parts are optional. The `JoinClause` offers just an `on()` method, which leads back to the `FromClause`.:

[source,kotlin]
----
data class JoinClause(
    val queryData: QueryData,
    val tableName: NameWithAlias
) {

    fun on(firstColumn: String, secondColumn: String) =
        FromClause(queryData.copy(
            joinClauses = queryData.joinClauses +
                TableJoin(tableName, firstColumn, secondColumn)
        ))
}
----

The `WhereClause` is quite simple, but of course using `String` to represent the different conditions is not very safe and should be avoided in production code. Our SQL subset allows to progress to the `GroupByClause` (while the full syntax would also permit `HAVING`, `ORDER BY` etc). Alternatively, we can finish the query by calling the `build()` method:

[source,kotlin]
----
data class WhereClause(val queryData: QueryData) {

    fun and(condition: String) =
        copy(queryData = queryData.copy(
            whereConditions = queryData.whereConditions +
                condition
        ))

    fun groupBy(vararg groupByColumns: String) =
        GroupByClause(queryData.copy(
            groupByColumns = groupByColumns.toList()
        ))

    fun build() = build(queryData)
}
----

The `GroupByClause` allows just a call to the `build()` method:

[source,kotlin]
----
data class GroupByClause(val queryData: QueryData) {
    fun build() = build(queryData)
}
----

The only missing part is the common `build(queryData)` method used by `FromClause`, `WhereClause` and `GroupByClause`:

[source,kotlin]
----
private fun build(queryData: QueryData): String {
    val (columns, tableName, joinClauses, whereConditions, groupByColumns) = queryData
    val sb = StringBuilder()
        .append("SELECT ${columns.joinToString(", ")}")
        .append("\nFROM ")
        .append(tableName)
    joinClauses.forEach { (n, c1, c2) ->
        sb.append("\n  JOIN $n ON $c1 = $c2")
    }
    if (whereConditions.isNotEmpty()) {
        sb.append("\nWHERE ${whereConditions.joinToString("\n  AND ")}")
    }
    if (groupByColumns.isNotEmpty()) {
        sb.append("\nGROUP BY ${groupByColumns.joinToString(", ")}")
    }
    sb.append(';')
    return sb.toString()
}
----

Bundling all data in a data holder instance as shown here can reduce the overhead of moving all the data around substantially, especially by leveraging the power of the `copy()` method. In the next section, we will explore an alternative implementation of the same DSL.

=== The Chameleon Class Approach

While having a separate data holder class makes the separate class approach more convenient, it would be nicer if we wouldn't need to copy data around in the first place. But what is with all the guarantees a chained builder provides, e.g. that you can't call `build()` or `join()` in a `SELECT`  clause? One way to achieve this is to use a "chameleon class". The basic idea is to adapt the type of this class to the state it resent currently, and change it accordingly when the state changes. First need to translate our former state classes into interfaces:

[source,kotlin]
----
interface SelectClause {
    fun from(table: String, alias: String? = null): FromClause
}

interface FromClause{
    fun join(tableName: String, alias: String? = null): JoinClause
    fun where(condition: String): WhereClause
    fun groupBy(vararg groupByColumns: String): GroupByClause
    fun build(): String
}

interface JoinClause {
    fun on(firstColumn: String, secondColumn: String): FromClause
}

interface WhereClause {
    fun and(condition: String): WhereClause
    fun groupBy(vararg groupByColumns: String): GroupByClause
    fun build(): String
}

interface GroupByClause {
    fun build(): String
}
----

Now all left to do is to implement these interfaces in one chameleon class, and to keep track of the data. It is important to make the constructor private, as the initial type shouldn't be the type of the class itself, but `SelectClause`.  That's why the `select()` method in the companion object is used as starting point for the DSL:

[source,kotlin]
----
class QueryBuilder private constructor(val columns: List<String>):
    SelectClause, FromClause, JoinClause, WhereClause, GroupByClause {
    var tableName = NameWithAlias("", null)
    var joinTableName = NameWithAlias("", null)
    val joinClauses = mutableListOf<TableJoin>()
    val whereConditions = mutableListOf<String>()
    val groupByColumns = mutableListOf<String>()

    companion object {
        fun select(vararg columns: String): SelectClause = QueryBuilder(columns.asList())
    }

    // SelectClause
    override fun from(table: String, alias: String?): FromClause =
        this.apply { tableName = NameWithAlias(table, alias) }

    // FromClause
    override fun join(tableName: String, alias: String?): JoinClause =
        this.apply { joinTableName = NameWithAlias(tableName, alias) }

    override fun where(condition: String): WhereClause =
        this.apply { whereConditions += condition }

    // JoinClause
    override fun on(firstColumn: String, secondColumn: String): FromClause =
        this.apply { joinClauses += TableJoin(joinTableName, firstColumn, secondColumn) }

    // WhereClause
    override fun and(condition: String): WhereClause =
        this.apply { whereConditions += condition }

    // FromClause and WhereClause
    override fun groupBy(vararg groupByColumns: String): GroupByClause =
        this.apply { this.groupByColumns += groupByColumns.toList() }

    // FromClause, WhereClause and GroupByClause
    override fun build(): String {
        val sb = StringBuilder()
            .append("SELECT ${columns.joinToString(", ") { it }}")
            .append("\nFROM ")
            .append(tableName)
        joinClauses.forEach { (n, c1, c2) ->
            sb.append("\n  JOIN $n ON $c1 = $c2")
        }
        if (whereConditions.isNotEmpty()) {
            sb.append("\nWHERE ${whereConditions.joinToString("\n  AND ")}")
        }
        if (groupByColumns.isNotEmpty()) {
            sb.append("\nGROUP BY ${groupByColumns.joinToString(", ")}")
        }
        sb.append(';')
        return sb.toString()
    }
}
----

For the compiler, it doesn't matter that you give back the same object over and over again at runtime, because the static type decides which methods can be called, and this static type is never `QueryBuilder`, but instead one of the interfaces for the SQL clauses. Calling the DSL looks like before, and you still can't call methods out of order.

The chameleon class concept might look somewhat strange at first, but results usually in compact and  readable code. However, be aware that this approach is susceptible to name clashes, which occur e.g. when the same method signature is used with different return types by multiple interfaces.

=== The Phantom Type Approach

There is an alternative implementation to the chameleon class, which uses <<chapter-04.adoc#typeLevelProgramming,phantom types>>(((Phantom Types))). From a usage perspective, the main difference is that the phantom type approach uses a data holder class and extension functions. The data holder class has a generic parameter (the phantom type), which is used by the extension functions to distinguish the current state:

[source,kotlin]
----
interface CanGroupBy
interface CanBuild

sealed interface State
interface SelectClause : State
interface FromClause : State, CanGroupBy, CanBuild
interface JoinClause : State
interface WhereClause : State, CanGroupBy, CanBuild
interface GroupByClause : State, CanBuild

data class QueryData<out State>(
    val columns: List<String>,
    val tableName: NameWithAlias = NameWithAlias(""),
    val joinTableName: NameWithAlias = NameWithAlias(""),
    val joinClauses: List<TableJoin> = emptyList(),
    val whereConditions: List<String> = emptyList(),
    val groupByColumns: List<String> = emptyList()
)

@Suppress("UNCHECKED_CAST")
private fun <S : State> QueryData<*>.cast(): QueryData<S> = this as QueryData<S>
----

The states are represented by interfaces. We need two additional interfaces `CanGroupBy` and `CanBuild` for the functions that can be called from multiple states. Except for the generic parameter, the data holder class looks as usual. As the generic parameter doesn't refer to any real data, the cast itself is safe. The `cast()` extension function allows us to switch easily between states. Of course, this function must be private in order to avoid abuse. The extension functions for the state transitions are straight-forward:

[source,kotlin]
----
fun QueryData<SelectClause>.from(table: String, alias: String?): QueryData<FromClause> =
    copy(tableName = NameWithAlias(table, alias)).cast()

fun QueryData<FromClause>.join(tableName: String, alias: String?): QueryData<JoinClause> =
    copy(joinTableName = NameWithAlias(tableName, alias)).cast()

fun QueryData<FromClause>.where(condition: String): QueryData<WhereClause> =
    copy(whereConditions = whereConditions + condition).cast()

fun QueryData<JoinClause>.on(firstColumn: String, secondColumn: String): QueryData<FromClause> =
    copy(joinClauses = joinClauses + TableJoin(joinTableName, firstColumn, secondColumn)).cast()

fun QueryData<WhereClause>.and(condition: String): QueryData<WhereClause> =
    copy(whereConditions = whereConditions + condition)

fun QueryData<CanGroupBy>.groupBy(vararg groupByColumns: String): QueryData<GroupByClause> =
    copy(groupByColumns = groupByColumns.toList()).cast()

fun QueryData<CanBuild>.build(): String {
    val sb = StringBuilder()
        .append("SELECT ${columns.joinToString(", ")}")
        .append("\nFROM ")
        .append(tableName)
    joinClauses.forEach { (n, c1, c2) ->
        sb.append("\n  JOIN $n ON $c1 = $c2")
    }
    if (whereConditions.isNotEmpty()) {
        sb.append("\nWHERE ${whereConditions.joinToString("\n  AND ")}")
    }
    if (groupByColumns.isNotEmpty()) {
        sb.append("\nGROUP BY ${groupByColumns.joinToString(", ")}")
    }
    sb.append(';')
    return sb.toString()
}
----

Note that `groupBy()` can be called e.g. on `QueryData<FromClause>`, even though it is defined as `fun QueryData<CanGroupBy>.groupBy(...)`. This is possible because the phantom type in `QueryData` was defined as contravariant using the `out` keyword. Without this, we would have needed a signature like `fun <S: CanGroupBy> QueryBuilder<S>.groupBy(...)` in order to be callable from a data holder with a sub-interface.

Chameleon classes and the phantom type implementation are conceptually similar, and it is a matter of taste whether you prefer a large class with methods, or a data holder with extension methods. When the DSL needs to be called from Java, it should be considered that only the chameleon approach preserves the DSL syntax in this case.

=== Conclusion

The Loan Pattern DSL has several advantages over the classic Builder Pattern style, and is very common in Kotlin. It really shines when dealing with nested structures, and allows to integrate other DSL techniques more easily.

==== Preferable Use Cases

* Creating data
* Execute actions
* Configuring systems
* Testing

==== Rating

* image:5_sun.png[] - for Simplicity of DSL design
* image:3_sun.png[] - for Elegance
* image:3_sun.png[] - for Usability
* image:2_sun.png[] - for Application Scope

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* easy to write and read

|* succession rules can't be enforced
* might be difficult to use from Java client code
|===