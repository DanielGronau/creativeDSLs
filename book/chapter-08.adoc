== Hybrid DSLs

In many cases, it is hard to categorize a DSL because it uses a mix of different techniques: Some parts could resemble a builder, others look like an algebraic DSL, and in one place annotations are used. That's what I call a "hybrid DSL".

When most of a DSL can be written in a certain style, it is usually a good idea to stick with it in order to ensure a coherent look and feel. So I wouldn't advocate to mix builder and loan pattern styles together, but to decide on one. But if this is not possible, there is nothing wrong with designing a DSL which combines different approaches, when it gets the job done.

=== Quasi-lingual DSLs

A common reason for mixing features from different DSL categories is to imitate - to a degree - natural language. I call this important subgroup of Hybrid DSLs "quasi-lingual". Even though the syntax is usually rigid and contains artifacts like braces, parenthesis or commas, it is still "readable" in a very literal sense. This snippet from the mocking library https://mockk.io/#dsl-examples[MockK] should give you a good impression:

[source,kotlin]
----
every { car.door(DoorType.FRONT_LEFT).windowState() } returns WindowState.UP
----

Technically, writing a quasi-lingual DSL is not very different from other Hybrid DSLs, although it might be harder to model grammatical structures correctly. Also, name clashes with keywords like `is`, `as` etc. are more of a problem. As good advice is to keep the DSL grammar simple and well-structured, and to compromise when it helps to reduce complexity. E.g. instead of insisting on writing something like `should` `be` separated, it is okay to write `shouldBe` when it helps to keep the grammar simple.

=== Case Study: Chemical Equations

Writing a DSL for chemical equations is no easy task, because the notation is very concise and can't be imitated easily using Kotlin syntax. For our case study, we won't cover the full notation, e.g. we won't support writing ions, just ordinary molecules.

A simple chemical equation looks like this: `3Ba(OH)2 + 2H3PO4 -{zwsp}> 6H2O + Ba3(PO4)2`. To express such an equation, we use the following code:

[source,kotlin]
----
data class Element(val symbol: String, val count: Int) : Part {
    constructor(symbol: String) : this(symbol, 1)
    override fun toString() = when (count) {
        1 -> symbol
        else -> symbol + count
    }
}

data class Group(val parts: List<Part>, val count: Int) : Part {
    constructor(vararg parts: Part) : this(parts.asList(), 1)
    override fun toString() = when (count) {
        1 -> parts.joinToString("", "(", ")")
        else -> parts.joinToString("", "(", ")") + count
    }
}

data class Molecule(val factor: Int, val parts: List<Part>) {
    constructor(vararg parts: Part) : this(1, parts.asList())
    constructor(factor: Int, vararg parts: Part) : this(factor, parts.asList())
    override fun toString() = when (factor) {
        1 -> parts.joinToString("")
        else -> "$factor${parts.joinToString("")}"
    }
}

data class Equation(val leftSide: List<Molecule>, val rightSide: List<Molecule>, val reversible: Boolean = false) {
    override fun toString() = leftSide.joinToString(" + ") +
            (if (reversible) " <-> " else " -> ") +
            rightSide.joinToString(" + ")
}
----

An `Element` contains just the chemical symbol, like `"H"` (hydrogen) or `"Ba"` (barium), and optionally a count index. A feature of the chemical notation is that you can also define groups like `"(OH)2"` in a molecule, which is why we need the `Group` class as well.

A `Molecule` is a collection of elements or groups, and can also have a factor in front. An equation consists of two sides and either an arrow `-{zwsp}>` or in case of reversible reactions a double arrow `<{zwsp}-{zwsp}>` in the middle, while every side is either a single molecule or a sum of molecules.

The code contains secondary constructors for more convenient initialization (note that data classes don't allow varargs in their primary constructor), and overwrites the `toString()` methods in order to give the output in chemical notation. The equation mentioned above for making barium phosphate could be written like this:

[source,kotlin]
----
val Ba = Element("Ba")
val Ba3 = Element("Ba", 3)
val O = Element("O")
val O2 = Element("O", 2)
val O4 = Element("O", 4)
val H2 = Element("H", 2)
val H3 = Element("H", 3)
val P = Element("P")

val bariumHydroxide = Molecule(3, Ba, Group(2, O, H))
val phosphoricAcid = Molecule(2, H3, P, O4)
val water = Molecule(6, H2, O)
val bariumPhosphate = Molecule(Ba3, Group(2, P, O4))

val equation = Equation(
    listOf(bariumHydroxide, phosphoricAcid),
    listOf(water, bariumPhosphate),
    false)

println(equation)
//3Ba(HO)2 + 2H3PO4 -> 6H2O + Ba3(PO4)2
----

This code works, but a little improvement wouldn't be the worst idea. Let's write a Hybrid DSL for it. First, we predefine all elements:

[source,kotlin]
----
val H = Element("H")
val He = Element("He")
val Li = Element("Li")
// etc.
----

Next, we need a convenient way to add the multiplier to an element or a group. For this, we could use the invoke-operator `()` or the index access operator `[]`. As we will need parentheses in other places as well, the index access operator seems to be the better choice. We can now write `H[2]` to denote `H2`:

[source,kotlin]
----
operator fun Element.get(count: Int) =
    apply { require(this.count == 1 && count > 1) }
        .copy(count = count)
operator fun Group.get(count: Int) =
    apply { require(this.count == 1 && count > 1) }
        .copy(count = count)
----

The code for both functions contains a sanity check, which won't allow nonsensical calls like `H[-5]` or `H[2][7]`.

The next task is to assemble molecules from elemental or group parts. We can use the minus operator `-` to represent a chemical bond, e.g. a water molecule could be written as `(H[2]-O)`. We also need to assemble groups, and from the few remaining operators the range operator `..` seems like a good fit, so we can write e.g. a carboxyl group as `(C..O..O..H)`:

[source,kotlin]
----
operator fun Part.minus(that: Part) = Molecule(this, that)
operator fun Molecule.minus(that: Part) = copy(parts = parts + that)
operator fun Element.rangeTo(that: Part) = Group(this, that)
operator fun Group.rangeTo(that: Part) = copy(parts = parts + that)
----

Generally, we need to put molecules and groups in parentheses because of the precedence rules.

A molecule can have an optional factor in front. Also, the same operation should "promote" an element or group to a molecule, allowing e.g. to write `2*O[2]` resulting in an oxygen molecule with a factor of two. Again, we need sanity checks, rendering calls like `-2*H[2]` or `3*(2*O[2])` invalid:

[source,kotlin]
----
operator fun Int.times(that: Molecule) =
    that.apply { require(factor == 1 && this@times > 1) }
        .copy(factor = this)
operator fun Int.times(that: Part) =
    Molecule(this, that)
        .apply { require(factor > 1) }
----

Next, we need a way to group the left and right side of an equation to a list of molecules, and the obvious choice for an operator is `+`. Again, we "promote" molecule parts to full molecules when necessary. This time the precedence rules for `*` and `+` play nicely along with the intended use, so we won't need parentheses on this level.

[source,kotlin]
----
operator fun Molecule.plus(that: Molecule) = listOf(this, that)
operator fun Molecule.plus(that: Part) = listOf(this, Molecule(that))
operator fun Part.plus(that: Molecule) = listOf(Molecule(this), that)
operator fun List<Molecule>.plus(that: Part) = this + Molecule( that)
----

In case you wonder why there is no `List<Molecule>.plus(that: Molecule)` function: This would be just a special case of adding elements to a list, which is already defined in the standard library.

The last part is collecting everything in an equation. This is not complicated, but lengthy, because we might encounter not only lists of molecules, but single molecules or molecule parts on both sides of the equation. Further, we have to account for the two different equation types:

[source,kotlin]
----
infix fun List<Molecule>.reactsTo(that: List<Molecule>) = Equation(this, that, false)
infix fun Molecule.reactsTo(that: List<Molecule>) = Equation(listOf(this), that, false)
infix fun List<Molecule>.reactsTo(that: Molecule) = Equation(this, listOf(that), false)
infix fun Molecule.reactsTo(that: Molecule) = Equation(listOf(this), listOf(that), false)
infix fun Part.reactsTo(that: List<Molecule>) = Equation(listOf(Molecule(this)), that, false)
infix fun List<Molecule>.reactsTo(that: Part) = Equation(this, listOf(Molecule(that)), false)
infix fun Part.reactsTo(that: Part) = Equation(listOf(Molecule(this)), listOf(Molecule(that)), false)
infix fun Part.reactsTo(that: Molecule) = Equation(listOf(Molecule(this)), listOf(that), false)
infix fun Molecule.reactsTo(that: Part) = Equation(listOf(this), listOf(Molecule(that)), false)

infix fun List<Molecule>.reversibleTo(that: List<Molecule>) = Equation(this, that, false)
infix fun Molecule.reversibleTo(that: List<Molecule>) = Equation(listOf(this), that, false)
infix fun List<Molecule>.reversibleTo(that: Molecule) = Equation(this, listOf(that), false)
infix fun Molecule.reversibleTo(that: Molecule) = Equation(listOf(this), listOf(that), false)
infix fun Part.reversibleTo(that: List<Molecule>) = Equation(listOf(Molecule(1,this)), that, false)
infix fun List<Molecule>.reversibleTo(that: Part) = Equation(this, listOf(Molecule(1,that)), false)
infix fun Part.reversibleTo(that: Part) = Equation(listOf(Molecule(this)), listOf(Molecule(that)), false)
infix fun Part.reversibleTo(that: Molecule) = Equation(listOf(Molecule(this)), listOf(that), false)
infix fun Molecule.reversibleTo(that: Part) = Equation(listOf(this), listOf(Molecule(that)), false)
----

Unfortunately, we have to resort to infix functions, as there seems to be no suitable operator available. A common trick is to use the backtick syntax to mimic an operator, but `{backtick}-{zwsp}>{backtick}` and `{backtick}<{zwsp}-{zwsp}>{backtick}` won't work: `<` and `>` are two of the very few characters that are not allowed in backtick syntax on the JVM.

So, how does our DSL look like in action? Here are a few examples:

[source,kotlin]
----
//2H2 + O2 <-> 2H2O
val makingWater =
    2*H[2] + O[2] reversibleTo 2*(H[2]-O)

//3Ba(HO)2 + 2H3PO4 -> 6H2O + Ba3(PO4)2
val makingBariumPhosphate =
    3*(Ba-(O..H)[2]) + 2*(H[3]-P-O[4]) reactsTo
        6*(H[2]-O) + (Ba[3]-(P..O[4])[2])

//H2SO4 + 8HI <-> H2S + 4I2 + 4H2O
val sulfuricAcidAndHydrogenIodide =
    (H[2]-S-O[4]) + 8*(H-I) reversibleTo (H[2]-S) + 4*I[2] + 4*(H[2]-O)
----

There is one optional improvement, which is more a matter of taste: We could add some extension properties for low counts of elements and groups, which would allow to write e.g. `N._2` instead of `N[2]`:

[source,kotlin]
----
val Element._2
    get() = this.apply { require(count == 1) }.copy(count = 2)
val Element._3
    get() = this.apply { require(count == 1) }.copy(count = 3)
// etc.

val Group._2
    get() = this.apply { require(count == 1) }.copy(count = 2)
val Group._3
    get() = this.apply { require(count == 1) }.copy(count = 3)
// etc.

// new syntax
val eq = 3*(Ba-(O..H)._2) + 2*(H._3-P-O._4) reactsTo
            6*(H._2-O) + (Ba._3-(P..O._4)._2)
----

Please decide for yourself which version you prefer. Personally, I find the first syntax more readable.

Simulating the dense chemical notation is hard, and while using operator overloading and infix notation made our example substantially shorter, it still contains a lot of clutter. Of course, after some time one would get used to the DSL, but there is clearly a learning curve involved. In the next chapter, we will have another look at the problem, and attack it from a totally different angle.

=== Case Study: Pattern Matching

Kotlin's `when` is certainly more versatile than Java's `switch`, but languages like Scala or Haskell go one step further and allow pattern matching. This means that you can not only compare or test a value, you can also decompose it, test its parts individually or use the parts in the result expression. An ideal syntax could look like this:

[source,text]
----
//not (yet?) Kotlin
val p = Person("Andy", "Smith", 43)

val result = match(p) {
    Person("Andy", "Miller", _) ->
        "Andy Miller has called!"
    Person("Andy", lastName != "Miller", age) ->
        "Some other Andy of age $age has called"
    else -> "Some unknown caller"
}
----

We have to allow for some compromises to make it work in Kotlin:

* We can't use `Person` in the match cases, but `Person::class` would be okay
* The arrow is not possible, we will use `then` instead
* Comparisons as well as `and` and `or` can be only infix functions
* The right sides should be only evaluated if needed, so we need to have a type of `() -> T`, which also means we need braces
* Capturing variables on the left and using them on the right needs some function calls using a string key, also the result of capturing might be `null`, e.g. when a cast to the target type is not possible.
* `else` is a keyword, so we will use `otherwise` instead. Further, we can't know if conditions are exhaustive, so the `otherwise` branch is mandatory
* The whole construct has only limited type safety, as we can't know which member types a data class has.

That's a long list, let's see how our example looks now:

[source,kotlin]
----
val result = match(p) {
    Person::class("Andy", "Miller", any) then
        { "Andy Miller has called!" }
    Person::class("Andy", !eq("Miller"), capture("age")) then
        { "Some other Andy of age ${get<Int>("age")!!} has called" }
    otherwise { "Some unknown caller" }
}
----

That doesn't look too bad. The core of the DSL is quite small:

[source,kotlin]
----
fun interface Test : (Any?) -> Boolean

data class MatchResult<T>(val value: T)

class Matcher<T>(private val obj: Any?) {
    private val captures = mutableMapOf<String, Any?>()
    private var result: T? = null

    fun otherwise(default: () -> T) = MatchResult(result ?: default())

    infix fun Test.then(value: () -> T) {
        if (result == null && this(obj)) {
            result = value()
        }
    }

    fun capture(key: String) = Test {
        captures[key] = it
        true
    }

    @Suppress("UNCHECKED_CAST")
    fun <R> get(key: String) = captures[key] as? R
}

fun <T> match(obj: Any, body: Matcher<T>.() -> MatchResult<T>): T =
    Matcher<T>(obj).run(body).value
----

If you wonder what a `fun interface` is: It's an interface containing only one method, which allows to use a simplified syntax for implementing it. Using this syntax is officially called a https://kotlinlang.org/docs/fun-interfaces.html#sam-conversions[SAM Conversion].

Note that the body argument of the `match()` method requires a `MatchResult` as return value. This is a trick to force the user to call the `otherwise()` method at the end of the block. The capture mechanism is very simple, and a little unsafe because of the cast, but there is not much we can do about, and returning an `Any?` would be very inconvenient for the user.

=== Conclusion

Writing good hybrid DSLs is challenging. In most cases it is the better choice to stick with a certain style, when it is possible. On the other hand, a well-designed hybrid DSL can combine the most fitting techniques in a way that feels intuitive and organic.

==== Preferable Use Cases

* Creating data
* Transforming data
* Define operations
* Execute actions
* Generating code
* Testing
* Logging

==== Rating

* image:3_sun.png[] - for Simplicity of DSL design
* image:4_sun.png[] - for Elegance
* image:4_sun.png[] - for Usability
* image:5_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* can support a wide range of problems
* allows to get creative with different techniques
* can get very concise by having many implementation options

|* might look incoherent
* high perceptual complexity -> steeper learning curve
* difficult to control and predict the outcome
* higher maintenance effort needed
|===
