== Hybrid DSLs

In many cases, it is hard to categorize a DSL because it uses a mix of different techniques: Some parts could resemble a builder, others look like an algebraic DSL, and in one place annotations are used. That's what I call a "hybrid DSL".

When most of a DSL can be written in a certain style, it is usually a good idea to stick with it in order to ensure a coherent look and feel. So I wouldn't advocate to mix builder and loan pattern styles together, but to decide on one. But if this is not possible, there is nothing wrong with designing a DSL which combines different approaches, when it gets the job done.

=== Case Study: Pattern Matching

=== Case Study: Chemical Equations

Writing a DSL for chemical equations is no easy task, because the notation is very concise and can't be imitated easily using Kotlin syntax. For our case study, we won't cover the full notation, e.g. we won't support writing ions, just ordinary molecules.

A simple chemical equation looks like this: `3Ba(OH)2 + 2H3PO4 -{zwsp}> 6H2O + Ba3(PO4)2`. To express such an equation, we use the following code:

[source,kotlin]
----
interface Part

data class Element private constructor(val symbol: String, val count: Int) : Part {
    constructor(symbol: String) : this(symbol, 1)

    override fun toString() = when (count) {
        1 -> symbol
        else -> symbol + count
    }

    operator fun get(count: Int) =
        apply { require(this.count == 1 && count > 1) }
            .copy(count = count)
}

data class Group private constructor(val parts: List<Part>, val count: Int) : Part {
    constructor(vararg parts: Part) : this(parts.asList(), 1)

    override fun toString() = when (count) {
        1 -> parts.joinToString("", "(", ")")
        else -> parts.joinToString("", "(", ")") + count
    }

    operator fun get(count: Int) =
        apply { require(this.count == 1 && count > 1) }
            .copy(count = count)
}

data class Molecule(val factor: Int, val parts: List<Part>) {
    constructor(vararg parts: Part) : this(1, parts.asList())
    constructor(factor: Int, vararg parts: Part) : this(factor, parts.asList())

    override fun toString() = when (factor) {
        1 -> parts.joinToString("")
        else -> "$factor${parts.joinToString("")}"
    }
}

data class Equation(val leftSide: List<Molecule>, val rightSide: List<Molecule>, val reversible: Boolean = false) {
    override fun toString() = leftSide.joinToString(" + ") +
            (if (reversible) " <-> " else " -> ") +
            rightSide.joinToString(" + ")
}
----

An `Element` contains just the chemical symbol, like `"H"` (hydrogen) or `"Ba"` (barium). A feature of the chemical notation is that you can also define groups like `"(OH)2"` in a molecule, which is why we need the `Group` class as well. If you want to increase the count of an `Element` and `Group` , you can use the index access operator, e.g. `Element("H")[2]`. The index access functions contain a sanity check, which won't allow calls like `Element("H")[-5]` or `Element("H")[2][7]`

A `Molecule` is a collection of elements or groups, and can also have a factor in front. An equation consists of two sides and either an arrow `-{zwsp}>` or in case of reversible reactions a double arrow `<{zwsp}-{zwsp}>` in the middle, while every side is either a single molecule or a sum of molecules.

The code contains secondary constructors for more convenient initialization footnote:[Note that data classes don't allow varargs in their primary constructor.], and overwrites the `toString()` methods in order to give the output in chemical notation. The equation mentioned above for making barium phosphate could be written like this:

[source,kotlin]
----
val Ba = Element("Ba")
val O = Element("O")
val H = Element("H")
val P = Element("P")

val bariumHydroxide = Molecule(3, Ba, Group(O, H)[2])
val phosphoricAcid = Molecule(2, H[3], P, O[4])
val water = Molecule(6, H[2], O)
val bariumPhosphate = Molecule(Ba[3], Group(P, O[4])[2])

val equation = Equation(
    listOf(bariumHydroxide, phosphoricAcid),
    listOf(water, bariumPhosphate),
    false)

println(equation)
//3Ba(HO)2 + 2H3PO4 -> 6H2O + Ba3(PO4)2
----

This looks like it might need a little improvement. This is a suggestion how a DSL could look like:

[source,kotlin]
----
val H = Element("H")
val He = Element("He")
val Li = Element("Li")
// etc.

operator fun Part.not() = Molecule(this)
operator fun Part.minus(that: Part) = Molecule(this, that)
operator fun Molecule.minus(that: Part) = copy(parts = parts + that)
operator fun Element.rangeTo(that: Part) = Group(this, that)
operator fun Group.rangeTo(that: Part) = copy(parts = parts + that)

operator fun Int.times(that: Molecule) =
    that.apply { require(factor == 1 && this@times > 1) }
        .copy(factor = this)
operator fun Molecule.plus(that: Molecule) = listOf(this, that)

infix fun List<Molecule>.reactsTo(that: List<Molecule>) =
    Equation(this, that, false)
infix fun Molecule.reactsTo(that: List<Molecule>) =
    Equation(listOf(this), that, false)
infix fun List<Molecule>.reactsTo(that: Molecule) =
    Equation(this, listOf(that), false)

infix fun List<Molecule>.reactsReversible(that: List<Molecule>) =
    Equation(this, that, false)
infix fun Molecule.reactsReversible(that: List<Molecule>) =
    Equation(listOf(this), that, false)
infix fun List<Molecule>.reactsReversible(that: Molecule) =
    Equation(this, listOf(that), false)
----

First, we predefine all chemical elements. Then, we define the `!` operator to "promote" an element like `H[2]` or a group like `(CH[3])[2]` to a molecule. Next we use the minus operator `-` to represent a chemical bond, e.g. a water molecule could be written as `(H[2]-O)`. We still have a similar problem to assemble groups, and from the few remaining operators the range operator `..` seems like a good fit, so we can write e.g. a carboxyl group as `(C..O..O..H)`. Generally, you need to put molecules and groups in parentheses (except for molecules generated with `!`) because of the precedence rules.

The next function allows us to write factors in front of molecules. The sanity check in this function makes calls like `-2*!H[2]` or `3*(2*!O[2])` invalid. Then there is a `+` function for converting two molecules into a list. We don't need an extra function for adding a molecule to an existing list of molecules, as there is already an extension function for adding elements to lists in the standard library. Also, note that this time the precedence rules for `*` and `+` play nicely along with the intended use.

The next eight function simply assemble the equation. The high number of functions comes from the fact that we need to decide whether we need a single or double arrow, and because we can have either single molecules or lists of them on either side. As infix functions have lower precedence than any operators, we don't need parentheses on this level.

So, how does our DLS look like in action? Here are a few examples:

[source,kotlin]
----
//2H2 + O2 <-> 2H2O
val makingWater =
    2 * !H[2] + !O[2] reactsReversible 2 * (H[2]-O)

//3Ba(HO)2 + 2H3PO4 -> 6H2O + Ba3(PO4)2
val makingBariumPhosphate =
    3*(Ba-(O..H)[2]) + 2*(H[3]-P-O[4]) reactsTo 6*(H[2]-O) + (Ba[3]-(P..O[4])[2])

//H2SO4 + 8HI <-> H2S + 4I2 + 4H2O
val sulfuricAcidAndHydrogenIodide =
    (H[2]-S-O[4]) + 8*(H-I) reactsReversible (H[2]-S) + 4*!I[2] + 4*(H[2]-O)
----

Simulating the dense chemical notation is hard, and while using operator overloading and infix notation made our example substantially shorter, it still contains a lot of clutter. Of course, after some time one would get used to the DSL, but there is clearly a learning curve involved. To get to this DSL, we had to push the boundaries of the Kotlin syntax, and it shows. In the next chapter, we will have another look at the problem, and attack it from a totally different angle.

=== Conclusion

