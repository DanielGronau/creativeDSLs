== Real-World DSL Examples

In this chapter we will have a look of some widely used and successful DSLs, characterize them, look at interesting details, and maybe even suggest some improvements.

=== KotlinPoet

https://square.github.io/kotlinpoet/[KotlinPoet] is a source code generator for Kotlin, and the sister-project to JavaPoet.
We used it in chapter 11 to generate sources for operations with physical quantities.

The library follows closely the syntax of JavaPoet, which is written in Java, and I think this was the right decision.
The builder pattern works reasonably well for this purpose.
This is the introductory example on their home page:

[source,kotlin]
.https://square.github.io/kotlinpoet Hello World Example
----
class Greeter(val name: String) {
  fun greet() {
    println("""Hello, $name""")
  }
}

fun main(vararg args: String) {
  Greeter(args[0]).greet()
}
----

[source,kotlin]
.https://square.github.io/kotlinpoet Code Generation of the Example
----
val greeterClass = ClassName("", "Greeter")
val file = FileSpec.builder("", "HelloWorld")
  .addType(
    TypeSpec.classBuilder("Greeter")
      .primaryConstructor(
        FunSpec.constructorBuilder()
          .addParameter("name", String::class)
          .build()
      )
      .addProperty(
        PropertySpec.builder("name", String::class)
          .initializer("name")
          .build()
      )
      .addFunction(
        FunSpec.builder("greet")
          .addStatement("println(%P)", "Hello, \$name")
          .build()
      )
      .build()
  )
  .addFunction(
    FunSpec.builder("main")
      .addParameter("args", String::class, VARARG)
      .addStatement("%T(args[0]).greet()", greeterClass)
      .build()
  )
  .build()

file.writeTo(System.out)
----

If KotlinPoet were a stand-alone library, I would rather use a Loan Pattern DSL instead:

[source,kotlin]
----
val greeterClass = ClassName("", "Greeter")
val file = fileSpec("", "HelloWorld") {
    +classSpec("Greeter") {
        primaryConstructor = constructorSpec {
            +parameter("name", String::class)
        }
        +propertySpec("name", String::class) {
            initializer("name")
        }
        +functionSpec("greet") {
            +statement("println(%P)", "Hello, \$name")
        }
    }
    +functionSpec("main") {
        +parameter("args", String::class, VARARG)
        +statement("%T(args[0]).greet()", greeterClass)
    }
}
----



=== Gradle .kts

https://gradle.org/[Gradle] is an amazing build system. In contrast to descriptive approaches like the XML-based https://maven.apache.org[Apache Maven], the build process is "programmable", which gives the user a lot of flexibility.

However, the original Gradle implementation was written in Groovy - at the time probably the best choice to write an expressive DSL in the Java ecosystem. Alas, the Groovy language comes with its own set of problems. It is a scripted language with a weak type system, and as a result, IDE features like autocompletion, content assistance, source navigation, quick documentation and refactoring support are limited.

To overcome these problems, the Gradle team decided to provide an alternative DSL based on Kotlin Script (.kts). Obviously, the new DSL should look very similar to the old Groovy style, in order to make the transition as smooth as possible. I think, in this regard, the Kotlin DSL was a resounding success. Here is a comparison, taken from the https://docs.gradle.org/current/userguide/migrating_from_groovy_to_kotlin_dsl.html[Gradle Userguide: Migrating build logic from Groovy to Kotlin]:

[source,groovy]
.Groovy
----
plugins {
    id 'java-library'
}
dependencies {
    implementation 'com.example:lib:1.1'
    runtimeOnly 'com.example:runtime:1.0'
    testImplementation('com.example:test-support:1.3') {
        exclude(module: 'junit')
    }
    testRuntimeOnly 'com.example:test-junit-jupiter-runtime:1.3'
}
----

[source,kotlin]
.Kotlin Script
----
plugins {
    `java-library`
}
dependencies {
    implementation("com.example:lib:1.1")
    runtimeOnly("com.example:runtime:1.0")
    testImplementation("com.example:test-support:1.3") {
        exclude(module = "junit")
    }
    testRuntimeOnly("com.example:test-junit-jupiter-runtime:1.3")
}
----

At the first glance, it is hard to tell which is which. There are parts of the DSLs
which deviate more, but then it looks more like a deliberate decision, in order to clean up and standardize the syntax, than a limitation of the language.

The Kotlin Script DSL itself uses mainly the Loan Pattern. For the definition of dependencies, there are two notations: The example shows the "string notation", which is an example for a String-Parsing DSL. Alternatively, the "map notation" can be used, which looks like this: `implementation(group = "com.example", name = "lib", version = "1.1")`

In my opinion, Gradle is a good example how Kotlin DSLs can help to modernize an already established and successful solution, without causing major disruptions.

=== kotest

=== better-parse

