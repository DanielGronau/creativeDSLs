== Writing a DSL

So, you defined the requirements, and want finally dive into designing and implementing the DSL. I get your excitement, but I can tell from experience that it still makes a lot of sense to add a little structure to the process. The workflow outlined here is very simple, with just four steps, but it addresses some problems you might run into when you start coding right away.

[ditaa,"writing-a-dsl"]
.DSL-Writing Workflow
....

         /-----------------\
         |  Clarification  |
         v                 |
   /--------------\  /-----+-------\  /---------------\  /----------------\
   | Ideal Syntax +->| Prototyping +->| Formalization +->| Implementation |
   \--------------/  \-------------/  \---------------/  \-------+--------/
                           ^                                     |
                           |    Chosen Approach isn't viable     |
                           \-------------------------------------/

....

=== Dream up the Ideal Syntax

This might sound weird at first, especially if you come from Java, where the options for writing a DSL are usually quite limited. And after the requirement analysis, we should have already a pretty clear picture of how the syntax should look like, right? Yes, in some cases, the "ideal" syntax is pretty much set, e.g. if there is already an established standard for it. But often you have some creative freedom, and then this step becomes really useful.

The problem is that thinking about the DSL in terms of language features and implementation details limits your creativity. As a software developer, it is part of your job to "know" very quickly what is possible in a programming language, and what not. For experienced programmers, thinking something like "this won't work because of type erasure" is very common and highly internalized, it becomes part of the mentality. I hope you can see how this generally very useful skill can get in the way when designing DSLs by causing tunnel-vision.

So try to put your programming glasses away for a moment. If possible, invite domain experts. Get into brainstorming mood. The goal is to sketch out how an ideal DSL syntax could look like, regardless of how to implement it. If you can't agree on one syntax, it might be okay to have two candidates, but probably not more.

Usually it isn't necessary to specify a formal grammar. Instead, write lots of examples, comment these, and make sure that there are no inconsistencies or gaps. Don't forget to specify how the output for the respective example should look like: This is crucial information.

Again, if you have the chance, get feedback from domain experts or future users. Few things are more frustrating than presenting a new shiny implementation, only to be told you forgot about a crucial detail.

=== Prototyping

Now, finally the time for coding has come. As you have to experiment usually a lot to get the syntax right, and it's not always clear which solutions will work for the whole problem domain. That's why I would suggest to start coding a prototype: If you have multiple similar features, you implement only one of them (a.k.a. "Spike implementation"), and you can skip extensive testing or sanity checks. Sometimes you don't even need to generate the expected output, but write only an empty shell to verify that the chosen syntax is viable.

You should check regularly whether the syntax of the prototype is acceptable. Again, feedback from domain experts or potential users is invaluable. One advantage of the prototyping approach is that you can easily present different versions.

During prototyping, you might find out that you missed some details when specifying the ideal syntax. In such cases, you should fix the specification instead of just "muddling through". The ideal syntax description is thought as guidance for both the prototyping and implementation phase, and as a benchmark for the quality of the real syntax of the DSL, so it is too important to be left incomplete.

=== Formalization and Documentation

Once a prototype has shown how a realistic syntax could look like, you should formalize the syntax. This doesn't have to be a big process, it really depends on the scope of the project. Sometimes a simple wiki page might be enough, sometimes you have to define a formal grammar. Even more important as in case of the ideal syntax is the documentation of the mapping from the DSL to its output.

TIP: This step shouldn't be skipped: A prototype is no documentation, the final implementation needs exact specifications, and later users require a documentation as well. Doing it now makes the most sense.

One aspect deserving special attention is completeness. You should ensure that the DSL can actually express all "allowed" configurations. Sometimes, rare cases are simply overlooked, or some features are not orthogonal, even though they should. An example for missing orthogonality would be a syntax for describing animals, which doesn't allow to choose both "mammal" and "lays eggs", even though this combination actually exists.

=== Implementation

The last step is of course the implementation. Often parts of the prototype can be reused, but don't be afraid to throw it away, and to write better structured, more flexible or faster code instead. If you encounter a lot of boilerplate, you might consider using a source code generator. In contrast to the prototype, now it is time to shine and to follow all best practices, e.g. writing tests and sanity checks.

In some cases, you may discover that your prototype wasn't thorough enough, and hit a wall. When this happens, don't panic. If you can't find an immediate workaround, consider going back to the prototype phase. Staying in "full implementation mode" is heavy-weight, and limits you field of view. Taking a step back and exploring other approaches is often more productive than trying to power through.

The implementation of a DSL is quite often different from the usual programming tasks, therefore it comes with its own problems and pitfalls. Below, I'll list some points that deserve special attention.

==== Name Clashes

A good DSL can be used extensively in a code base, and of course that's a great thing. However, this also increases the likelihood of name clashes. That's why it might be  problematic to add extension methods to often used classes like `Int` or `String`. Sometimes two DSLs can clash, e.g. when trying to define the same operator. That's why you should try limit the scope of a function etc. by pulling it in one of the DSL classes, whenever it is possible.

==== Coupling

When writing a DSL for creating classes that are also under your control, you might be tempted to integrate the DSL tightly into these classes. This can backfire, for various reasons:

* DSL code gets entangled with business logic
* the DSL becomes part of the business API, making it bloated and inflexible
* In many cases it is important that the result classes can work on its own. This can be the case when code generation (((Code Generation))) or analysis tools are involved, when working with big data, or for testing
* at some point in time, the DSL may get obsolete

In Java, this kind of tight coupling might be excusable because there is often no other way to write a convenient DSL. But Kotlin is much more expressive, e.g. due to features like extension methods, so this excuse doesn't count.

==== Code Conventions

A point where you might need to compromise is following code conventions, e.g. regarding rules for using upper- and lowercase. Of course, you should stick to code conventions whenever possible, but in the context of DSL design some deviations are acceptable. But if you have to break the rules, you should at least document this decision.

==== Documentation

Many people don't like to write documentations, but it is important. A DSL is per definition an own language, and people might need a helping hand to use it correctly and effectively. Don't presume too much prior knowledge of the DSL, and don't be too lazy to show a few good examples, or to visualize core concepts. To be frank, if you find it very difficult to write a documentation for your own DSL, it might be an indication that the DSL itself has some improvement potential.

Often, you have to deviate a bit from the original specification, or you added some new details. Please don't forget to update the documentation.

One of the best things you can do is to write a little example project using the DSL. Listing all the DSL features is well and good, but demonstrating the intended workflow and showing the interplay of the DSL elements gives the user a much better understanding of how to apply the DSL to their problem domain.



