== Writing a DSL

Now that you have defined the requirements for your DSL and are ready to move on to the design and implementation phase, it's important to take a structured approach to the process. While it's natural to be excited to get started, adding a little structure to your workflow can help you avoid common pitfalls and ensure that your DSL is successful.

The following four-step workflow can be a helpful guide as you begin designing and implementing your DSL:

* Imagine the ideal syntax: Begin by considering the concepts and ideas that you want to express in your DSL, and brainstorm possible syntaxes that could be used to represent them. Consider readability, expressiveness, and usability as you explore different options.
* Prototyping: Once you have a rough idea of the syntax you want to use, create a prototype of your DSL using Kotlin's language features. This will allow you to experiment with different approaches and see how they work in practice.
* Formalization: Once you are satisfied with the prototype of your DSL, formalize the syntax and semantics of your DSL.
* Implementation: With the syntax and semantics of your DSL formally defined, you can begin implementing your DSL in Kotlin. Use the features and techniques you have learned to create a complete and functional DSL that is ready for use.

[ditaa,"writing-a-dsl"]
.DSL-Development Workflow
....

         /-----------------\                  /------------------\
         |  Clarification  |                  |    Refinement    |
         v                 |                  v                  |
   /--------------\  /-----+-------\  /---------------\  /-------+--------\
   | Ideal Syntax +->| Prototyping +->| Formalization +->| Implementation |
   \--------------/  \-------------/  \---------------/  \-------+--------/
                           ^                                     |
                           |    Chosen Approach isn't viable     |
                           \-------------------------------------/

....

By following this simple workflow, you can ensure that your DSL project is well-structured and successful.

=== Imagine the Ideal Syntax

It may seem strange at first to begin the process of designing and implementing a DSL by imagining an ideal syntax, especially if you are more familiar with languages like Java, which tend to have more limited options for building DSLs. However, this step can be extremely valuable, especially if you have some creative freedom in the design of your DSL. Even if the "ideal" syntax is largely predetermined by factors such as industry standards or existing conventions, it can be helpful to take some time to explore different options and consider how different syntaxes might affect the readability, expressiveness, and usability of your DSL.

As a software developer, it's natural to think in terms of language features and implementation details. Especially experienced programmers have a strong understanding of the capabilities and limitations of a programming language, and tend to think in terms of what is and isn't possible based on these factors. However, this kind of thinking can sometimes limit your creativity and lead to tunnel vision. When designing a DSL, it's important to keep in mind that the goal is not simply to create a working program, but a unique and consistent language.

Instead of focusing too narrowly on language features and implementation details, it can be helpful to take a step back and consider the broader goals and purpose of your DSL. Get into brainstorming mood, be open to exploring creative and unconventional approaches. The goal is to sketch out how an ideal DSL syntax could look like, regardless of how to implement it. If your team can't agree on one syntax, it might be okay to have two candidates, but probably not more.

In this step, it's generally not necessary to specify a formal grammar. Instead, it can be more effective to write lots of examples of how you envision the DSL being used, and to include comments and explanations to help clarify your intentions. Make sure to pay attention to any inconsistencies or gaps in the examples, and to specify how the output for each example should look. This is crucial information that will help ensure that your DSL is clear and intuitive to use.

If possible, it can also be helpful to seek feedback from domain experts or potential users of your DSL. This can help you identify any important details that you may have overlooked, and can help you create a DSL that meets the needs and expectations of your target audience. Few things are more frustrating than presenting a new implementation only to discover that you have forgotten a crucial detail, so it pays to be thorough and to seek feedback whenever possible.

=== Prototyping

Now that you have defined an ideal syntax, it's finally time to begin coding. Because it's often necessary to experiment and iterate to get the syntax and structure of your DSL just right, it can be very helpful to start with a prototype.

A prototype is a simplified version of your DSL that allows you to try out different approaches and see how they work in practice. You might choose to implement only selected features of your DSL (a.k.a. "spike implementations"), or to create an empty shell that simply verifies that your chosen syntax is viable. With a prototype, you can quickly test out different ideas and identify potential issues, you can save time and effort by avoiding extensive testing and sanity checks, and you can focus on experimenting with different approaches to see what works best. Prototyping can also help minimize the risk of spending time on solutions that ultimately prove to be unworkable.

As you work on prototyping your DSL, it's important to regularly check that the syntax you have chosen is acceptable and meets your goals and requirements. Feedback from domain experts or potential users of your DSL can be invaluable in this regard, as they can help you identify any issues or areas for improvement. One advantage of the prototyping approach is that it allows you to easily present different versions of your DSL and gather feedback on each one. This can help you refine your syntax and structure until you have a design that is both effective and intuitive.

If you find that you have missed some details when specifying the ideal syntax for your DSL, it's important to fix the specification rather than just "muddling through" with an incomplete or inadequate design. The ideal syntax description is intended to serve as guidance for both the prototyping and implementation phases, and as a benchmark for the quality of the final syntax of your DSL. As such, it's important to take the time to get it right.

=== Formalization and Documentation

Once a prototype has shown how a realistic syntax could look like, you should formalize the syntax. This doesn't have to be a big process, it really depends on the scope of the project. Sometimes a simple wiki page might be enough, sometimes you have to define a formal grammar. Even more important as in case of the ideal syntax is the documentation of the mapping from the DSL to its output.

TIP: This step shouldn't be skipped: A prototype is no documentation, the final implementation needs exact specifications, and later users require a documentation as well. Doing it now makes the most sense.

One aspect deserving special attention is completeness. You should ensure that the DSL can actually express all "allowed" configurations. Sometimes, rare cases are simply overlooked, or some features are not orthogonal, even though they should. An example for missing orthogonality would be a syntax for describing animals, which doesn't allow to choose both "mammal" and "lays eggs", even though this combination actually exists.

=== Implementation

The last step is of course the implementation. Often parts of the prototype can be reused, but don't be afraid to throw it away, and to write better structured, more flexible or faster code instead. If you encounter a lot of boilerplate, you might consider using a source code generator. In contrast to the prototype, now it is time to shine and to follow all best practices, e.g. writing tests and sanity checks.

In some cases, you may discover that your prototype wasn't thorough enough, and hit a wall. When this happens, don't panic. If you can't find an immediate workaround, consider going back to the prototype phase. Staying in "full implementation mode" is heavy-weight, and limits you field of view. Taking a step back and exploring other approaches is often more productive than trying to power through.

The implementation of a DSL is quite often different from the usual programming tasks, therefore it comes with its own problems and pitfalls. Below, I'll list some points that deserve special attention.

==== Name Clashes

A good DSL can be used extensively in a code base, and of course that's a great thing. However, this also increases the likelihood of name clashes. That's why it might be  problematic to add extension methods to often used classes like `Int` or `String`. Sometimes two DSLs can clash, e.g. when trying to define the same operator. That's why you should try limit the scope of a function etc. by pulling it in one of the DSL classes, whenever it is possible.

==== Coupling

When writing a DSL for creating classes that are also under your control, you might be tempted to integrate the DSL tightly into these classes. This can backfire, for various reasons:

* DSL code gets entangled with business logic
* the DSL becomes part of the business API, making it bloated and inflexible
* In many cases it is important that the result classes can work on its own. This can be the case when code generation (((Code Generation))) or analysis tools are involved, when working with big data, or for testing
* at some point in time, the DSL may get obsolete

In Java, this kind of tight coupling might be excusable because there is often no other way to write a convenient DSL. But Kotlin is much more expressive, e.g. due to features like extension methods, so this excuse doesn't count.

==== Code Conventions

A point where you might need to compromise is following code conventions, e.g. regarding rules for using upper- and lowercase. Of course, you should stick to code conventions whenever possible, but in the context of DSL design some deviations are acceptable. But if you have to break the rules, you should at least document this decision.

==== Documentation

Many people don't like to write documentations, but it is important. A DSL is per definition an own language, and people might need a helping hand to use it correctly and effectively. Don't presume too much prior knowledge of the DSL, and don't be too lazy to show a few good examples, or to visualize core concepts. To be frank, if you find it very difficult to write a documentation for your own DSL, it might be an indication that the DSL itself has some improvement potential.

Often, you have to deviate a bit from the original specification, or you added some new details. Please don't forget to update the documentation.

One of the best things you can do is to write a little example project using the DSL. Listing all the DSL features is well and good, but demonstrating the intended workflow and showing the interplay of the DSL elements gives the user a much better understanding of how to apply the DSL to their problem domain.



