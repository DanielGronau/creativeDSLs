== Writing a DSL

So, we defined the requirements, and want finally dive into designing and implementing the DSL. I totally get the excitement, but I can tell from experience that it still makes a lot of sense to give this process a little structure. The process outlined here is very simple, with just four steps, but it addresses some problems you might run into when you start coding right away.

=== Dream up the Ideal Syntax

This might sound weird, especially if you come from Java, where your options are usually limited. And after the requirement analysis, we should have already a pretty clear picture of how the syntax should look like, right? Yes, in some cases, the ideal syntax is pretty much given, e.g. if there is already an established standard for it. But in cases where you have some creative freedom, I would recommend to give this step a try.

Thinking about language features and implementation details limits your creativity. Try to put off your programming glasses. If possible, invite domain experts. Get some brainstorming vibes going. The goal is to sketch how an ideal DSL syntax could look like, without any regard about how to get there. If you can't agree on one syntax, it might be okay to have two candidates, but probably not more.

Usually it isn't necessary to specify a formal grammar. Instead, write lots of examples, comment those, and make sure that there are no inconsistencies or gaps. A crucial part of information is how the output for the respective example should look like.

If you have the chance, get feedback from domain experts or future users.

=== Prototyping

Now finally the time for coding has come. Usually you have to experiment a lot to get the syntax right, and it's not always clear which solutions will work for the whole problem domain. That's why I would suggest to start with a prototype: If you have multiple similar features, you implement only one of them (a.k.a. "Spike implementation"), and you can skip extensive testing or sanity checks. Sometimes you don't even need to generate the expected output, but write just an empty shell to show the syntax.

You should check regularly whether the syntax of the prototype is acceptable, and again feedback from experts or potential users is invaluable. One advantage of the prototyping approach is that you can easily present different versions.

=== Formalization and Documentation

Once a prototype has shown how a realistic syntax meeting the requirements could look like, you should formalize the syntax. This doesn't have to be a big process, it really depends on the scope of the project. Sometimes a simple wiki page might be enough, sometimes you have to define a formal grammar. Even more important as in case of the ideal syntax is the documentation of the mapping from the DSL to its output.

This step shouldn't be skipped: A prototype is no documentation, the real implementation needs exact specifications, and later users will need a documentation anyway.

One aspect deserving special attention is completeness. You should ensure that the DSL can actually express all "allowed" configurations. Sometimes rare cases are simply overlooked, or some features are not orthogonal. An example for the latter case would be a syntax for describing animals that doesn't allow to choose both "mammal" and "lays eggs" at the same time, even though this combination of properties actually exists.

=== Implementation

The last step is of course the implementation. Often parts of the prototype can be reused, but don't be afraid to throw it away, and to write better structured, more flexible or faster code instead. If you encounter a lot of boilerplate, you might consider using a source code generator. In contrast to the prototype, now is the time to shine and to follow all the best practices, e.g. writing tests and sanity checks.

In some cases, you discover that your prototype wasn't thorough enough, and hit a wall. When this happens, and you can't find an immediate workaround, consider going back to the prototype phase. Staying in "full implementation mode" is heavy-weight, and limits you field of view. Taking a step back and exploring other approaches is often more productive then trying to power through.

Generally, the implementation of a DSL can be quite different from the usual programming tasks, and comes with its own problems and pitfalls. Therefore, I'll list some points where you might want to pay special attention.

==== Name Clashes

A good DSL can be widely used in a code base, and of course that's a great thing. However, this also increases the possibility of name clashes. That's why it might be e.g. problematic to add extension methods to often used classes like `Int` or `String`. Sometimes two DSLs can clash, e.g. when trying to define the same operator.

==== Coupling

When writing a DSL for creating classes that are also under your control, you might be tempted to integrate the DSL tightly into these classes. This is very likely a bad idea, for various reasons:

* DSL code gets entangled with business logic
* the DSL becomes part of the classes' API, making it bloated and inflexible
* In many cases it is important that the result classes can work on its own. This might be the case for code generation or analysis tools, for working with big data or for testing
* at some point in time, the DSL may get obsolete

In Java, this kind of tight coupling might be excused because there often is no other way to make the DSL convenient to use. But Kotlin is much more expressive, most notably it has extension methods, so you don't have this excuse.

==== Code Conventions

A point where you might need to compromise is following code conventions, things like rules for writing upper- and lowercase. Of course, you should stick to code conventions whenever possible, but in the context of DSL design some deviations are acceptable. But if you have to break the rules, please document that this was a conscious decision.

==== Documentation

Often it turns out that you have to deviate a bit from the original specification, or you added some new details. Please don't forget to update the documentation accordingly.


