[#state_transitions]
== Modeling State Transitions in DSLs

> All things change in a dynamic environment. Your effort to remain what you are is what limits you.
-- Ghost in the Shell

DSLs often need to model complex state transitions that occur during program execution, to model workflows, or when objects need to be constructed in stages. In this chapter, we will explore three different techniques for modeling such use cases, how to choose the right one, and how to use these techniques in conjunction with other patterns such as the Builder and the Loan Pattern. The three approaches are:

* *Separate Classes*: The most intuitive implementation, where each state is represented by an independent class.
* *Chameleon Class*: The different states are represented by interfaces with their respective methods. A single class implements all interfaces, but the return type of its methods is always one of the interfaces, never the class itself.
* *Phantom Type*: A single class has a generic type parameter representing the different states, and extension methods can only be called for a particular state by specifying the appropriate type parameter for their receiver.

=== Case Study: DSL for SQL queries (using the Builder Pattern)

To allow a good comparison between the implementations, we will write a DSL for building SQL queries using the different approaches. Since the SQL language is very complex, we have to limit our example to queries using only `SELECT`, `FROM`, `WHERE` and `GROUP BY` clauses and simple string arguments (for a serious SQL DSL implementation, see https://www.jooq.org/[jOOQ]). The following state diagram gives an overview of the allowed transitions:

[ditaa,"sql-queries"]
.Simplified Select SQL Query
....
/--------\  /-------\
| Start  |  | JOIN  |
\---+----/  \---+---/
    |         ^ | /--------------------\
    |         | | |                    |
    v         | v |                    v
/--------\  /-+---+-\  /-------\  /----------\
| SELECT +->| FROM  +->| WHERE +->| GROUP BY |
\--------/  \---+---/  \---+---/  \----+-----/
                |          |           |
                v          v           v
            /--------------------------------\
            |             Finish             |
            \--------------------------------/
....

The final DSL will allow to write basic SQL queries like this:

[source,kotlin]
----
val queryAll = SELECT("p.firstName", "p.lastName", "p.income")
    .FROM("Person", "p")
    .build()

val queryJoin = SELECT("p.firstName", "p.lastName", "p.income")
    .FROM("Person", "p")
    .JOIN("Address", "a").ON("p.addressId","a.id")
    .WHERE("p.age > 20")
    .AND("p.age <= 40")
    .AND("a.city = 'London'")
    .build()

val queryGroupBy = SELECT("p.age", "min(p.income)", "max(p.income)")
    .FROM("Person", "p")
    .WHERE("p.age > 20")
    .GROUP_BY("p.age")
    .build()
----

While this example code uses a Builder Pattern syntax, we will also discuss what a Loan Pattern implementation of the same functionality might look like.

==== The 'Separate Classes' Approach (Builder Pattern)

The first approach is straightforward: Each state is represented by a separate class that is independent of all other classes. While this is conceptually very simple, the main drawback is that all collected data must be transferred between the classes representing the states. Often it is more convenient and readable to pass a dedicated Data Transfer Object (DTO) (((Data Transfer Object))) instead of using multiple parameters.

.Data Transfer Objects
****
A Data Transfer Object (DTO) is a container object that is used to hold and transfer data across layers, without any business logic or behavior. DTOs are often used to simplify the interface between different subsystems of an application, and to reduce the amount of data that needs to be exchanged between them. The primary purpose of a DTO is to provide a simple, standardized way of representing data that can be easily serialized and deserialized.
****

In preparation for writing the SQL query DSL, we need two helper classes and the DTO:

[source,kotlin]
----
data class NameWithAlias(
    val name: String,
    val alias: String? = null
) {
    override fun toString(): String = when (alias) {
        null -> name
        else -> "$name AS $alias"
    }
}

data class TableJoin(
    val nameWithAlias: NameWithAlias,
    val column1: String,
    val column2: String
)

data class QueryDTO(
    val columns: List<String>,
    val tableName: NameWithAlias,
    val joinClauses: List<TableJoin> = emptyList(),
    val whereConditions: List<String> = emptyList(),
    val groupByColumns: List<String> = emptyList()
)
----

Then we can write the `SELECT` part, which is straightforward:

[source,kotlin]
----
fun SELECT(vararg columns: String) = SelectClause(*columns)

class SelectClause(vararg val columns: String) {

    fun FROM(tableName: String, alias: String? = null) =
        FromClause(
            QueryDTO(
                columns = columns.asList(),
                tableName = NameWithAlias(tableName, alias)
            )
        )
}
----

There is no `build()` method, the only way forward is going into the `FromClause`, which is a bit more involved, as there might be multiple tables joined together:

[source,kotlin]
----
data class FromClause(val queryDTO: QueryDTO) {

    fun JOIN(tableName: String, alias: String? = null) =
        JoinClause(queryDTO, NameWithAlias(tableName, alias))

    fun WHERE(condition: String) =
        WhereClause(queryDTO.copy(
            whereConditions = listOf(condition)
        ))

    fun GROUP_BY(vararg groupByColumns: String) =
        GroupByClause(queryDTO.copy(
            groupByColumns = groupByColumns.toList()
        ))

    fun build() = build(queryDTO)
}
----

From here you can go to a `JoinClause`, which mimics SQL syntax by allowing you to write something like `fromClause.JOIN("Address","a").ON("p.addressId", "a.id")`. The other exit points lead to a `WhereClause` or a `GroupByClause`. Additionally, the `FromClause` has a `build()` method, because the `WHERE` and `GROUP BY` parts are optional. The `JoinClause` only provides an `ON()` method, which leads back to the `FromClause`:

[source,kotlin]
----
data class JoinClause(
    val queryDTO: QueryDTO,
    val tableName: NameWithAlias
) {

    fun ON(firstColumn: String, secondColumn: String) =
        FromClause(queryDTO.copy(
            joinClauses = queryDTO.joinClauses +
                TableJoin(tableName, firstColumn, secondColumn)
        ))
}
----

The `WhereClause` is quite simple, but of course using `String` to represent the different conditions is not very secure and should be avoided in production code. Our SQL subset allows us to proceed to the `GroupByClause` (while the full syntax would also allow `HAVING`, `ORDER BY`, etc.). Alternatively, we can end the query by calling the `build()` method:

[source,kotlin]
----
data class WhereClause(val queryDTO: QueryDTO) {

    fun AND(condition: String) =
        copy(queryDTO = queryDTO.copy(
            whereConditions = queryDTO.whereConditions +
                condition
        ))

    fun GROUP_BY(vararg groupByColumns: String) =
        GroupByClause(queryDTO.copy(
            groupByColumns = groupByColumns.toList()
        ))

    fun build() = build(queryDTO)
}
----

The `GroupByClause` only allows you to call the `build()` method:

[source,kotlin]
----
data class GroupByClause(val queryDTO: QueryDTO) {

    fun build() = build(queryDTO)
}
----

The only thing missing is the common `build(queryDTO)` method used by `FromClause`, `WhereClause` and `GroupByClause`:

[source,kotlin]
----
private fun build(queryDTO: QueryDTO): String = with(StringBuilder()) {

    val (columns, tableName, joinClauses, whereConditions, groupByColumns) =
        queryDTO

    append("SELECT ${columns.joinToString(", ")}")
    append("\nFROM $tableName")

    joinClauses.forEach { (n, c1, c2) ->
        append("\n  JOIN $n ON $c1 = $c2")
    }

    if (whereConditions.isNotEmpty())
        append("\nWHERE ${whereConditions.joinToString("\n  AND ")}")

    if (groupByColumns.isNotEmpty())
        append("\nGROUP BY ${groupByColumns.joinToString(", ")}")

    append(';')

}.toString()
----

Bundling all data into a DTO instance, as shown here, can significantly reduce the overhead of moving all data around, especially by taking advantage of the power of the `copy()` method. In the next section, we will explore an alternative implementation of the same DSL.

==== The Chameleon Class Approach (Builder Pattern) (((Chameleon Class)))

While using a separate DTO class makes the separate class approach more convenient, it would be nicer if we didn't have to copy data in the first place. But what about all the guarantees the first solution provides, e.g. that you can't call `build()` or `JOIN()` in a `SELECT` clause? One way to do this is to use a technique I call the "chameleon class". The basic idea is to adapt the type of this class to the current state it represents, and change it accordingly when the state changes.

.The Chameleon Class
****
A chameleon class

* implements multiple interfaces
* never exposes its own type, but always acts as one of those interfaces
* has a private constructor to avoid exposing its own type
* holds common data
****

First, we must translate our former state classes into interfaces:

[source,kotlin]
----
interface SelectClause {
    fun FROM(table: String, alias: String? = null): FromClause
}

interface FromClause{
    fun JOIN(tableName: String, alias: String? = null): JoinClause
    fun WHERE(condition: String): WhereClause
    fun GROUP_BY(vararg groupByColumns: String): GroupByClause
    fun build(): String
}

interface JoinClause {
    fun ON(firstColumn: String, secondColumn: String): FromClause
}

interface WhereClause {
    fun AND(condition: String): WhereClause
    fun GROUP_BY(vararg groupByColumns: String): GroupByClause
    fun build(): String
}

interface GroupByClause {
    fun build(): String
}
----

All that remains is to implement these interfaces in a single Chameleon class and keep track of the data. It's important to make the constructor private, because the initial type should not be the type of the class itself, but `SelectClause`.  That's why the `SELECT()` method in the companion object is used as a starting point for the DSL:

[source,kotlin]
----
class QueryBuilder private constructor(val columns: List<String>):
    SelectClause, FromClause, JoinClause, WhereClause, GroupByClause {
    var tableName = NameWithAlias("", null)
    var joinTableName = NameWithAlias("", null)
    val joinClauses = mutableListOf<TableJoin>()
    val whereConditions = mutableListOf<String>()
    val groupByColumns = mutableListOf<String>()

    companion object {
        fun SELECT(vararg columns: String): SelectClause =
            QueryBuilder(columns.asList())
    }

    // SelectClause
    override fun FROM(table: String, alias: String?): FromClause =
        this.apply { tableName = NameWithAlias(table, alias) }

    // FromClause
    override fun JOIN(tableName: String, alias: String?): JoinClause =
        this.apply { joinTableName = NameWithAlias(tableName, alias) }

    override fun WHERE(condition: String): WhereClause =
        this.apply { whereConditions += condition }

    // JoinClause
    override fun ON(firstColumn: String, secondColumn: String): FromClause =
        this.apply { joinClauses += TableJoin(joinTableName, firstColumn, secondColumn) }

    // WhereClause
    override fun AND(condition: String): WhereClause =
        this.apply { whereConditions += condition }

    // FromClause and WhereClause
    override fun GROUP_BY(vararg groupByColumns: String): GroupByClause =
        this.apply { this.groupByColumns += groupByColumns.toList() }

    // FromClause, WhereClause and GroupByClause
    override fun build(): String = with(StringBuilder()) {

        append("SELECT ${columns.joinToString(", ") { it }}")
        append("\nFROM $tableName")

        joinClauses.forEach { (n, c1, c2) ->
            append("\n  JOIN $n ON $c1 = $c2")
        }

        if (whereConditions.isNotEmpty())
            append("\nWHERE ${whereConditions.joinToString("\n  AND ")}")

        if (groupByColumns.isNotEmpty())
            append("\nGROUP BY ${groupByColumns.joinToString(", ")}")

        append(';')

    }.toString()
}
----

It doesn't matter to the compiler that you return the same object over and over again at runtime, because only the static type decides which methods can be called, and that static type is never `QueryBuilder` itself, but one of the interfaces for the SQL clauses. Using the DSL looks the same as before, and you still can't call methods out of order.

The chameleon class concept may look a bit strange at first, but usually results in compact and readable code. Be aware, however, that this approach is prone to name conflicts when two interfaces contain methods with the same name and parameters, but different return types.

==== The Phantom Type Approach (Builder Pattern)

The third approach uses <<chapter-04_features.adoc#typeLevelProgramming,phantom types>>(((Phantom Type))). The implementation is based on a DTO class with a generic parameter. This type parameter is not used as a type for any data within the class - that's why it's called a "phantom type". Instead, this parameter is used by extension functions that require their receiver to have the correct state

For the SQL query DSL, we need a type hierarchy containing the different clauses. As a slight complication, we also need two additional interfaces for methods that are present in multiple clauses. Then we need the DTO class itself. The `cast()` extension function allows us to easily switch between states. Since the generic parameter doesn't refer to any real data, the cast itself is safe. Of course, the `cast()` function must be private to prevent misuse:

[source,kotlin]
----
interface CanGroupBy
interface CanBuild

sealed interface State
interface SelectClause : State
interface FromClause : State, CanGroupBy, CanBuild
interface JoinClause : State
interface WhereClause : State, CanGroupBy, CanBuild
interface GroupByClause : State, CanBuild

data class QueryDTO<out State>(
    val columns: List<String>,
    val tableName: NameWithAlias = NameWithAlias(""),
    val joinTableName: NameWithAlias = NameWithAlias(""),
    val joinClauses: List<TableJoin> = emptyList(),
    val whereConditions: List<String> = emptyList(),
    val groupByColumns: List<String> = emptyList()
)

@Suppress("UNCHECKED_CAST")
private fun <S : State> QueryDTO<*>.cast(): QueryDTO<S> = this as QueryDTO<S>
----

The extension functions for the state transitions are straightforward:

[source,kotlin]
----
fun QueryDTO<SelectClause>.from(
        table: String,
        alias: String?
    ): QueryDTO<FromClause> =
    copy(tableName = NameWithAlias(table, alias)).cast()

fun QueryDTO<FromClause>.join(
        tableName: String,
        alias: String?
    ): QueryDTO<JoinClause> =
    copy(joinTableName = NameWithAlias(tableName, alias)).cast()

fun QueryDTO<FromClause>.where(
        condition: String): QueryDTO<WhereClause> =
    copy(whereConditions = whereConditions + condition).cast()

fun QueryDTO<JoinClause>.on(
        firstColumn: String,
        secondColumn: String
    ): QueryDTO<FromClause> =
    copy(joinClauses = joinClauses +
        TableJoin(joinTableName, firstColumn, secondColumn)
    ).cast()

fun QueryDTO<WhereClause>.and(
        condition: String): QueryDTO<WhereClause> =
    copy(whereConditions = whereConditions + condition)

fun QueryDTO<CanGroupBy>.groupBy(
        vararg groupByColumns: String): QueryDTO<GroupByClause> =
    copy(groupByColumns = groupByColumns.toList()).cast()

fun QueryDTO<CanBuild>.build(): String = with(StringBuilder()) {

    append("SELECT ${columns.joinToString(", ")}")
    append("\nFROM $tableName")

    joinClauses.forEach { (n, c1, c2) ->
        append("\n  JOIN $n ON $c1 = $c2")
    }

    if (whereConditions.isNotEmpty())
        append("\nWHERE ${whereConditions.joinToString("\n  AND ")}")

    if (groupByColumns.isNotEmpty())
        append("\nGROUP BY ${groupByColumns.joinToString(", ")}")

    append(';')

}.toString()
----

Note that `GROUP_BY()` can be called, for example, on `QueryDTO<FromClause>` even though it is defined as `fun QueryDTO<CanGroupBy>.groupBy(...)`. This is possible because the phantom type in `QueryDTO` was defined as contravariant using the `out` keyword. Without this, we would have needed a signature like `fun <S: CanGroupBy> QueryBuilder<S>.groupBy(...)` to be callable from a DTO with a sub-interface, which looks rather cryptic.

.Declaration-Site (((Declaration-Site Variance))) vs Use-Site Variance (((Use-Site Variance))) (((Variance)))
****
Declaration-site variance is a way of specifying the variance of a generic type when the type is defined or declared. In the declaration of a generic type or interface, you use variance annotations to specify whether the type parameter is covariant (`out`), contravariant (`in`), or invariant (neither). In contrast, use-site variance allows you to specify the variance of a generic type when you use it in a particular context (at the use site) using type bounds or wildcards. While Kotlin supports both styles, Java only allows use-site variance.
****

Chameleon classes and the phantom type implementation are conceptually similar, and it depends on the problem at hand whether a class with all methods or a DTO with extension methods is preferable. If the DSL needs to be called from Java, keep in mind that only the chameleon approach preserves the DSL syntax. On the other hand, the phantom type approach doesn't have fixed APIs for the different states, only extension functions that operate on them, which means that new functionality can be added more easily than with the other techniques.

=== Case Study: DSL for SQL queries (using the Loan Pattern) (((Loan Pattern)))

So far, all examples have used a Builder Pattern syntax. This doesn't have to be the case. A DSL that uses the Loan Pattern style might look like this:

[source,kotlin]
----
val queryAll = SELECT{
    +"p.firstName"
    +"p.lastName"
    +"p.income"
}.FROM{
    "Person" AS "p"
}.build()

val queryJoin = SELECT{
    +"p.firstName"
    +"p.lastName"
    +"p.income"
}.FROM{
    "Person" AS "p"
    JOIN{
        "Address" AS "a"
        ON("p.addressId","a.id")
    }
}.WHERE {
    +"p.age > 20"
    +"p.age <= 40"
    +"a.city = 'London'"
}.build()

val queryGroupBy = SELECT{
    +"p.age"
    +"min(p.income)"
    +"max(p.income)"
}.FROM{
    "Person" AS "p"
}.WHERE {
    +"p.age > 20"
}.GROUB_BY{
    +"p.age"
}.build()
----

This looks quite different from the Builder pattern syntax, and it is debatable whether this style looks better for this particular use case. It may be better suited for cases that require deeper nesting or more complex operations in the trailing lambda bodies.

One difference from the builder example is that `JOIN` is now nested, which seems more natural here. The lambda bodies give more freedom to use other DSL techniques, such as infix functions like `AS`. Also, we still need `build()` methods, as it is not clear when we are done constructing the query. In cases with only one exit state, the construction can be done behind the scenes, as usual in Loan Pattern implementations.

Note that for a serious implementation, the <<chapter-04_features.adoc#dslMarker,@DslMarker mechanism>> (((@DslMarker))) should be used, since the join clause is nested, but for the sake of brevity it won't be used in the following use cases.

==== The 'Separate Classes' Approach (Loan Pattern)

Here is what an implementation using separate classes might look like. We start as usual with the DTO, using the same helper classes `NameWithAlias` and `TableJoin` as before:

[source,kotlin]
----
data class QueryDTO(
    val columns: List<String>,
    val tableName: NameWithAlias = NameWithAlias(""),
    val joinClauses: List<TableJoin> = emptyList(),
    val whereConditions: List<String> = emptyList(),
    val groupByColumns: List<String> = emptyList()
)
----

Now we need a starting point, in the form of a `SELECT` function. It executes the given body (where the columns can be added) and passes the results to the `SelectClause` class, which in turn has a method to proceed to the `FromClause`:

[source,kotlin]
----
fun SELECT(body: SelectBody.() -> Unit) =
    SelectClause(QueryDTO(columns = SelectBody().apply(body).columns))

class SelectBody {
    val columns = mutableListOf<String>()
    operator fun String.unaryPlus() { columns += this }
}

class SelectClause(val queryDTO: QueryDTO) {
    fun FROM(body: FromBody.() -> Unit) =
        FromBody().apply(body).let{
            FromClause(queryDTO.copy(tableName = it.tableName, joinClauses = it.joinClauses))
        }
}
----

The `FromBody` is a little more complex, as it contains the nested `JOIN` clause:

[source,kotlin]
----
class FromBody {
    var tableName = NameWithAlias("")
    val joinClauses  = mutableListOf<TableJoin>()

    operator fun String.unaryPlus() { tableName = NameWithAlias(this) }

    infix fun String.AS(alias: String) { tableName = NameWithAlias(this, alias) }

    fun JOIN(body: JoinBody.() -> Unit) {
        JoinBody().apply(body).also {
            joinClauses += TableJoin(it.tableName, it.firstColumn, it.secondColumn)
        }
    }
}

data class FromClause(val queryDTO: QueryDTO) {

    fun WHERE(body: WhereBody.() -> Unit) =
        WhereClause(queryDTO.copy(whereConditions = WhereBody().apply(body).conditions))

    fun GROUP_BY(body: GroupByBody.() -> Unit) =
        GroupByClause(queryDTO.copy(groupByColumns = GroupByBody().apply(body).columns))

    fun build() = build(queryDTO)
}

data class JoinClause(val queryDTO: QueryDTO, val tableName: NameWithAlias) {

    fun ON(firstColumn: String, secondColumn: String) =
        FromClause(queryDTO.copy(
            joinClauses = queryDTO.joinClauses +
                TableJoin(tableName, firstColumn, secondColumn)
        ))
}
----

This scheme continues in the same style for the other clauses:

[source,kotlin]
----
data class WhereClause(val queryDTO: QueryDTO) {

    fun AND(condition: String) = copy(queryDTO = queryDTO.copy(whereConditions = queryDTO.whereConditions + condition))

    fun GROUP_BY(vararg groupByColumns: String) =
        GroupByClause(queryDTO.copy(groupByColumns = groupByColumns.toList()))

    fun build() = build(queryDTO)
}

data class GroupByClause(val queryDTO: QueryDTO) {

    fun build() = build(queryDTO)
}
----

The `build(queryDTO)` function is identical to the Builder-style version of the code.

Admittedly, the code is more difficult to read and write, but it allows for more flexible syntax within the trailing lambda blocks, which feels more natural and structured compared to the Builder Pattern syntax for a wide range of problems. Using the same techniques as before, we can improve the code.

==== The Chameleon Class Approach (Loan Pattern) (((Chameleon Class)))

To use a chameleon class, we must first turn the clause data classes into interfaces:

[source,kotlin]
----
interface SelectClause {
    fun FROM(body: FromBody.() -> Unit): FromClause
}

interface FromClause {
    fun WHERE(body: WhereBody.() -> Unit): WhereClause
    fun GROUP_BY(body: GroupByBody.() -> Unit): GroupByClause
    fun build(): String
}

interface WhereClause {
    fun GROUP_BY(body: GroupByBody.() -> Unit): GroupByClause
    fun build(): String
}

interface GroupByClause {
    fun build(): String
}
----

All the `...Body` classes remain unchanged, so we will skip them. The only thing missing is the Chameleon class itself:

[source,kotlin]
----
data class QueryBuilder private constructor(val columns: List<String>) :
    SelectClause, FromClause, WhereClause, GroupByClause {
    var tableName = NameWithAlias("")
    val joinClauses = mutableListOf<TableJoin>()
    val whereConditions = mutableListOf<String>()
    val groupByColumns = mutableListOf<String>()

    companion object {
        fun SELECT(body: SelectBody.() -> Unit): SelectClause =
            QueryBuilder(columns = SelectBody().apply(body).columns)
    }

    override fun FROM(body: FromBody.() -> Unit): FromClause =
        this.apply {
            val fromBody = FromBody().apply(body)
            tableName = fromBody.tableName
            joinClauses += fromBody.joinClauses
        }

    override fun WHERE(body: WhereBody.() -> Unit): WhereClause =
        this.apply {
            whereConditions += WhereBody().apply(body).conditions
        }

    override fun GROUP_BY(body: GroupByBody.() -> Unit): GroupByClause =
        this.apply {
            groupByColumns += GroupByBody().apply(body).columns
        }

    override fun build(): String = with(StringBuilder()) {

        append("SELECT ${columns.joinToString(", ")}")
        append("\nFROM $tableName")

        joinClauses.forEach { (n, c1, c2) ->
            append("\n  JOIN $n ON $c1 = $c2")
        }

        if (whereConditions.isNotEmpty())
            append("\nWHERE ${whereConditions.joinToString("\n  AND ")}")

        if (groupByColumns.isNotEmpty())
            append("\nGROUP BY ${groupByColumns.joinToString(", ")}")

        append(';')

    }.toString()
}
----

==== The Phantom Type Approach (Loan Pattern)

Implementing the DSL using phantom types is very similar to the corresponding Builder Pattern code. Again, the `...Body` classes are unchanged, and are omitted.

[source,kotlin]
----
interface CanGroupBy
interface CanBuild

sealed interface State
interface SelectClause : State
interface FromClause : State, CanGroupBy, CanBuild
interface WhereClause : State, CanGroupBy, CanBuild
interface GroupByClause : State, CanBuild

data class QueryDTO<out State>(
    val columns: List<String>,
    val tableName: NameWithAlias = NameWithAlias(""),
    val joinTableName: NameWithAlias = NameWithAlias(""),
    val joinClauses: List<TableJoin> = emptyList(),
    val whereConditions: List<String> = emptyList(),
    val groupByColumns: List<String> = emptyList()
)

@Suppress("UNCHECKED_CAST")
private fun <S: State> QueryDTO<*>.cast(): QueryDTO<S> = this as QueryDTO<S>

fun SELECT(body: SelectBody.() -> Unit): QueryDTO<SelectClause> =
    QueryDTO(columns = SelectBody().apply(body).columns)

fun QueryDTO<SelectClause>.FROM(body: FromBody.() -> Unit): QueryDTO<FromClause> =
        FromBody().apply(body).let {
            this@FROM.copy(tableName = it.tableName, joinClauses = it.joinClauses)
        }.cast()

fun QueryDTO<FromClause>.WHERE(body: WhereBody.() -> Unit): QueryDTO<WhereClause> =
    copy(whereConditions = WhereBody().apply(body).conditions).cast()

fun QueryDTO<CanGroupBy>.GROUP_BY(body: GroupByBody.() -> Unit): QueryDTO<GroupByClause> =
    copy(groupByColumns = GroupByBody().apply(body).columns).cast()

private fun QueryDTO<CanBuild>.build(): String = with(StringBuilder()) {

    append("SELECT ${columns.joinToString(", ")}")
    append("\nFROM $tableName")

    joinClauses.forEach { (n, c1, c2) ->
        append("\n  JOIN $n ON $c1 = $c2")
    }

    if (whereConditions.isNotEmpty())
        append("\nWHERE ${whereConditions.joinToString("\n  AND ")}")

    if (groupByColumns.isNotEmpty())
        append("\nGROUP BY ${groupByColumns.joinToString(", ")}")

    append(';')

}.toString()
----

=== Conclusion

In this chapter we discussed how state transitions can be expressed using different techniques. The DSLs can use either an underlying builder pattern or a loan pattern syntax, and there are different approaches to implementing them. When in doubt, I would recommend starting with the separate classes approach, especially when prototyping. If you use a DTO (as recommended), the code can easily be converted to the Chameleon or Phantom Type style later.

==== Preferable Use Cases

* Creating data
* Configuring systems
* Testing

==== Rating

* image:5_sun.png[] - for Simplicity of DSL design
* image:3_sun.png[] - for Elegance
* image:3_sun.png[] - for Usability
* image:2_sun.png[] - for Application Scope

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* enforces the correct state transitions
* natural way to write code that creates data in stages
* natural way to write DSLs for Finite State Machines

|* hard to read code
* boilerplate code
* the "separate classes" approach requires to copy data over
* the "Phantom Type" approach is hard to use from Java client code
|===