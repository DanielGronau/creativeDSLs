== Hybrid DSLs (((Hybrid DSLs)))

In many cases, it is hard to categorize a DSL because it uses a mix of different techniques: Some parts could resemble a builder, others look like an algebraic DSL, and in one place annotations are used. That's what I call a "hybrid DSL".

When most of a DSL can be written in a certain style, it is usually a good idea to stick with it in order to ensure a coherent look and feel. So I wouldn't advocate to mix builder and loan pattern styles together, but to decide on one. But there is nothing wrong with designing a DSL which combines different approaches, when it gets the job done, and manages to provide a coherent language.

=== Quasi-lingual DSLs (((Quasi-lingual DSLs)))

A common reason for mixing features from different DSL categories is to imitate - to a degree - natural language. I would call this important subgroup of Hybrid DSLs "quasi-lingual". Even though the syntax is usually rigid and contains artifacts like braces, parenthesis or commas, it is still "readable" in a very literal sense. This snippet from the mocking library https://mockk.io/#dsl-examples[MockK] should give you a good impression:

[source,kotlin]
----
every { car.door(DoorType.FRONT_LEFT).windowState() } returns WindowState.UP
----

Technically, writing a quasi-lingual DSL is not very different from other Hybrid DSLs, although it might be harder to model grammatical structures correctly. Also, name clashes with keywords like `is`, `as` etc. are more of a problem. A good rule of thumb is to keep the DSL grammar simple and well-structured, and to compromise when it helps to reduce complexity. E.g. instead of trying to model words like `should` `be` separated, it might be advisable to use `shouldBe` instead, when it helps to keep the grammar simple.

[#chemicalEquationsAsHybrid]
=== Case Study: Chemical Equations

Writing a DSL for chemical equations is no easy task, because the notation is very concise and can't be imitated easily using Kotlin syntax. For our case study, we will attempt to recreate the <<chapter-09_strings.adoc#chemicalEquationsAsString,string-based DSL>> from chapter 9 using a hybrid approach. We will use the same underlying model classes:

[source,kotlin]
----
sealed interface Part

data class Element(val symbol: String, val subscript: Int) : Part {
    override fun toString() = when (subscript) {
        1 -> symbol
        else -> symbol + subscript
    }
}

data class Group(val parts: List<Part>, val subscript: Int) : Part {
    override fun toString() = when (subscript) {
        1 -> parts.joinToString("", "(", ")")
        else -> parts.joinToString("", "(", ")") + subscript
    }
}

data class Molecule(val coefficient: Int, val parts: List<Part>) {
    override fun toString() = when (coefficient) {
        1 -> parts.joinToString("")
        else -> "$coefficient${parts.joinToString("")}"
    }
}

data class Equation(val leftSide: List<Molecule>, val rightSide: List<Molecule>, val reversible: Boolean = false) {
    override fun toString() = leftSide.joinToString(" + ") +
            (if (reversible) " <-> " else " -> ") +
            rightSide.joinToString(" + ")
}
----

As a refresher, here is the related structure chart:

[ditaa,"chemicalEquationAsHybrid"]
.Model for Chemical Equations
....

         +--------------+
         |   Chemical   |
         |              |
         |   Equation   |
         +---+------+---+
             |1     |1
        LHS  |      |  RHS
             vn     vn
         +--------------+
         |   Molecule   |
         |              |
         | e.g. 2CH3OH  |
         +------+-------+
                |1
                |
                vn
         +--------------+
         |   Molecular  |
         |              +<--+
         |     Part     |   |1
         +-+----------+-+   |
           |          |     |
           |is-a  is-a|     |n
    +------+--+    +--+-----+-+
    | Element |    |  Group   |
    |         |    |          |
    | e.g. H2 |    |e.g. (OH)2|
    +---------+    +----------+

....

As a first step, we define the elements as `val`{nbsp}s:

[source,kotlin]
----
val H = Element("H", 1)
val He = Element("He", 1)
val Li = Element("Li", 1)
// etc.
----

Next, we need a convenient way to add the subscript to an element or a group. For this, we could use the invoke-operator `()` or the index access operator `[]`. As we will need parentheses in other places as well, the index access operator seems to be the better choice for this job. We can now write `H[2]` to denote `H~2~`:

[source,kotlin]
----
operator fun Element.get(subscript: Int) =
    apply { require(this.subscript == 1 && subscript > 1) }
        .copy(subscript = subscript)
operator fun Group.get(subscript: Int) =
    apply { require(this.subscript == 1 && subscript > 1) }
        .copy(subscript = subscript)
----

The code for both functions contains a sanity check, which won't allow nonsensical calls like `H[-5]` or `H[2][7]`.

The next task is to assemble molecules from either elements or groups. We can use the minus operator `-` to represent a chemical bond, e.g. a water molecule could be written as `H[2]-O`. We also need to assemble groups, and we have to distinguish them from molecules, so we need to use a different operator for the bonds inside groups. From the few remaining choices the range operator `..` seems like a good fit, so we can write e.g. a carboxyl group as `(C..O..O..H)`:

[source,kotlin]
----
operator fun Part.minus(that: Part) =
    Molecule(1,listOf(this, that))

operator fun Molecule.minus(that: Part) =
    copy(parts = parts + that)

operator fun Element.rangeTo(that: Part) =
    Group(listOf(this, that),1)

operator fun Group.rangeTo(that: Part) =
    copy(parts = parts + that)
----

Generally, we have to put groups and sometimes molecules in parentheses because of the precedence rules.

A molecule can have an optional coefficient in front. Also, the same multiplication operation should "promote" an element or group to a molecule, allowing e.g. to write `2*O[2]` resulting in an oxygen molecule with a coefficient of two. Again, we need sanity checks, rendering calls like `-2*H[2]` or `3*(2*O[2])` invalid:

[source,kotlin]
----
operator fun Int.times(that: Molecule) =
    that.apply { require(coefficient == 1 && this@times > 1) }
        .copy(factor = this)

operator fun Int.times(that: Part) =
    Molecule(this, listOf(that))
        .apply { require(coefficient > 1) }
----

Next, we need a way to group the left and right side of an equation to a list of molecules, and the obvious choice for an operator is `+`. As before, we "promote" molecule parts to full molecules when necessary. This time the precedence rules for `*` and `+` play nicely along with the intended use, so we won't need parentheses on this level.

[source,kotlin]
----
operator fun Molecule.plus(that: Molecule) =
    listOf(this, that)

operator fun Molecule.plus(that: Part) =
    listOf(this, Molecule(1,listOf(that)))

operator fun Part.plus(that: Molecule) =
    listOf(Molecule(1,listOf(this)), that)

operator fun List<Molecule>.plus(that: Part) =
    this + Molecule(1, listOf( that))
----

In case you wonder why there is no `List<Molecule>.plus(that: Molecule)` function: This would be just a special case of adding elements to a list, which is already defined in the standard library.

The last part of the DSL is collecting everything in an equation. This is not complicated, but lengthy, because we might encounter not only lists of molecules, but single molecules or molecule parts on both sides of the equation. Further, we have to account for the two different equation types:

[source,kotlin]
----
infix fun List<Molecule>.reactsTo(that: List<Molecule>) =
    Equation(this, that, false)

infix fun Molecule.reactsTo(that: List<Molecule>) =
    Equation(listOf(this), that, false)

infix fun List<Molecule>.reactsTo(that: Molecule) =
    Equation(this, listOf(that), false)

infix fun Molecule.reactsTo(that: Molecule) =
    Equation(listOf(this), listOf(that), false)

infix fun Part.reactsTo(that: List<Molecule>) =
    Equation(listOf(Molecule(1,listOf(this))), that, false)

infix fun List<Molecule>.reactsTo(that: Part) =
    Equation(this, listOf(Molecule(1, listOf(that))), false)

infix fun Part.reactsTo(that: Part) =
    Equation(listOf(Molecule(1,listOf(this))), listOf(Molecule(1,listOf(that))), false)

infix fun Part.reactsTo(that: Molecule) =
    Equation(listOf(Molecule(1,listOf(this))), listOf(that), false)

infix fun Molecule.reactsTo(that: Part) =
    Equation(listOf(this), listOf(Molecule(1,listOf(that))), false)

// same functions for reversibleTo, just with
// an equation having reversible == true
----

Unfortunately, we have to resort to infix functions, as there seems to be no suitable operator available. A common trick is to use the backtick syntax(((Backtick Notation))) to mimic an operator, but `{backtick}-{zwsp}>{backtick}` and `{backtick}<{zwsp}-{zwsp}>{backtick}` won't work: `<` and `>` are two of the very few characters that are not allowed in backtick syntax on the JVM.

So, how does our DSL look in action? Here are a few examples:

[source,kotlin]
----
//2H2 + O2 <-> 2H2O
val makingWater =
    2*H[2] + O[2] reversibleTo 2*(H[2]-O)

//3Ba(HO)2 + 2H3PO4 -> 6H2O + Ba3(PO4)2
val makingBariumPhosphate =
    3*(Ba-(O..H)[2]) + 2*(H[3]-P-O[4]) reactsTo
        6*(H[2]-O) + Ba[3]-(P..O[4])[2]

//H2SO4 + 8HI <-> H2S + 4I2 + 4H2O
val sulfuricAcidAndHydrogenIodide =
    H[2]-S-O[4] + 8*(H-I) reversibleTo (H[2]-S) + 4*I[2] + 4*(H[2]-O)

//CuSO4 + 4H2O -> [Cu(H2O)4]SO4
val copperSulfateComplex =
    Cu-S-O[4] + 4*(H[2]-O) reactsTo (Cu..(H[2]..O)[4])-S-O[4]
----

There is one optional improvement, which is more a matter of taste: We could add some extension properties for low subscripts of elements and groups, which would allow to write e.g. `N._2` instead of `N[2]`:

[source,kotlin]
----
val Element._2
    get() = this.apply { require(subscript == 1) }.copy(subscript = 2)
val Element._3
    get() = this.apply { require(subscript == 1) }.copy(subscript = 3)
// etc.

val Group._2
    get() = this.apply { require(subscript == 1) }.copy(subscript = 2)
val Group._3
    get() = this.apply { require(subscript == 1) }.copy(subscript = 3)
// etc.

// new syntax
val eq = 3*(Ba-(O..H)._2) + 2*(H._3-P-O._4) reactsTo
            6*(H._2-O) + (Ba._3-(P..O._4)._2)
----

Please decide for yourself which version you prefer. Personally, I find the syntax with the index operator `[]` more readable.

Simulating the dense chemical notation is hard, and while using operator overloading and infix notation made our example substantially shorter, it still contains a lot of clutter. Of course, after some time one would get used to the DSL, but there is clearly a learning curve involved. You have already seen how the same problem can be tackled with a string-based DSL, which seems to be the more elegant approach in this specific case.

=== Case Study: Pattern Matching (((Pattern Matching)))

//TODO revamp

Kotlin's `when` is certainly more versatile than Java's `switch`, but languages like Scala or Haskell go one step further and allow pattern matching. This feature allows you to destructure and match values against specific patterns. It provides a concise and powerful way to perform conditional branching and data extraction based on the structure and contents of the input.

In pattern matching, you define a set of patterns that describe the possible shapes or values that an input can take. These patterns can include literals, variables, data constructors, or even more complex patterns like lists or tuples. The language then matches the input against these patterns and executes the corresponding code block or expression associated with the first matching pattern.

In this case study, we want to provide similar functionality in Kotlin, although it won't be as elegant as its built-in counterparts in other languages.

An ideal syntax could look like this:

[source,text]
----
//not (yet?) Kotlin
val p = Person("Andy", "Smith", 43)

val result = match(p) {
    Person("Andy", "Miller", _) ->
        "It's Andy Miller!"
    Person("Andy", lastName != "Miller", age) ->
        "Some other Andy of age $age."
    else -> "Some unknown person."
}
----

However, we have to allow for some compromises to make it work in Kotlin:

* We can't use `Person` in the match cases, but we need to write a helper function.
* It is difficult to support a mix of literal values and patterns, so for our small example we need to wrap all values like `"Andy"` in a pattern, e.g. `eq("Andy")`
* The arrow notation is not possible, we will use `then` instead
* Comparisons as well as `and` and `or` can be only infix functions
* The right sides should be only evaluated if needed, so we need braces for lazy evaluation.
* Capturing variables on the left and using them on the right requires a dedicated "capture" pattern.
* `else` is a keyword, so `otherwise` is used instead. As it is not possible to determine at compile time whether the given conditions are exhaustive, the `otherwise` branch is mandatory
* In some cases, we need to provide generic type information.

That's a rather long list, let's see how our example looks now:

[source,kotlin]
----
val result = match(p) {
    person(eq("Andy"), eq("Miller"), any()) then
        { "It's Andy Miller!" }
    val ageCapture = capture<Int>()
    person(eq("Andy"), !eq("Miller"), ageCapture) then
        { "Some other Andy of age ${ageCapture.value}." }
    otherwise { "Some unknown person." }
}
----

That doesn't look too bad. The core of the DSL is quite small. It consists of a matcher providing a context for keeping track of the result and defining the `then` and `otherwise` methods. Then we have the pattern, which is just a test function, so we can use a type alias instead of introducing a new interface. The `MatchResult` is just an interface wrapping a given value. And finally, the `match()` function ties everything together and acts as an entry point for the DSL:

[source,kotlin]
----
typealias Pattern<P> = (P) -> Boolean

interface MatchResult<T : Any> {
    val value: T
}

class Matcher<P, T : Any>(private val obj: P) {

    private var result: T? = null

    infix fun Pattern<P>.then(value: () -> T) {
        if (result == null && this(obj)) {
            result = value()
        }
    }

    fun otherwise(default: () -> T) = object : MatchResult<T> {
        override val value = result ?: default()
    }
}

fun <P, T : Any> match(obj: P, body: Matcher<P, T>.() -> MatchResult<T>): T =
    Matcher<P, T>(obj).run(body).value
----

Note that the `body` parameter of the `match()` method requires a `MatchResult` as return value, and immediately extracts its content. So why doesn't the block simply return a `T` value directly? This is a trick to remind users to call the `otherwise()` method at the end of the block, because this is the obvious way to construct such a instance.

Of course, there are still patterns missing for the left-hand sides of the `then` infix functions. For implementing them, we can take advantage of the simplified syntax for functional interfaces (a.k.a. SAM conversion). Most of them are quite easy to write:

[source,kotlin]
----
// matches everything
fun <P> any(): Pattern<P> =
    { true }

// matches nothing
fun <P> none(): Pattern<P> =
    { false }

// matches null values
fun <P> isNull(): Pattern<P> =
    { it == null }

// negates a pattern
operator fun <P> Pattern<P>.not(): Pattern<P> =
    { !this@not(it) }

// conjunction of patterns
infix fun <P> Pattern<P>.and(that: Pattern<P>): Pattern<P> =
    { this@and(it) && that(it) }

// disjunction of patterns
infix fun <P> Pattern<P>.or(that: Pattern<P>): Pattern<P> =
    { this@or(it) || that(it) }

// equality to a value
fun <P> eq(value: P): Pattern<P> =
    { it == value }

// equality to one of the values
fun <P> oneOf(vararg values: P): Pattern<P> =
    { it in values }

// type check
fun <P> isA(kClass: KClass<*>): Pattern<P> =
    { kClass.isInstance(it) }

// instance equality
fun <P> isSame(value: P): Pattern<P> =
    { it === value }
----

For comparing values, some type checks are needed in order to ensure that the value is comparable. That's why we need <<chapter-04_features.adoc#reifiedGenerics, reified generics>> in this case:

[source,kotlin]
----
// greater than
inline fun <reified C : Comparable<C>> gt(value: C): Pattern<C> =
    { it > value }

// greater or equal
inline fun <reified C : Comparable<C>> ge(value: C): Pattern<C> =
    { it >= value }

// less than
inline fun <reified C : Comparable<C>> lt(value: C): Pattern<C> =
    { it < value }

// less or equal
inline fun <reified C : Comparable<C>> le(value: C): Pattern<C> =
    { it <= value }
----

Similarly to the existing `all()`, `any()` and `none()` predicates on `Iterable`{nbsp}s, we can define those as patterns:

[source, kotlin]
----
// checks that all elements match the given pattern
fun <P> all(p: Pattern<P>) : Pattern<Iterable<P>> =
    { it.all(p) }

// checks that at least one element matches the given pattern
fun <P> any(p: Pattern<P>) : Pattern<Iterable<P>> =
    { it.any(p) }

// checks that no element matches the given pattern
fun <P> none(p: Pattern<P>) : Pattern<Iterable<P>> =
    { it.none(p) }
----

For capturing values we need a class implementing `Pattern<T>`, which can also hold a value:

[source,kotlin]
----
class Capture<P : Any> : Pattern<P> {

    lateinit var value: P
        private set

    override fun invoke(obj: P) = true.also { value = obj }
}

inline fun <reified P : Any> capture() = Capture<P>()
----

For capturing values, you first define a val using the `capture<T>()` method. Then you can use it on the left-hand side of `then` as a pattern, which always succeeds, but also stores the value. On the right-hand side the value can be read from the val. The initial example for the syntax demonstrates the usage

[source,kotlin]
----
val result = match(p) {
    ...
    val ageCapture = capture<Int>()
    person(eq("Andy"), !eq("Miller"), ageCapture) then
        { "Some other Andy of age ${ageCapture.value}." }
    ...
}
----

Now the only missing pattern is the one for decomposing a data class, but unfortunately it is not possible to write code to handle all data classes at once in a typesafe manner. So we are forced to write a pattern for every data class we want to use in a pattern, but it is straightforward to do so:

[source,kotlin]
----
fun person(
    firstNamePattern: Pattern<String>,
    lastNamePattern: Pattern<String>,
    agePattern: Pattern<Int>
): Pattern<Person?> = {
    when (it) {
        null -> false
        else -> firstNamePattern(it.firstName) &&
                lastNamePattern(it.lastName) &&
                agePattern(it.age)
    }
}
----

The next chapter discusses how to generate such boilerplate code.

Of course, you can write many more patterns, but the DSL is already functional as it is. Regardless of the complexity of the topic, it wasn't that difficult to come up with a quite usable DSL, which demonstrates the power and expressiveness of Kotlin.

=== Conclusion

Writing high-quality hybrid DSLs can be a complex task, as it requires careful consideration and integration of different language features. It's important to recognize that not all language features may work seamlessly together, and in such cases, it is often better to stick with a consistent style throughout the DSL.

However, when done well, a well-designed hybrid DSL can effectively combine various techniques in a way that feels intuitive and organic. By leveraging the strengths of different language features and carefully designing their integration, you can create very powerful and expressive DSLs.

==== Preferable Use Cases

* Creating data
* Transforming data
* Define operations
* Execute actions
* Generating code
* Configuring systems
* Testing
* Logging

==== Rating

* image:3_sun.png[] - for Simplicity of DSL design
* image:4_sun.png[] - for Elegance
* image:4_sun.png[] - for Usability
* image:5_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* can support a wide range of problems
* allows to get creative with different techniques
* can get very concise by having many implementation options

|* might look incoherent
* high perceptual complexity -> steeper learning curve
* difficult to control and predict the outcome
* higher maintenance effort needed
* Java interoperability can be very challenging
|===
