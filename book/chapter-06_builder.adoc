== Builder Pattern DSLs and Method Chaining

> Builders are the poets of object creation, crafting instances with eloquent syntax and profound semantics.
-- ChapGPT 3.5

A common task is to initialize a complex, sometimes nested object. The classic solution is the _Builder Pattern_: the builder class is mutable, uses method chaining(((Method Chaining))) (also called "Fluent Interfaces")(((Fluent Interface))) to simplify value assignment, and contains a terminal build method that constructs the domain object. Note that while builders are the most prominent use case, method chaining can be used in other contexts, and the points made for builders can usually be applied to such cases as well.

This chapter covers the classic builder pattern as it is often used in Java. Next, we will show how named arguments can often replace the builder pattern in Kotlin, especially when constructing smaller classes. We will also briefly discuss nested builders. Next, we will address the issue of mandatory fields in builders by introducing the _Typesafe Builder Pattern_, and we will also cover the related _Counting Builder_. Finally, we discuss why builders are not as widely used in Kotlin as they are in Java.

=== Classical Builder

As an example for a classical builder with realistic complexity, we can use `java.net.http.HttpRequest`, which is written in Java. A typical builder call could look like this:

[source,kotlin]
.https://docs.oracle.com/en/java/javase/18/docs/api/java.net.http/java/net/http/HttpRequest.Builder.html
----
val request = HttpRequest.newBuilder(URI.create("https://acme.com:9876/products"))
    .GET()
    .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
    .header("Accept-Encoding", "gzip, deflate")
    .timeout(Duration.ofSeconds(5L))
    .build()
----

As this example shows, a builder has three parts:

* *Builder Initialization:* The builder needs a starting point, which can be provided by a constructor or factory method. This initializes the builder instance and prepares it for data collection.
* *Data Collection:* Through method chaining, the builder instance collects the necessary data and configuration options. Each method call adds a specific attribute or behavior to the final object being constructed.
* *Target Object Construction:* To complete the construction process, a terminal method, often called `build()`, is called. This method performs any necessary validation on the collected data and proceeds to instantiate the target object with the provided configuration.

By following this pattern, builders provide a structured approach to constructing objects with customizable parameters, providing a convenient and readable way to initialize complex objects in a flexible manner.

If you want to write a builder in Kotlin, you can take advantage of the `apply()` or `also()` method. Consider this example:

[source,kotlin]
----
class Person(val firstName: String, val lastName: String, val age: Int?)

class PersonBuilder {
    private var firstName: String? = null
    private var lastName: String? = null
    private var age: Int? = null

    fun setFirstName(firstName: String): PersonBuilder {
        this.firstName = firstName
        return this
    }

    fun setLastName(lastName: String): PersonBuilder {
        this.lastName = lastName
        return this
    }

    fun setAge(age: Int): PersonBuilder {
        this.age = age
        return this
    }

    fun build() = Person(firstName!!, lastName!!, age)
}
----

This looks pretty much like you would write the builder in Java, but using `apply()` is shorter and more idiomatic:

[source,kotlin]
----
class PersonBuilder {
    private var firstName: String? = null
    private var lastName: String? = null
    private var age: Int? = null

    fun setFirstName(firstName: String) = apply {
        this.firstName = firstName
    }

    fun setLastName(lastName: String) = apply {
        this.lastName = lastName
    }

    fun setAge(age: Int) = apply {
        this.age = age
    }

    fun build() = Person(firstName!!, lastName!!, age)
}
----

=== Named Arguments instead of Builders

In Kotlin, you may not need a builder because the language has features like named and default arguments that can provide similar functionality. Consider this implementation of an RGBA color:

[source,kotlin]
----
data class Color(
    val red: Int,
    val green: Int,
    val blue: Int,
    val alpha: Int = 255
)

val c = Color(0, 100, 130, 200)
----

Written like this, the four `Int` values may be a little confusing to read, especially when you expect only three values, as is usual for RGB colors. However, instead of relying on a builder, you can simply clarify the meaning by rewriting the last line as follows:

[source,kotlin]
----
val c = Color(
    red = 0,
    green = 100,
    blue = 130,
    alpha = 200
)
----

The syntax is different, but the functionality of this code is very similar to a builder. Of course, like a builder, the arguments can be listed in any order. A notable difference between named arguments is that each argument can only be set once, while a builder allows you to set (and possibly overwrite) an argument value multiple times.

The `Color` class is immutable, but if you want to get modified copies, you can use the `copy()` method:

[source,kotlin]
----
val c = Color(0, 100, 130, 200)
val c1 = c.copy(red = 120)
----

The `copy()` method is autogenerated for all `data` classes. In Java, you would have to write a method equivalent to `fun withRed(r: Int): Color` (sometimes called _wither_ similar to "getter" and "setter"). Such methods may also be necessary in Kotlin when you can't use data classes, but they are less common than in Java.

=== Nesting Builders (((Nested Builders)))

When an object has complex components, it makes sense to have not only a top-level builder, but also builders for those components, their own subcomponents, and so on. A typical example of such nested builders is the DSL of the  https://square.github.io/kotlinpoet/[KotlinPoet] library:

[source,kotlin]
.https://square.github.io/kotlinpoet/
----
val file = FileSpec.builder("", "HelloWorld")
  .addType(
    TypeSpec.classBuilder("Greeter")
      .primaryConstructor(
        FunSpec.constructorBuilder()
          .addParameter("name", String::class)
          .build()
      )
      .addProperty(
        PropertySpec.builder("name", String::class)
          .initializer("name")
          .build()
      )
      .addFunction(
        FunSpec.builder("greet")
          .addStatement("println(%P)", "Hello, \$name")
          .build()
      )
      .build()
  )
  .addFunction(
    FunSpec.builder("main")
      .addParameter("args", String::class, VARARG)
      .addStatement("%T(args[0]).greet()", greeterClass)
      .build()
  )
  .build()
----

As this example shows, the need to call `build()` at the end of each nested builder leads to a lot of visual clutter. To avoid this problem, some DSLs make builder nesting more convenient by having two versions of each nested method: One version that takes the constructed object as an argument as usual, and another version that takes a builder of the object instead. This way, the user doesn't have to repeatedly call `build()` methods for the nested builders.

==== Flattening instead of Nesting

An alternative to nesting builders is to handle everything in the top-level builder, by putting the nested content between a start and end method. In KotlinPoet, control flows are implemented this way:

[source,kotlin]
----
val funSpec = FunSpec.constructorBuilder()
    .addParameter("value", String::class)
    .beginControlFlow("require(value.isNotEmpty())")
    .addStatement("%S", "value cannot be empty")
    .endControlFlow()
    .build()
----

This approach can make the DSL code more readable, but it requires more discipline on the part of the user to ensure that the start and end methods are placed properly. To give an example implementation, consider a `Person` class that contains a name, a phone number, and a list of contacts that also have a name and optionally a phone:

[source,kotlin]
----
data class Contact(
    val name: String,
    val phone: String?)

data class Person(
    val name: String,
    val phone: String,
    val contacts: List<Contact>)

class PersonBuilder {
    private var name: String? = null
    private var phone: String? = null
    private var addingContact = false
    private var contactName: String? = null
    private var contactPhone: String? = null
    private val contacts: MutableList<Contact> = mutableListOf()

    fun beginContact() = apply {
        require(!addingContact)
        addingContact = true
    }

    fun endContact() = apply {
        require(addingContact)
        contacts.add(Contact(contactName!!, contactPhone))
        contactName = null
        contactPhone = null
        addingContact = false
    }

    fun setName(name: String) = apply {
        if (addingContact) this.contactName = name else this.name = name
    }

    fun setPhone(phone: String) = apply {
        if (addingContact) this.contactPhone = phone else this.phone = phone
    }

    fun build(): Person {
        require(!addingContact)
        return Person(name!!, phone!!, contacts)
    }
}
----

And this is how the DSL could be used:

[source,kotlin]
----
val superman = PersonBuilder()
    .setName("Superman")
    .beginContact()
    .setName("Wonder Woman")
    .endContact()
    .setPhone("555-3213-125")
    .beginContact()
    .setName("Lois Lane")
    .setPhone("555-4112-423")
    .endContact()
    .build()
----

The process flow of a flattened builder can also be thought of as a very simple state transition, namely from the outer layer to the inner layer and back. xref:chapter-08_transitions.adoc[Chapter 8] demonstrates techniques to implement such state transitions in a safe way, so that the code won't compile if the start and end methods are placed incorrectly.

While there are certainly valid use cases for a flattening builder, the usual approach based on nesting is not only simpler conceptually and implementation-wise, it also scales better, and should therefore be preferred.

==== Nesting with Varargs (((Varargs)))

If you are building a tree-like structure where each node has only one type of child, method chaining using varargs can lead to quite elegant DSLs. A good example is data validation, where you check if a value matches your specification, and if it does not, you get a list of problems. You can have validators that just check a simple condition, like a `String` not being blank, but you can also have validators that combine the results of sub-validators.

Here is our validation result type:

[source,kotlin]
----
sealed interface Validation {
    data object Success : Validation
    data class Failure(val reasons: List<String>) : Validation

    operator fun Validation.plus(that: Validation): Validation = when {
        this is Failure && that is Failure -> this.copy(reasons = this.reasons + that.reasons)
        this is Success -> that
        else -> this
    }
}
----

Now we need the `Validator` interface and a validate extension function that can be called on any object. When nesting validators, we would not only see our own `validate()` method, but also the one from our caller, etc., so we use the `@DslMarker` (((@DslMarker))) mechanism to hide the latter. We also include a helper function to construct a validator based on a condition.

[source,kotlin]
----
@DslMarker
annotation class ValidationDsl

@ValidationDsl
fun interface Validator<T> {
    fun validate(t: T): Validation
}

fun <T> T.validate(
    vararg validators: Validator<T>
): Validation = validators.fold<_, Validation>(Validation.Success) { result, validator ->
    result + validator.validate(this)
}

private infix fun Boolean.then(reason: String) = when {
    this -> Validation.Failure(listOf(reason))
    else -> Validation.Success
}
----

Writing simple validators is straightforward, especially since `Validator` is a functional interface, so I'll only show a few examples for string validators:

[source,kotlin]
----
fun notBlank() = Validator<String> {
    it.isBlank() then "String can't be blank"
}

fun minLength(min: Int) = Validator<String> {
    (it.length < min) then "String '$it' must have at least $min characters"
}

fun maxLength(max: Int) = Validator<String> {
    (it.length > max) then "String '$it' must have at most $max characters"
}
----

Using them is very simple, a typical call could be `myString.validate(notBlank(), maxLength(10))`.

Now comes the interesting part, namely validators that take other validators as arguments, or more specifically, as varargs:

[source,kotlin]
----
fun <T> forAll(vararg validators: Validator<T>) = Validator<List<T>> {
    it.fold<_, Validation>(Validation.Success) { result, element ->
        result + element.validate(*validators)
    }
}

fun <T, S> KProperty1<T, S>.validate(
    vararg validators: Validator<S>
) = Validator<T> {
    validators.fold<_, Validation>(Validation.Success) { result, validator ->
        result + validator.validate(this.call(it))
    }
}

fun <T, S> KFunction1<T, S>.validate(
    vararg validators: Validator<S>
) = Validator<T> {
    validators.fold<_, Validation>(Validation.Success) { result, validator ->
        result + validator.validate(this.call(it))
    }
}
----

The `forAll()` function applies the given validators to all elements of a list. The next two functions allow you to validate properties and getter-like functions of the given value. If you look at the sample calls, you can see how the nested varargs give the DSL a tree-like shape, without much syntactic clutter:

[source,kotlin]
----
data class Child(val name: String, val friends: List<String>)

val child = Child("Charlie", listOf("Snoopy", "Lucy", "Linus"))

val result = child.validate(
    Child::name.validate(
        minLength(2),
        maxLength(3)
    ),
    Child::friends.validate(
        forAll(
            notBlank(),
            maxLength(5)
        )
    )
)

// Failure(reasons=[
//   String 'Charlie' must have at most 3 characters,
//   String 'Snoopy' must have at most 5 characters
// ])
----

As mentioned above, this style isn't always feasible, but when it can be used, it often improves readability.

=== The Typesafe Builder Pattern (((Typesafe Builder Pattern)))

A common problem with builders is the inability to enforce the setting of mandatory fields. While it's possible to check for these conditions in the build method, it would be better if the compiler could prevent incomplete objects from being built. To achieve this, we can use <<chapter-04_features.adoc#typeLevelProgramming, Type-Level Programming>>(((Type-Level Programming))), although it requires some boilerplate code.

By using generics to track the state of mandatory fields, the build method can be adapted to accept only builders with all mandatory values set. For example, consider the following class for a product that requires a product id, name, and price, while the other attributes are optional:

[source,kotlin]
----
 data class Product(
    val id: UUID,
    val name: String,
    val price: BigDecimal,
    val description: String?,
    val images: List<URI>)
----

The first requirement for our builder is three classes to represent the state of the mandatory fields. They are similar to `Optional`, except that the empty and full states are represented by different subclasses. The type parameter `T: Any` was used because it prevents `T` from being inhabited by a nullable type.

[source,kotlin]
----
sealed class Val<T: Any>

class Without<T: Any> : Val<T>()

class With<T: Any>(val value: T): Val<T>()
----

With the help of these classes, we can write the builder:

[source,kotlin]
----
data class ProductBuilder<
      ID: Val<UUID>,
      NAME: Val<String>,
      PRICE: Val<BigDecimal>> private constructor(
    val id: ID,
    val name: NAME,
    val price: PRICE,
    val description: String?,
    val images: List<URI>) {
    ...
}
----

The generic signature looks complicated, but the idea behind it is simple: Each mandatory field has its own generic type parameter that keeps track of whether it is already set or not. The constructor was made private because we want to make sure we start with an empty builder. As a replacement, we implement a companion object that simulates a constructor using the `invoke` operator:

[source,kotlin]
----
data class ProductBuilder<
      ID: Val<UUID>,
      NAME: Val<String>,
      PRICE: Val<BigDecimal>> private constructor(
    val id: ID,
    val name: NAME,
    val price: PRICE,
    val description: String?,
    val images: List<URI>) {

        companion object {
                inline fun invoke() = ProductBuilder(
                id = Without(),
                name = Without(),
                price = Without(),
                description = null,
                images = listOf()
            )
        }

        fun id(uuid: UUID) =
            ProductBuilder(With(uuid), name, price, description, images)

        fun name(name: String) =
            ProductBuilder(id, With(name), price, description, images)

        fun price(price: BigDecimal) =
            ProductBuilder(id, name, With(price), description, images)

        fun description(desc: String) =
            copy(description = desc)

        fun addImage(image: URI) =
            copy(images = images + image)
}
----

The inferred return type of this `invoke()` operation is `ProductBuilder<Without<UUID>, Without<String>, Without<BigDecimal>>`, which fortunately we don't have to write out. When an optional field is set, these type parameters don't change, but when a mandatory field is set, the signature changes from `Without` to `With` for that particular field. Since the mandatory field setters return a builder with a changed signature, we can't use the `copy()` method in these cases (at least if we don't want to use casts).

Of course, a crucial part is missing: The `build()` method. But we can't write it as part of the builder class, because it needs to check the generic signature. It _must_ be an extension method, because only there can you "fix" the type parameters to concrete types, which is known as <<chapter-04_features.adoc#typeNarrowing, type narrowing>>(((Type Narrowing))):

[source,kotlin]
----
fun ProductBuilder<With<UUID>, With<String>, With<BigDecimal>>.build() =
    Product(id.value, name.value, price.value, description, images)
----

Note that you can access the `value` fields of the `With` classes, because the type inference matches on the "narrowed" type. Now we have a builder with a `build()` method that can only be called if all mandatory fields are set:

[source,kotlin]
----
ProductBuilder()
    .id(UUID.randomUUID())
    .name("Comb")
    .description("Green plastic comb")
    .price(12.34.toBigDecimal())
    .build()
----

You can check that the code no longer compiles after removing one of the mandatory fields.

NOTE: The Typesafe Builder Pattern was pioneered by http://blog.rafaelferreira.net/2008/07/type-safe-builder-pattern-in-scala.html[Rafael Ferreira] in Scala, using ideas from Haskell. The code shown here is based on the implementation by http://dcsobral.blogspot.de/2009/09/type-safe-builder-pattern.html[Daniel Sobral].

=== Counting Builder

I have to admit that this is one of the more exotic builder variations, but I decided to include it because it is an interesting technique, and because this type of construction might be useful in other contexts.

Consider the following `Polygon` class, which could be part of a graphics library:

[source,kotlin]
----
import java.awt.geom.Point2D

data class Polygon(val points: List<Point2D>)
----

However, a problem arises when we want to ensure that polygons are constructed with at least three points. To solve this problem, we could create a builder that counts the number of points added and only allows the construction of polygons with three or more points.

While the obvious solution is to check the number of points at runtime, we can be more secure by preventing an invalid builder from being created at compile time. This can be achieved by using a recursive type parameter to keep track of the number of points, again using <<chapter-04_features.adoc#typeLevelProgramming, Type-Level Programming>>(((Type-Level Programming))). While this may seem odd at first, the implementation is quite simple:

[source,kotlin]
----
sealed interface Nat
interface Z : Nat
interface S<N : Nat> : Nat

class PolygonBuilder<N : Nat> private constructor() {

    companion object {
        operator fun invoke() =
            PolygonBuilder<Z>()
    }

    val points: MutableList<Point2D> =
        mutableListOf()

    @Suppress("UNCHECKED_CAST")
    fun add(point: Point2D) =
        (this as PolygonBuilder<S<N>>)
            .also { points += point }
}

fun <N : Nat> PolygonBuilder<S<S<S<N>>>>.build() = Polygon(points)
----

First, we create a sealed interface `Nat` to represent the natural numbers, and two sub-interfaces, `Z` representing zero and `S<N>` representing the successor of a natural number `N`. For example, the number 3 would be written as `S<S<S<Z>>>`. This is called the "Peano Representation" of the natural numbers. Note that even if we don't know the innermost part of `S<S<S<...>>>`, we can still deduce that the given number is greater than or equal to 3, which is exactly what we need to check our condition. These recursively constructed numbers are used by the builder class as a generic "counter" parameter, holding the number of items in the list.

.The Peano Axioms
****
When asked to count, the usual answer is "one, two, three...", not "zero, successor of zero, successor of successor of zero...", so you might wonder where the strange _Peano Representation_ comes from. In 1889 Giuseppe Peano published his famous nine axioms to define natural numbers and their properties in a formal way, and the Peano Representation follows directly from these axioms.

The first axiom states the existence of zero, the next four axioms cover basic properties of equality (it is reflexive, symmetric, transitive, and closed), but the next four axioms rely crucially on the use of the successor function:

* For every natural number, its successor is also a natural number.
* If the successors of two natural numbers are equal, then the numbers themselves are equal.
* Zero is not a successor of a natural number.
* Any natural number can be reached from zero by repeatedly applying the successor function (this is also known as "induction").

That's why, from a mathematical point of view, the Peano Representation is the most fundamental way to write natural numbers, and our usual number systems (decimal, binary, hexadecimal...) could be considered as convenient abbreviations.
****

Similar to the Typesafe Builder Pattern, the builder class must hide its constructor, because a call like `PolygonBuilder<S<S<Z>>>()` would initialize the builder with a wrong counter. That's why we simulate a constructor using the `invoke()` operator in the companion object, which only returns builders with a counter correctly initialized to 0. The `add()` method appends a point to the list, but also casts the instance to one with an incremented counter. This is safe because the counter is a phantom type(((Phantom Type))). Alternatively, we could have constructed a new Builder object on each `add()` call.

The last ingredient is the `build()` method, which must be an extension function for the same reasons as in the Typesafe Builder example. The function "counts" the points by checking the type signature of the builder. This is how our builder might be used:

[source,kotlin]
----
val polygon = PolygonBuilder()
    .add(Point2D.Double(1.0, 2.3))
    .add(Point2D.Double(2.1, 4.5))
    .add(Point2D.Double(2.4, 5.0))
    .build()
----

If one of the `add()` calls is removed, the code will no longer compile because the type of the `PolygonBuilder` no longer matches the signature of the `build()` extension function.

Of course, you can use this pattern to count more than one thing, and you can also combine it with the Typesafe Builder Pattern.

=== Builders with multiple stages

It is possible to build objects in stages. However, since there are several ways to implement this use case, and since these techniques are not only applicable to builders, <<chapter-08_transitions.adoc#state_transitions, Chapter 8>> covers this topic in detail.

=== Conclusion

The Builder Pattern is quite popular in Java - there are even libraries like https://projectlombok.org/[Project Lombok] that generate builders for you. The downside is that builders are quite inflexible and may not be very safe to use, although variations like the Typesafe Builder Pattern can help. In Kotlin, using named and default parameters can already provide functionality similar to a builder. The next chapter introduces another common approach in Kotlin that has some advantages over the classic Builder Pattern.

==== Preferable Use Cases

* Creating data
* Generating code
* Configuring systems
* Testing
* Logging

==== Rating

* image:4_sun.png[] - for Simplicity of DSL design
* image:2_sun.png[] - for Elegance
* image:3_sun.png[] - for Usability
* image:4_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* easy to understand
* applicable for a wide range of construction tasks
* variations of the pattern can fix some of its shortcomings
* can be autogenerated (e.g. using https://projectlombok.org[Project Lombok])
* easy to use from Java client code

|* often not the most natural syntax for the problem
* nested builders don't look nice
* inflexible structure
* boilerplate code (e.g. need for a `build()` method)
* assignments are disguised as method calls
|===
