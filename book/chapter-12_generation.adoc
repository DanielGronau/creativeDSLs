== Code Generation for DSLs (((Code Generation)))

> Do not cite the Deep Magic to me, witch! I was there when it was written.
-- C. S. Lewis, The Lion, the Witch and the Wardrobe

Sometimes you are prototyping a DSL, and you find a nice syntax, but it turns out that it would take a lot of boilerplate code to make it work. A common reason is combinatorial explosion, or you need many classes that follow the same pattern (e.g., tuple classes or fixed-length vectors). In such cases, you might consider using code generation.

A popular library for generating Kotlin code is https://square.github.io/kotlinpoet[KotlinPoet]. If you are also working with Java, you may also want to check out its sister project https://github.com/square/javapoet[JavaPoet]. There is even some interoperability between them.

=== Case Study: Physical Quantities

Let's say you've already defined quantities for physical units such as seconds, square meters, or Watts:

[source,kotlin]
----
sealed interface Quantity {
    val amount: Double
}

// base units
data class Second(override val amount: Double) : Quantity
data class Meter(override val amount: Double) : Quantity
data class Kilogram(override val amount: Double) : Quantity

// derived units
data class SquareMeter(override val amount: Double) : Quantity
data class CubicMeter(override val amount: Double) : Quantity
data class MeterPerSecond(override val amount: Double) : Quantity
data class MeterPerSecondSquared(override val amount: Double) : Quantity
data class Newton(override val amount: Double) : Quantity
data class Joule(override val amount: Double) : Quantity
data class Watt(override val amount: Double) : Quantity
data class Pascal(override val amount: Double) : Quantity
----

WARNING: You should always consider whether the precision provided by `Double` is sufficient for the kind of calculations required by your application, and switch to e.g. `BigDecimal` if not.

At this point, we can't even add two quantities together. It would be nice if we could write this function only once in `Quantity`, but of course only quantities of the same unit can be added. There are techniques to make this safe, but they would require the use of generics in Kotlin.

Instead, we will use https://square.github.io/kotlinpoet[KotlinPoet]. You will need to add a dependency to your project, e.g:

[source,kotlin]
.Gradle (.kts)
----
implementation("com.squareup:kotlinpoet:1.15.1")
----

First, we will generate some extension functions for the missing addition:

[source,kotlin]
----
fun makeAddition(kClass: KClass<out Quantity>) =
    FunSpec.builder("plus")
        .addModifiers(KModifier.OPERATOR)
        .receiver(kClass)
        .addParameter("that", kClass)
        .addStatement("return copy(amount = this.amount + that.amount)")
        .build()

fun makeAdditions() =
    Quantity::class.sealedSubclasses.map { makeAddition(it) }
----

As you can see, KotlinPoet relies heavily on the builder pattern. In the `makeAdditions()` method, we take advantage of the fact that a sealed class - here `Quantity` - knows about its subclasses. As a result, we get a list of `FunSpec` instances representing functions, constructors, getters or setters. You can just print the contents to the console to see what the code would look like. Later we will add these instances to a `FileSpec' that can be written to the file system. The generated functions will look like this:

[source,kotlin]
----
public operator fun Second.plus(that: Second) =
   copy(amount = this.amount + that.amount)
----

The next operations follow pretty much the same pattern. They define subtraction, negation, and scalar multiplication:

[source,kotlin]
----
fun makeSubtraction(kClass: KClass<out Quantity>) =
    FunSpec.builder("minus")
        .addModifiers(KModifier.OPERATOR)
        .receiver(kClass)
        .addParameter("that", kClass)
        .addStatement("return copy(amount = this.amount - that.amount)")
        .build()

fun makeNegation(kClass: KClass<out Quantity>) =
    FunSpec.builder("unaryMinus")
        .addModifiers(KModifier.OPERATOR)
        .receiver(kClass)
        .addStatement("return copy(amount = -this.amount)")
        .build()

fun makeScalarMultiplication(kClass: KClass<out Quantity>) =
    FunSpec.builder("times")
        .addModifiers(KModifier.OPERATOR)
        .receiver(Double::class)
        .addParameter("that", kClass)
        .addStatement("return that.copy(amount = this * that.amount)")
        .build()

fun makeSubtractions() =
    Quantity::class.sealedSubclasses.map { makeSubtraction(it) }

fun makeNegations() =
    Quantity::class.sealedSubclasses.map { makeNegation(it) }

fun makeScalarMultiplications() =
    Quantity::class.sealedSubclasses.map { makeScalarMultiplication(it) }
----

The next part is more interesting: We need conversions from and back to `Double`. Note that we can define these conversions for more units than we have classes defined for, e.g. we can define not only `5.0.s` to get `Second(5.0)`, but also `1.0.min` to get `Seconds(60.0)`. And vice versa, we want to be able to get not only seconds from a `Second` instance, but also minutes and so on. It is obvious that we need additional information to write the conversions for a certain unit: We need its name, the quantity subclass, and a factor to apply.

[source,kotlin]
----
private val fromToDouble = listOf(
    Triple("s", Second::class, 1.0),
    Triple("min", Second::class, 60.0),
    Triple("h", Second::class, 3600.0),
    Triple("yr", Second::class, 31_556_925.216),

    Triple("mm", Meter::class, 0.001),
    Triple("cm", Meter::class, 0.01),
    Triple("in", Meter::class, 0.0254),
    Triple("ft", Meter::class, 0.3048),
    Triple("yd", Meter::class, 0.9144),
    Triple("m", Meter::class, 1.0),
    Triple("km", Meter::class, 1000.0),
    Triple("mi", Meter::class, 1609.344),

    // etc.
)
----

To make the DSL a bit more readable, we will generate extension properties instead of extension functions, so we don't have to use brackets. The generating functions look like this:

[source,kotlin]
----
fun makeDoubleToQuantity(unit: String, kClass: KClass<out Quantity>, factor: Double) =
    PropertySpec.builder(unit, kClass)
        .receiver(Double::class)
        .getter(
            FunSpec.getterBuilder()
                .addStatement("return %T(this * %L)", kClass, factor)
                .build()
        )
        .build()

fun makeQuantityToDouble(unit: String, kClass: KClass<out Quantity>, factor: Double) =
    PropertySpec.builder(unit, Double::class)
        .receiver(kClass)
        .getter(
            FunSpec.getterBuilder()
                .addStatement("return this.amount / %L", factor)
                .build()
        )
        .build()

fun makeDoubleToQuantities() =
    fromToDouble.map { (u, k, f) -> makeDoubleToQuantity(u, k, f) }

fun makeQuantityToDoubles() =
    fromToDouble.map { (u, k, f) -> makeQuantityToDouble(u, k, f) }

----

In case you were wondering about the `(u, k, f)` part: This is the destructuring syntax, which works e.g. for `Pair`, `Triple` and data classes. Here is an example of a generated pair of transformations:

[source,kotlin]
----
public val Double.kJ: Joule
  get() = Joule(this * 1000.0)

public val Joule.kJ: Double
  get() = this.amount / 1000.0
----

So far, we can generate a lot of boilerplate code, but for the next task - multiplying and dividing quantities - it would be extremely tedious to write the necessary code by hand, even for our modest example. If we have N physical units, the number of possible multiplications and divisions is of the order of NÂ² (we won't implement all possible combinations, but it's still a lot). When we have such polynomial or even exponential growth, we are dealing with a combinatorial explosion.

To tackle this problem, we first need all valid multiplication equations. This could look like this, where the first two values of a triple are the types of the factors, and the third is the type of the product:

[source,kotlin]
----
val multiply = listOf(
    Triple(Meter::class, Meter::class, SquareMeter::class),
    Triple(Meter::class, SquareMeter::class, CubicMeter::class),
    Triple(MeterPerSecond::class, Second::class, Meter::class),
    Triple(MeterPerSecondSquared::class, Second::class, MeterPerSecond::class),
    Triple(MeterPerSecondSquared::class, Kilogram::class, Newton::class),
    Triple(Pascal::class, SquareMeter::class, Newton::class),
    Triple(Newton::class, Meter::class, Joule::class),
    Triple(Watt::class, Second::class, Joule::class),

    // etc.
)
----

Now we evaluate these equations for both multiplication and division. A slight complication is that we also want to add functions with swapped operands, but only if they are of different types:

[source,kotlin]
----
fun makeMultiplication(
    in1: KClass<out Quantity>,
    in2: KClass<out Quantity>,
    out: KClass<out Quantity>) = FunSpec
        .builder("times")
        .addModifiers(KModifier.OPERATOR)
        .receiver(in1)
        .addParameter("that", in2)
        .addStatement("return %T(this.amount * that.amount)", out)
        .build()

fun makeDivision(
    in1: KClass<out Quantity>,
    in2: KClass<out Quantity>,
    out: KClass<out Quantity>) = FunSpec
        .builder("div")
        .addModifiers(KModifier.OPERATOR)
        .receiver(in1)
        .addParameter("that", in2)
        .addStatement("return %T(this.amount / that.amount)", out)
        .build()

fun makeMultiplications() =
    multiply.flatMap { (in1, in2, out) ->
        when {
            in1 == in2 -> listOf(makeMultiplication(in1, in2, out))
            else -> listOf(
                makeMultiplication(in1, in2, out),
                makeMultiplication(in2, in1, out))
        }
    }

fun makeDivisions() =
    multiply.flatMap { (in1, in2, out) ->
        when {
            in1 == in2 -> listOf(makeDivision(out, in1, in2))
            else -> listOf(
                makeDivision(out, in1, in2),
                makeDivision(out, in2, in1))
        }
    }
----

This is the result of the function generation process:

[source,kotlin]
----
public operator fun Newton.times(that: Meter) =
    Joule(this.amount * that.amount)

public operator fun Meter.times(that: Newton) =
    Joule(this.amount * that.amount)

public operator fun Joule.div(that: Meter) =
    Newton(this.amount / that.amount)

public operator fun Joule.div(that: Newton) =
    Meter(this.amount / that.amount)

// etc.
----

To finish the DSL, we need to write the generated code to a file. For simplicity, we will write it right next to the generating file, but it is common to have separate directories for generated code. For convenience, I have added two extension functions to `FileSpec` that allow you to add multiple properties or functions at once:

[source,kotlin]
----
fun main() {
    FileSpec.builder("creativeDSLs.chapter_11", "generated")
        .addProperties(makeQuantityToAmounts())
        .addProperties(makeAmountToQuantities())
        .addFunctions(makeAdditions())
        .addFunctions(makeSubtractions())
        .addFunctions(makeNegations())
        .addFunctions(makeScalarMultiplications())
        .addFunctions(makeMultiplications())
        .addFunctions(makeDivisions())
        .build()
        .writeTo(Path.of("./src/main/kotlin/"))
}

fun FileSpec.Builder.addProperties(properties: List<PropertySpec>) =
    this.also { properties.forEach { this.addProperty(it) } }

fun FileSpec.Builder.addFunctions(functions: List<FunSpec>) =
    this.also { functions.forEach { this.addFunction(it) } }
----

As you can see, working with KotlinPoet is pretty straightforward. You use the various spec classes to assemble your code, and the `FileSpec' and `ClassSpec' classes allow you to write the file or class to the file system. Behind the scenes, KotlinPoet does a lot of work for you, such as managing imports or simplifying your code (e.g., converting function bodies with braces to expression syntax where possible).

With our generated DSL in place, we can now calculate physical quantities in a safe and convenient way, e.g:

[source,kotlin]
----
val acceleration = 30.0.m_s / 1.0.s
val force = acceleration * 64.0.kg
val energy = force * 5.0.m
println("${energy.kJ} kiloJoule")
----

The example code is written in such a way that you manually generate the code via the `main()` method when the DSL has changed. This is a simple approach if you know that code changes won't happen very often, but it can quickly become cumbersome if changes become more frequent. In the next section, we will discuss using an annotation processor instead.

=== Writing an annotation processor using KSP (((Annotation Processor))) (((KSP))) (((Kotlin Symbol Processing API)))

There are two APIs for annotation processors in Kotlin. The older one is called `kapt`, which is no longer actively developed, but is still used for many projects. The more modern API is `KSP`, which stands for https://kotlinlang.org/docs/ksp-overview.html[Kotlin Symbol Processing].

Before deciding to write an annotation processor, it's important to understand how it works and what its limitations are. You will need at least two modules: One module containing annotations, related interfaces, etc. that you can use in your client code to specify your requirements to the annotation processor, and one module containing the annotation processor itself that is integrated into the build process to do things like code generation, reporting, or to provide tooling support. Often, a third module is added for testing purposes, because not only do you want to have unit tests for the processor classes, but you also need to verify that the processor works as intended when building client code.

[ditaa,"generating-a-dsl"]
.Annotation processor using KSP
....

  /-------------\           /-----------\            /--------------\
  | Annotations |<----------+ Processor +----------->|   DSL Code   |
  \-----+-------/ looks for \-----+-----/ generates  \--------------/
        ^                         |                          ^
        |uses                     |inspects                  |uses
        |                         v                          |
 /------+----------------------------------------------------+-------\
 |                       Client Application                          |
 \-------------------------------------------------------------------/

....


WARNING: At the time you call KSP, the client code is not yet built, which means **you can't use regular reflection** for client classes. The KSP API gives you syntactic information about the code, but working with this API isn't as convenient as using reflection.

The lack of reflection support means that KSP may not be the right tool if you need to rely heavily on code inspection, and that you should think about making the process of gathering information as easy as possible for the processor, e.g. by using annotations.

==== Case Study: Designing the DSL and writing the annotations module

What would an annotation-based DSL for defining the relationship between physical quantities look like? One possible solution is to annotate the `Quantity` interface with all the necessary information we had in the `fromToDouble` and `multiply` lists before:

[source,kotlin]
----
@Conversion("s", Second::class, 1.0)
@Conversion("min", Second::class, 60.0)
@Conversion("h", Second::class, 3600.0)
...
@Multiply(Meter::class, Meter::class, SquareMeter::class)
@Multiply(Meter::class, SquareMeter::class, CubicMeter::class)
@Multiply(MeterPerSecond::class, Second::class, Meter::class)
...
sealed interface Quantity {
    val amount: Double
}
----

So we need two annotations in the annotation module so that the client application can use them and the processor can react to them:

[source,kotlin]
----
import kotlin.reflect.KClass

@Repeatable
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class Conversion(
    val derivedUnit: String,
    val baseUnit: KClass<*>,
    val factor: Double
)

@Repeatable
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class Multiply(
    val factor1: KClass<*>,
    val factor2: KClass<*>,
    val result: KClass<*>
)
----

[#annotationProcessor]
==== Case Study: Writing the Annotation Processor

This book can only give a very high-level overview of KSP. Please consult the https://kotlinlang.org/docs/ksp-quickstart.html[KSP Documentation] for a more detailed discussion.

KSP uses Java's https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html[Service Provider Interface] mechanism to discover new processors. That's why we need to write a provider first:

[source,kotlin]
----
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider

class PhysicalQuantitiesProcessorProvider : SymbolProcessorProvider {

    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
        PhysicalQuantitesProcessor(
            codeGenerator = environment.codeGenerator,
            logger = environment.logger,
            options = environment.options
        )
}
----

This provider must be registered in a text file called `SymbolProcessorProvider' located in `resources/META-INF/services'. In this file you simply add the qualified name of the provider class.

Now we have to write the processor. The basic structure is as follows:

[source,kotlin]
----
class PhysicalQuantitiesMapperProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val options: Map<String, String>
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        ...
    }
}
----

We can ask the resolver to provide the annotated elements:

[source,kotlin]
----
val conversions = resolver
    .getSymbolsWithAnnotation("creativeDsl.chapter12.ksp.annotations.Conversion")
    .filterIsInstance<KSClassDeclaration>()
val multiplications = resolver
    .getSymbolsWithAnnotation("creativeDsl.chapter12.ksp.annotations.Multiply")
    .filterIsInstance<KSClassDeclaration>()
----

//TODO

=== Case Study: Generating Data Class Patterns ===

=== Conclusion

The decision to use code generation requires careful consideration because of the effort required. However, this technique allows you to implement DSLs that would just be too much overhead without it. And with libraries like https://square.github.io/kotlinpoet[KotlinPoet], it is quite intuitive to generate the code you want. Kotlin-Poet is itself a nice example of a real-world DSL, and will be explored as such in the final chapter.

Using code generation in conjunction with annotation processors like KSP can produce flexible, powerful, and well-integrated DSLs that wouldn't otherwise be possible.

==== Preferable Use Cases

* Creating data
* Transforming data
* Define operations
* Testing

==== Rating

* image:2_sun.png[] - for Simplicity of DSL design
* image:5_sun.png[] - for Elegance
* image:4_sun.png[] - for Usability
* image:5_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* automatize writing of boilerplate code
* very flexible and adaptable
* intuitive libraries like https://square.github.io/kotlinpoet[Kotlin-Poet] are available
* if the generator function is correct, so are all the outputs, e.g. no typos or copy-paste errors

|* requires some up-front effort and setup
* strong dependency on the used library
* longer build times when generation is done for every build
* code can get out of sync when generation is done only on request
|===


