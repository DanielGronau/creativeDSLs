== Code Generation for DSLs (((Code Generation)))

Sometimes you are prototyping a DSL and find a nice syntax, but it turns out it would need a lot of boilerplate code to make it work. One common reason is a combinatorial explosion, or there are many classes needed which follow the same pattern (e.g. tuple classes, or fixed length vectors). In such cases, you might consider using code generation.

A popular library for generating Kotlin code is https://square.github.io/kotlinpoet[KotlinPoet]. If you work with Java, too, you might also check out its sister project https://github.com/square/javapoet[JavaPoet]. There is even some interoperability between the libraries.

=== Case Study: Physical Quantities

Let's assume you have already defined quantities for physical units, like seconds, square meters, or Watt:

[source,kotlin]
----
sealed interface Quantity {
    val amount: Double
}

// base units
data class Second(override val amount: Double) : Quantity
data class Meter(override val amount: Double) : Quantity
data class Kilogram(override val amount: Double) : Quantity

// derived units
data class SquareMeter(override val amount: Double) : Quantity
data class CubicMeter(override val amount: Double) : Quantity
data class MeterPerSecond(override val amount: Double) : Quantity
data class MeterPerSecondSquared(override val amount: Double) : Quantity
data class Newton(override val amount: Double) : Quantity
data class Joule(override val amount: Double) : Quantity
data class Watt(override val amount: Double) : Quantity
data class Pascal(override val amount: Double) : Quantity
----

WARNING: You should always consider whether the precision provided by `Double` is sufficient for the kind of calculations required by your application, and switch e.g. to `BigDecimal` if not.

At this point, we can't even add two quantities together. It would be nice if we could write this function only once in `Quantity`, but of course only quantities of the same unit are allowed to be added. There are techniques to make this safe, but would require the use of generics in Kotlin.

Instead, we will use https://square.github.io/kotlinpoet[KotlinPoet]. You need to add a dependency to your project, e.g.:

[source,kotlin]
.Gradle (.kts)
----
implementation("com.squareup:kotlinpoet:1.12.0")
----

First, we will generate some extension functions for the missing addition:

[source,kotlin]
----
fun makeAddition(kClass: KClass<out Quantity>) =
    FunSpec.builder("plus")
        .addModifiers(KModifier.OPERATOR)
        .receiver(kClass)
        .addParameter("that", kClass)
        .addStatement("return copy(amount = this.amount + that.amount)")
        .build()

fun makeAdditions() =
    Quantity::class.sealedSubclasses.map { makeAddition(it) }
----

As you can see, KotlinPoet relies heavily on the Builder Pattern. In the `makeAdditions()` method, we use the fact that a sealed class - here `Quantity` - "knows" about its subclasses. As a result, we get a list of `FunSpec` instances, which represent functions, constructors, getters or setters. You can simply print the content in the console to see what the code would look like. Later we will add these instances to a `FileSpec`, which can be written to the file system. The generated functions will look like this:

[source,kotlin]
----
public operator fun Second.plus(that: Second) =
   copy(amount = this.amount + that.amount)
----

The next operations follow pretty much the same pattern. They define subtraction, negation and scalar multiplication:

[source,kotlin]
----
fun makeSubtraction(kClass: KClass<out Quantity>) =
    FunSpec.builder("minus")
        .addModifiers(KModifier.OPERATOR)
        .receiver(kClass)
        .addParameter("that", kClass)
        .addStatement("return copy(amount = this.amount - that.amount)")
        .build()

fun makeNegation(kClass: KClass<out Quantity>) =
    FunSpec.builder("unaryMinus")
        .addModifiers(KModifier.OPERATOR)
        .receiver(kClass)
        .addStatement("return copy(amount = -this.amount)")
        .build()

fun makeScalarMultiplication(kClass: KClass<out Quantity>) =
    FunSpec.builder("times")
        .addModifiers(KModifier.OPERATOR)
        .receiver(Double::class)
        .addParameter("that", kClass)
        .addStatement("return that.copy(amount = this * that.amount)")
        .build()

fun makeSubtractions() =
    Quantity::class.sealedSubclasses.map { makeSubtraction(it) }

fun makeNegations() =
    Quantity::class.sealedSubclasses.map { makeNegation(it) }

fun makeScalarMultiplications() =
    Quantity::class.sealedSubclasses.map { makeScalarMultiplication(it) }
----

The following part is more interesting: We need conversions from and back to `Double`. Note that we can define these conversions for more units than we have classes defined for, e.g. we can not only define `5.0.s` to give us `Second(5.0)`, but also `1.0.min` to give us `Seconds(60.0)`. And conversely, we want to be able to get from a `Second` instance not only the seconds, but also minutes etc. It is obvious that we need additional information to write the conversions for a certain unit: We need its name, the quantity class, and a factor to apply.

[source,kotlin]
----
private val fromToDouble = listOf(
    Triple("s", Second::class, 1.0),
    Triple("min", Second::class, 60.0),
    Triple("h", Second::class, 3600.0),
    Triple("yr", Second::class, 31_556_925.216),

    Triple("mm", Meter::class, 0.001),
    Triple("cm", Meter::class, 0.01),
    Triple("in", Meter::class, 0.0254),
    Triple("ft", Meter::class, 0.3048),
    Triple("yd", Meter::class, 0.9144),
    Triple("m", Meter::class, 1.0),
    Triple("km", Meter::class, 1000.0),
    Triple("mi", Meter::class, 1609.344),

    // etc.
)
----

In order to make the DSL slightly more readable, we will generate extension properties instead of extension functions, so we don't have parenthesis. The generating functions look like this:

[source,kotlin]
----
fun makeDoubleToQuantity(unit: String, kClass: KClass<out Quantity>, factor: Double) =
    PropertySpec.builder(unit, kClass)
        .receiver(Double::class)
        .getter(
            FunSpec.getterBuilder()
                .addStatement("return %T(this * %L)", kClass, factor)
                .build()
        )
        .build()

fun makeQuantityToDouble(unit: String, kClass: KClass<out Quantity>, factor: Double) =
    PropertySpec.builder(unit, Double::class)
        .receiver(kClass)
        .getter(
            FunSpec.getterBuilder()
                .addStatement("return this.amount / %L", factor)
                .build()
        )
        .build()

fun makeDoubleToQuantities() =
    fromToDouble.map { (u, k, f) -> makeDoubleToQuantity(u, k, f) }

fun makeQuantityToDoubles() =
    fromToDouble.map { (u, k, f) -> makeQuantityToDouble(u, k, f) }

----

In case you are wondering about the `(u, k, f)` part: This is the destructuring syntax, which works e.g. for `Pair`, `Triple` and data classes. Here is an example for a generated pair of conversions:

[source,kotlin]
----
public val Double.kJ: Joule
  get() = Joule(this * 1000.0)

public val Joule.kJ: Double
  get() = this.amount / 1000.0
----

So far, we can already generate a lot of boilerplate code, but for the next task - the multiplication and division of quantities - it would be extremely tedious to write the necessary code manually, even for our modest example. When we have N physical units, the number of possible multiplications and divisions is of order NÂ² (we won't implement all possible combinations, but it is still a lot). When we have such polynomial or even exponential growth, we are dealing with a combinatorial explosion.

To tackle this problem, we first need all valid multiplication equations. This could look like this, where the first two values of a triple are the types of the factors, and the third is the product type:

[source,kotlin]
----
val multiply = listOf(
    Triple(Meter::class, Meter::class, SquareMeter::class),
    Triple(Meter::class, SquareMeter::class, CubicMeter::class),
    Triple(MeterPerSecond::class, Second::class, Meter::class),
    Triple(MeterPerSecondSquared::class, Second::class, MeterPerSecond::class),
    Triple(MeterPerSecondSquared::class, Kilogram::class, Newton::class),
    Triple(Pascal::class, SquareMeter::class, Newton::class),
    Triple(Newton::class, Meter::class, Joule::class),
    Triple(Watt::class, Second::class, Joule::class)
)
----

Now we evaluate these equations both for multiplications and divisions. A slight complication is that we also want to add functions with the operands switched, but only if they have different types:

[source,kotlin]
----
fun makeMultiplication(
    in1: KClass<out Quantity>,
    in2: KClass<out Quantity>,
    out: KClass<out Quantity>) = FunSpec
        .builder("times")
        .addModifiers(KModifier.OPERATOR)
        .receiver(in1)
        .addParameter("that", in2)
        .addStatement("return %T(this.amount * that.amount)", out)
        .build()

fun makeDivision(
    in1: KClass<out Quantity>,
    in2: KClass<out Quantity>,
    out: KClass<out Quantity>) = FunSpec
        .builder("div")
        .addModifiers(KModifier.OPERATOR)
        .receiver(in1)
        .addParameter("that", in2)
        .addStatement("return %T(this.amount / that.amount)", out)
        .build()

fun makeMultiplications() =
    multiply.flatMap { (in1, in2, out) ->
        when {
            in1 == in2 -> listOf(makeMultiplication(in1, in2, out))
            else -> listOf(
                makeMultiplication(in1, in2, out),
                makeMultiplication(in2, in1, out))
        }
    }

fun makeDivisions() =
    multiply.flatMap { (in1, in2, out) ->
        when {
            in1 == in2 -> listOf(makeDivision(out, in1, in2))
            else -> listOf(
                makeDivision(out, in1, in2),
                makeDivision(out, in2, in1))
        }
    }
----

This is how the generated functions look like:

[source,kotlin]
----
public operator fun Newton.times(that: Meter) =
    Joule(this.amount * that.amount)

public operator fun Meter.times(that: Newton) =
    Joule(this.amount * that.amount)

public operator fun Joule.div(that: Meter) =
    Newton(this.amount / that.amount)

public operator fun Joule.div(that: Newton) =
    Meter(this.amount / that.amount)
----

In order to finish the DSL, we need to write the generated code in a file. For simplicity, will write it directly next to the generating file, but it is common to have separate directories for generated code. For convenience, I added two extension functions for `FileSpec`, which allow to add multiple properties or functions at once:

[source,kotlin]
----
fun main() {
    FileSpec.builder("creativeDSLs.chapter_11", "generated")
        .addProperties(makeQuantityToAmounts())
        .addProperties(makeAmountToQuantities())
        .addFunctions(makeAdditions())
        .addFunctions(makeSubtractions())
        .addFunctions(makeNegations())
        .addFunctions(makeScalarMultiplications())
        .addFunctions(makeMultiplications())
        .addFunctions(makeDivisions())
        .build()
        .writeTo(Path.of("./src/main/kotlin/"))
}

fun FileSpec.Builder.addProperties(properties: List<PropertySpec>) =
    this.also { properties.forEach { this.addProperty(it) } }

fun FileSpec.Builder.addFunctions(functions: List<FunSpec>) =
    this.also { functions.forEach { this.addFunction(it) } }
----

As you can see, working with KotlinPoet is quite straightforward. You use the different spec classes to assemble your code, and the `FileSpec` and `ClassSpec` classes allow you to write the file or class to the filesystem. Behind the scenes, KotlinPoet does a lot of work for you, e.g. managing imports or simplifying your code (e.g. turning function bodies with curly braces into expression syntax if possible).

With our generated DSL in place, we can now calculate physical quantities in a safe and convenient way, e.g.:

[source,kotlin]
----
val acceleration = 30.0.m_s / 1.0.s
val force = acceleration * 64.0.kg
val energy = force * 5.0.m
println("${energy.kJ} kiloJoule")
----

The example code is written in a way where you generate the code manually via the `main()` method when the DSL has changed. This is a simple approach when you know that code changes don't happen very often, but it can become cumbersome quickly when changes become more frequent. In the next section, we will discuss the use of an annotation processor instead.

=== Writing an annotation processor using KSP

There are two APIs for Kotlin annotation processors. The older one is called `kapt`, which is no longer actively developed, but is still used for many projects. The more modern API is `KSP`, which stands for https://kotlinlang.org/docs/ksp-overview.html[Kotlin Symbol Processing].

Before deciding to write an annotation processor, it is important to understand how it works and what it's limitations are. You need at least two modules: One module containing annotations, related interfaces etc you can use in your client code to invoke the annotation processor, and one module containing the annotation processor itself, which will be integrated in the build process to do things like code generation, reporting or tom provide tooling support. Often, a third module is added for testing purposes, as you not only want to have unit tests for the processor classes, but you also need to check whether the processor works as intended when building client code.

[ditaa,"generating-a-dsl"]
.Annotation processor using KSP
....

  /-------------\           /-----------\            /--------------\
  | Annotations |<----------+ Processor +----------->|   DSL Code   |
  \-----+-------/ looks for \-----+-----/ generates  \--------------/
        ^                         |                          ^
        |uses                     |inspects                  |uses
        |                         v                          |
 /------+----------------------------------------------------+-------\
 |                       Client Application                          |
 \-------------------------------------------------------------------/

....


WARNING: At the time KSP is invoked, the client code is not yet built, which means **you can't use regular reflection** for client classes. The KSP API provides you with syntactical information about the code, but working with this API isn't as convenient as using reflection.

The missing reflection support means that KSP might be not the right tool if you need to rely heavily on code inspection, and that you should think about making the process of information gathering as easy as possible for the processor, e.g. by using annotations.

==== Case Study: Designing the DSL and writing the annotations module

How could an annotation based DSL for defining the relation between physical quantities look like? Now, we could annotate the `Quantity` interface with all the necessary information we had in the `fromToDouble` and `multiply` lists before:

[source,kotlin]
----
@Conversion("s", Second::class, 1.0)
@Conversion("min", Second::class, 60.0)
@Conversion("h", Second::class, 3600.0)
...
@Multiply(Meter::class, Meter::class, SquareMeter::class)
@Multiply(Meter::class, SquareMeter::class, CubicMeter::class)
@Multiply(MeterPerSecond::class, Second::class, Meter::class)
...
sealed interface Quantity {
    val amount: Double
}
----

So we need two annotations in the annotation module, so that the client application can ust them, and the processor can react to them:

[source,kotlin]
----
import kotlin.reflect.KClass

@Repeatable
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class Conversion(
    val derivedUnit: String,
    val baseUnit: KClass<*>,
    val factor: Double
)

@Repeatable
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class Multiply(
    val factor1: KClass<*>,
    val factor2: KClass<*>,
    val result: KClass<*>
)
----

[#annotationProcessor]
==== Case Study: Writing the Annotation Processor

This book can give just a very high-level overview of KSP. Please consult the https://kotlinlang.org/docs/ksp-quickstart.html[KSP Documentation] for a more comprehensive discussion.

KSP uses Java's https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html[Service Provider Interface] mechanism to discover new processors. That's why we need to write a provider first:

[source,kotlin]
----
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider

class PhysicalQuantitiesProcessorProvider : SymbolProcessorProvider {

    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
        PhysicalQuantitesProcessor(
            codeGenerator = environment.codeGenerator,
            logger = environment.logger,
            options = environment.options
        )
}
----

This provider must be registered in a text file called `SymbolProcessorProvider` located in `resources/META-INF/services`. In this file, you simply add the qualified name of the provider class.

Now we need to write the processor. The basic structure looks like this:

[source,kotlin]
----
class PhysicalQuantitiesMapperProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val options: Map<String, String>
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        ...
    }
}
----

To get the annotated elements, we can ask the resolver to provide them:

[source,kotlin]
----
val conversions = resolver
    .getSymbolsWithAnnotation("creativeDsl.chapter12.ksp.annotations.Conversion")
    .filterIsInstance<KSClassDeclaration>()
val multiplications = resolver
    .getSymbolsWithAnnotation("creativeDsl.chapter12.ksp.annotations.Multiply")
    .filterIsInstance<KSClassDeclaration>()
----

//TODO

=== Case Study: Generating Data Class Patterns ===

=== Conclusion

Using code generation means bringing out the big guns, it certainly requires some planning and setup. However, this technique allows you to implement DSLs that would be just too much overhead without. And with libraries like https://square.github.io/kotlinpoet[KotlinPoet], it is quite intuitive to generate the code you want. Kotlin-Poet is itself a nice example for a real-world DSL, and will be explored as such in the next chapter.

Using code generation in conjunction with annotation processors like KSP can produce flexible, powerful and well-integrated DSLs that wouldn't be possible otherwise.

==== Preferable Use Cases

* Creating data
* Transforming data
* Define operations
* Testing

==== Rating

* image:2_sun.png[] - for Simplicity of DSL design
* image:5_sun.png[] - for Elegance
* image:4_sun.png[] - for Usability
* image:5_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* automatize writing of boilerplate code
* very flexible and adaptable
* intuitive libraries like https://square.github.io/kotlinpoet[Kotlin-Poet] are available
* if the generator function is correct, so are all the outputs, e.g. no typos or copy-paste errors

|* requires some up-front effort and setup
* strong dependency on the used library
* longer build times when generation is done for every build
* code can get out of sync when generation is done only on request
|===


