[preface]

== Preface

=== Why another book about DSLs in Kotlin?

Kotlin is very suitable to write DSLs and accordingly there exists already literature about this topic. However, in my opinion many existing books fall short in some ways:

* They focus too much on "toy examples" that give little insight in the process of writing DSLs in practice
* They present solutions in a "vacuum", without highlighting how an effective  design process looks like, which requirements, constraints and limitations apply, and which trade-offs were made
* They don't attempt a categorization of, and comparison between the different DSL types

This book tries to address these shortcomings. It contains a checklist of requirements, which includes less obvious, but nevertheless important aspects of the requirement analysis. It shows, how designing DSLs can be structured. Further, the presented DSLs progress from "boring" default examples to more and more challenging and unwieldy cases, and concludes with a discussion of some complex and successful real-world DSLs.

Another goal of this book is to avoid presenting isolated examples, but to attempt a classification of DLS. The design patterns movement established a common language for battle-tested coding solutions. In the same way, there should exist a widely accepted terminology for classifying DSLs, and this book wants to contribute to this effort.

=== Who Shouldn't Read this Book (yet)?

Writing DSLs can be challenging, usually it isn't a good introduction to a host language. That's why this book assumes that you are already familiar with Kotlin, and - to a lesser degree - with Java. The book contains actually a chapter describing language features of Kotlin, but it is focussing on their possible use in DSLs - so this won't be enough to learn the language.

So, if you don't feel comfortable in Kotlin yet, take your time and explore the language first, it will save you from a lot of confusion. This book won't go anywhere in the meantime, it can wait until you can get the most out of it.

=== About this Book

I was always interested in the weird nooks and crannies in the languages I used. I tried to push the boundaries of Java, and later of Scala and Kotlin. When changing my job to a 100% Kotlin position, I decided to brush up my Kotlin, and as I had some time on my hand between the gigs, this project started almost by itself, and grew faster than I would have imagined it.

I'm a quite open person, and I always try to get feedback and constructive criticism. That's why as soon as the content was more or less there, I presented the book to various friends and programming forums, and I'm very thankful for all the support I got. As a self-publisher, I am the only person responsible for the quality of the book, and I can't believe how much it has improved through sharing it.

One thing I'm quite surprised about is how serious my technical writing style turned out tp be: No jokes, no personal stories, no funny quips. Reading the book, you could get the impression I have no life at all - which is true - and no humor at all, which couldn't be farther from the truth. I think I unconsciously used a serious style because I take the topic serious, and because I also think the content can speak for itself, that it can spark curiosity and interest without any sugarcoating.

=== Prerequisites

To try out code samples from this book or the associated project https://github.com/creativeDsls[], you can use any IDE capable of running Kotlin (obviously IntelliJ IDEA will have an edge regarding Kotlin support), or you can go to https://play.kotlinlang.org/[] for an online sandbox. The Kotlin language version used is 1.7. If not stated otherwise, when discussing Java, language level 11 is assumed.

=== Typographical Conventions

This book uses a few typographical conventions to structure its content.

Inlined code snippets are shown like this: `val answer = 42`

Tips, warnings etc. are shown as follows:

TIP: When the white frost comes, do not eat the yellow snow.

WARNING: Beware the Jabberwock, my son! The jaws that bite, the claws that catch!
Beware the Jubjub bird, and shun the frumious Bandersnatch!

Example code is shown like this, and may include the file name or lines with numbered remarks:

[source,kotlin]
.src/main/kotlin/personDemo/Person.kt
----
import java.time.ZonedDateTime
import java.time.temporal.ChronoUnit.YEARS

data class Person(val firstName: String, val lastName: String, val age: Int) {<1>
   constructor(firstName: String, lastName: String, dateOfBirth: ZonedDateTime):<2>
       this(firstName, lastName, YEARS.between(dateOfBirth, ZonedDateTime.now()).toInt())
}
----
<1> This is the *main constructor*. For data classes, it also describes the structure of the object and its `toString()` representation.
<2> *Secondary constructors* allow to initialize the object in other ways, however they must delegate to the main constructor.

Definitions or additional information may be presented as follows:

.The name "Kotlin"
****
"Kotlin" is a small Russian island in the Baltic Sea. Naming languages or projects after islands has been a tradition in the Java ecosystem. Beside Java itself, there exists e.g. project Lombok, and the Ceylon language.
****

Quotes look like this:

"Code is like humor. When you have to explain it, itâ€™s bad."
-- Cory House

=== Feedback

I'm always thankful for feedback from my readers. Constructive criticism helps to improve this book. As every book, it contains mistakes, omissions, unclear formulations and - as I'm painfully aware as a non-native speaker - bad grammar.

To send me feedback, e-mail me at feedback@creativedsls.com.
