[preface]

== Preface

=== Why another book about DSLs in Kotlin?

Kotlin is a powerful language that is well-suited for writing Domain Specific Languages. There is already a wealth of literature available on this topic, but I find that many of these books fall short in a few key areas:

* They often focus on oversimplified examples that do not provide a clear understanding of how to write DSLs in practice
* They present solutions in a vacuum, without explaining the design process, the requirements and constraints that apply, or the trade-offs that were made
* They do not provide a categorization of the different types of DSLs, or a comparison of their relative strengths and weaknesses

This book aims to fill these gaps by providing a comprehensive guide to writing DSLs in Kotlin, with a focus on practical examples and real-world considerations. One of the main goals of this book is to go beyond toy examples and provide real-world insights into the process of writing DSLs in practice. This includes discussing the design process, the requirements and constraints that apply, the trade-offs that must be made, and the challenges that arise.

To achieve this, the book progresses from "boring" default examples to more challenging and complex cases, culminating in a discussion of real-world DSLs that have been successful in practice. In addition to providing practical guidance, it is attempted to find a comprehensive terminology for classifying DSLs, similar to the way the design patterns movement established a common language for coding solutions.

Overall, the goal of the book is to provide a comprehensive and practical guide to designing and implementing DSLs using Kotlin.

=== Who is this book not (yet) intended for?

This book is not very suitable for those who are new to Kotlin or Java. While this book does contain a chapter discussing Kotlin language features and their potential use in DSLs, it is not meant to be a comprehensive guide to learning the Kotlin language. If you are not yet familiar with Kotlin or Java, it is recommended to take the time to learn these languages before diving into DSLs. Writing DSLs can be challenging, and it is important to have a solid foundation in the host language before attempting to create a full-scale DSL. This book will still be here when you are ready to take on the challenge of DSL development.

=== What's in this Book

_Chapter 1, Introduction_, defines what a DSL is, discusses the differences between internal and external DSLs, and gives a general overview about the usage of DSL and underlying design principles.

_Chapter 2, Requirements Analysis_, helps to define requirements and expectations of a DSL design before implementing it. Jumping into action without defining your goals may end in a nasty surprise, as there are more things to consider than you may think.

_Chapter 3, Writing a DSL_, suggests a simple methodology for implementing a DSL. The given steps help to avoid tunnel vision, to get unstuck when hitting a wall, and to iterate your way to success.

_Chapter 4, Relevant Language Features_, takes a closer look at the Kotlin language from the perspective of a DSL designer. Even if you are very familiar with Kotlin, you might have never used one of the more obscure language features, like extension properties.

_Chapter 5, Algebraic DSLs_, introduces the first category of DSLs, which supports number-like behavior by employing operator overloading and infix functions. This is a quite straightforward DSL type, but mastering it will come handy in many other contexts.

_Chapter 6, Builder Pattern DSLs_, covers the well known Builder Pattern you probably already know from Java, and shows some variations attempting to make builders safer to use.

_Chapter 7, Loan Pattern DSLs_, is about employing extension functions and the Loan Pattern in order to solve similar problems like the Builder Pattern DSL, but in a more idiomatic and convenient way. It is also shown how the DSL code can be written for you by using libraries like AutoDSL.

_Chapter 8, Hybrid DSLs_, shows how to deal with situations where one of the already covered DSL categories alone just doesn't cut it, and you have to combine them. Mixing language features comes with its own set of challenges, and this chapter will prepare you to overcome them.

_Chapter 9, String-Parsing DSLs_, gives you an overview about DSLs embedded in strings, which can be seen as an edge case between internal and external DSLs. The chapter contains - for educational purposes - a manually written parser, but also shows how the same parser can be written using a parser-combinator library.

_Chapter 10, Annotation-based DSLs_, discusses the use of annotations for a DSL, which allows to add new meaning or additional behavior to existing code. The example code shows also how to use reflection behind the scenes in order to bring the annotations to life.

_Chapter 11, Code Generation for DSLs_, discusses how code generation can help you when writing the DSL manually is just too much boilerplate. At first, this task may sound complicated, but the example shows that it isn't really something to be afraid of.

_Chapter 12, Java interoperability_, gives an overview of the issues that may arise when Kotlin DSLs are used from Java code, and gives some advice on how to solve these issues.

_Chapter 13, Real-World DSL Examples_, discusses some well-known and battle-tested DSLs, in order to learn from it. In my opinion, toy-examples are not enough to learn good DSL design. It is important to see how DSLs deal with real-world issues, how they have to compromise and still manage to deliver a great user experience.

=== Prerequisites

To try out the code samples in this book or from the associated project at https://github.com/creativeDsls[github.com/creativeDsls], you will need an integrated development environment (IDE) that can run Kotlin. I recommend using JetBrains' IntelliJ IDEA, which has a free community edition that is sufficient for this purpose. Alternatively, you can also use the online Kotlin sandbox   https://play.kotlinlang.org/[play.kotlinlang.org] for smaller examples. This book uses Kotlin version 1.8 and assumes Java language level 11 unless otherwise specified.

It is also recommended that you familiarize yourself with the https://kotlinlang.org/docs/home.html[Kotlin Documentation], which is a valuable resource for learning about the language and its features. This book will refer to the Kotlin documentation for specific or non-DSL-related topics, rather than repeating information that can already be found there.

=== Typographical Conventions

This book uses a few typographical conventions to structure its content.

Inlined code snippets are shown like this: `val answer = 42`

Tips, warnings etc. are presented as follows:

TIP: When the white frost comes, do not eat the yellow snow.

WARNING: Beware the Jabberwock, my son! The jaws that bite, the claws that catch!
Beware the Jubjub bird, and shun the frumious Bandersnatch!

Example code is shown like this, and may include a file name or other indication of origin before the code block:

[source,kotlin]
.src/main/kotlin/personDemo/Person.kt
----
import java.time.ZonedDateTime
import java.time.temporal.ChronoUnit.YEARS

data class Person(val firstName: String, val lastName: String, val age: Int) {
   constructor(firstName: String, lastName: String, dateOfBirth: ZonedDateTime):
       this(firstName, lastName, YEARS.between(dateOfBirth, ZonedDateTime.now()).toInt())
}
----

Definitions or additional information may be presented as follows:

.The name "Kotlin"
****
"Kotlin" is a small Russian island in the Baltic Sea. Naming languages or projects after islands has been a long-standing tradition in the Java ecosystem. Beside Java itself, there are projects like Lombok, the Komodo-IDE and the Ceylon language. The Jakarta project is named after the capital of Indonesia, which is located on the island of Java.
****

Quotes look like this:

"Code is like humor. When you have to explain it, itâ€™s bad."
-- Cory House

=== Tools used for writing this book

The book is written in the https://asciidoc.org/[AsciiDoc] format. For PDF and eBook generation, I used the https://asciidocfx.com/[AsciidocFX] editor. The main writing and programming tool was https://www.jetbrains.com/idea/[IntelliJ IDEA] by JetBrains, using the https://plugins.jetbrains.com/plugin/7391-asciidoc[Asciidoctor plugin]. The diagrams were made using the https://ditaa.sourceforge.net/[ditaa] library.

I used https://openai.com/blog/chatgpt/[ChatGPT] by OpenAI as writing assistant. As a non-native speaker, it is difficult to avoid grammar mistakes and to find to a natural writing style, and I'm thankful that OpenAI granted public access for testing this incredible technology.

=== Feedback

Please do not hesitate to contact me if you find any errors or have suggestions for improvement. Your feedback is very valuable to me and will help to improve this book for future readers. Thank you in advance for taking the time to let me know your thoughts.

To give feedback, e-mail me at creativeDsls@protonmail.com.
