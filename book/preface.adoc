[preface]

== Preface

=== Why another book about DSLs in Kotlin?

Kotlin is very suitable to write DSLs and accordingly there exists already literature about this topic. However, in my opinion many existing books fall short in some ways:

* They focus too much on "toy examples" that give little insight in the process of writing DSLs in practice
* They present solutions in a "vacuum", without highlighting how an effective design process looks like, which requirements, constraints and limitations apply, and which trade-offs were made
* They don't attempt a categorization of, and comparison between the different DSL types

This book tries to address these shortcomings. It contains a checklist of requirements, which includes less obvious, but nevertheless important aspects of the requirement analysis. It shows, how designing DSLs can be structured. Further, the presented DSLs progress from "boring" default examples to more and more challenging and unwieldy cases, and concludes with a discussion of some complex and successful real-world DSLs.

Another goal of this book is to avoid presenting isolated examples, but to attempt a classification of DLS. The design patterns movement established a common language for battle-tested coding solutions. In the same way, there should exist a widely accepted terminology for classifying DSLs, and this book wants to contribute to this effort.

=== Who Shouldn't Read this Book (yet)?

Writing DSLs can be challenging, usually it isn't a good introduction to a host language. That's why this book assumes that you are already familiar with Kotlin, and - to a lesser degree - with Java. The book contains actually a chapter describing language features of Kotlin, but it is focussing on their possible use in DSLs - so this won't be enough to learn the language.

So, if you don't feel comfortable in Kotlin yet, take your time and explore the language first, it will save you from a lot of confusion. This book won't go anywhere in the meantime, it can wait until you can get the most out of it.

=== What's in this Book

_Chapter 1, Introduction_, defines what a DSL is, discusses the differences between internal and external DSLs, and gives a general overview about the usage of DSL and underlying design principles.

_Chapter 2, Requirements Analysis_, helps to define requirements and expectations of a DSL design before implementing it. Jumping into action without defining your goals may end in a nasty surprise, as there are more things to consider than you may think.

_Chapter 3, Writing a DSL_, suggests a simple methodology for implementing a DSL. The given steps help to avoid tunnel vision, to get unstuck when hitting a wall, and to iterate your way to success.

_Chapter 4, Relevant Language Features_, takes a closer look at the Kotlin language from the perspective of a DSL designer. Even if you are very familiar with Kotlin, you might have never used one of the more obscure language features, like extension properties.

_Chapter 5, Algebraic DSLs_, introduces the first category of DSLs, which supports number-like behavior by employing operator overloading and infix functions. This is a quite straightforward DSL type, but mastering it will come handy in many other contexts.

_Chapter 6, Builder Pattern DSLs_, covers the well known Builder Pattern you probably already know from Java, but also some variations that may surprise you.

_Chapter 7, Loan Pattern DSLs_, is about employing extension functions and the Loan Pattern in order to solve similar problems like the Builder Pattern DSL, but in a more idiomatic and convenient way. It is also shown how the DSL code can be written for you by using libraries like AutoDSL.

_Chapter 8, Hybrid DSLs_, shows how to deal with situations where one of the already covered DSL categories alone just doesn't cut it, and you have to combine them. Mixing language features comes with its own set of challenges, and this chapter will prepare you to overcome them.

_Chapter 9, String-Parsing DSLs_, gives you an overview about DSLs embedded in strings, which can be seen as an edge case between internal and external DSLs. The chapter contains - for educational purposes - a manually written parser, but also shows how the same parser can be written using a parser-combinator library.

_Chapter 10, Annotation-based DSLs_, discusses the use of annotations for a DSL, which allows to add new meaning or additional behavior to existing code. The example code shows also how to use reflection behind the scenes in order to bring the annotations to life.

_Chapter 11, Code Generation for DSLs_, discusses how code generation can help you when writing the DSL manually is just too much boilerplate. At first, this task may sound complicated, but the example shows that it isn't really something to be afraid of.

_Chapter 12, Real-World DSL Examples_, discusses some well-known and battle-tested DSLs, in order to learn from it. In my opinion, toy-examples are not enough to learn good DSL design. It is important to see how DSLs deal with real-world issues, how they have to compromise and still manage to deliver a great user experience.

_Chapter 13, Wrap-up_, collects some bits and pieces of experience which might be helpful to your journey, and finishes with a few closing remarks.

=== Prerequisites

To try out code samples from this book or the associated project https://github.com/creativeDsls[github.com/creativeDsls], you can use any IDE capable of running Kotlin (obviously IntelliJ IDEA will have an edge regarding Kotlin support), or you can go to https://play.kotlinlang.org/[play.kotlinlang.org] for an online sandbox. The Kotlin language version used is 1.7. If not stated otherwise, when discussing Java, language level 11 is assumed.

=== Typographical Conventions

This book uses a few typographical conventions to structure its content.

Inlined code snippets are shown like this: `val answer = 42`

Tips, warnings etc. are shown as follows:

TIP: When the white frost comes, do not eat the yellow snow.

WARNING: Beware the Jabberwock, my son! The jaws that bite, the claws that catch!
Beware the Jubjub bird, and shun the frumious Bandersnatch!

Example code is shown like this, and may include a file name or other indication of origin before the code block:

[source,kotlin]
.src/main/kotlin/personDemo/Person.kt
----
import java.time.ZonedDateTime
import java.time.temporal.ChronoUnit.YEARS

data class Person(val firstName: String, val lastName: String, val age: Int) {
   constructor(firstName: String, lastName: String, dateOfBirth: ZonedDateTime):
       this(firstName, lastName, YEARS.between(dateOfBirth, ZonedDateTime.now()).toInt())
}
----

Definitions or additional information may be presented as follows:

.The name "Kotlin"
****
"Kotlin" is a small Russian island in the Baltic Sea. Naming languages or projects after islands has been a long-standing tradition in the Java ecosystem. Beside Java itself, there are projects like Lombok, the Komodo-IDE and the Ceylon language. The Jakarta project is named after the capital of Indonesia, which is located on the island of Java.
****

Quotes look like this:

"Code is like humor. When you have to explain it, itâ€™s bad."
-- Cory House

=== Feedback

I'm always thankful for feedback from my readers. Constructive criticism helps to improve this book. As every book, it contains mistakes, omissions, unclear formulations and - as I'm painfully aware as a non-native speaker - bad grammar.

To send me feedback, e-mail me at feedback@creativedsls.com.
