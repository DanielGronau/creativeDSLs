== Relevant Language Features
:source-highlighter: rouge
:icons: font

As mentioned in the preface, this book assumes basic Kotlin knowledge from the reader. However, DSLs use other language features, or they use them in other ways than common code. This chapter wants to give a short overview of language features that are relevant for writing DSLs.

=== Backtick Identifiers

Sometimes, you need very descriptive identifiers in a DSL, which shouldn't have to follow the usual rules. Kotlin allows almost arbitrary identifiers, as long as they are enclosed in backticks. For the JVM all characters except `\r\n,.;:\|/[]<>`` are allowed in backtick identifiers.

A typical use case are DSLs for test libraries. While Java limits you to underscores and camelCase, in Kotlin very descriptive names for test function are possible by using the backtick syntax:

[source,kotlin]
----
@Test
fun `check that the slithy toves gyre and gimble in the wabe` {
   ...
}
----

=== Named Arguments and Default Values

Method and constructor arguments can be accessed using their names, which increases the readability especially for longer argument lists. In Java, this behavior is often imitated by using a builder, but in many cases Kotlin's built-in solution is more convenient.

Further, method and constructor arguments can also have default values assigned. Both language features are useful on their own, but together they complement each other very well. A nice example is the autogenerated `copy()` method in data classes:

[source,kotlin]
----
data class Person(val firstName: String, val lastName: String, val age: Int) {
    ...
    fun copy(firstName: String = this.firstName,
             lastName: String = this.lastName,
             age: Int = this.age ) = Person(firstName, lastName, age)
}

val happyBirthday = person.copy(age = person.age + 1)
----

As you can see, the values of the current object are set as default values of the new instance, and thanks to the named argument feature one can pinpoint the arguments which must be changed, and leave all others untouched.

=== Trailing Lambda Arguments

...

### Varargs

Varargs sind bereits von Java bekannt, und erlauben, eine variable Anzahl von
Argumenten anzugeben. Allerdings gibt es einige wesentliche Verbesserungen in Kotlin:

Zum einen ist die Syntax durch den spread-Operator `*` eindeutig und erlaubt,
Einzelargumente und Arrays beliebig zu kombinieren,
etwa so: `val list = listOf(2, 0, *someArray, 4)`.

Zum anderen kann ein Varargs an beliebiger Stelle stehen, wobei man beim Aufruf in der
Regel benannte Argumente verwenden muss, um eine eindeutige Zuordnung der nachfolgenden
Parameter sicherzustellen:

```kotlin
fun someMethod(vararg numbers: Int, someString: String) { ... }

someMethod(1, 2, 3, someString = "Hi!")
```
Für DSLs interessant ist die Möglichkeit, ein Vararg als vorletztes Argument vor einem
abschließenden Lambda einsetzen zu können, ohne beim Aufruf benannte Argumente
verwenden zu müssen:

```kotlin
fun someMethod(someString: String, vararg numbers: Int, block: () -> Unit) { ... }

someMethod("Hi!", 1, 2, 3) {
    ...
}
```

### Property-Syntax

### Operator-Überladung

...

Der Invoke-Operator kann verwendet werden, um die Syntax eines
Funktionsaufrufs zu simulieren. So können sich z.B. Objekte als
Funktionen "tarnen", aber dabei State speichern:

```kotlin
object count {
    private var n = 1
    operator fun invoke(): Int = n++
}
```

### Inline Funktionen

### Erweiterungs-Funktionen

### Receiver-Funktionen und -Lambdas

### Die @DslMarker-Annotation

## Properties

## Annotationen

## Reflection

