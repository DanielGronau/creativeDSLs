== Relevant Language Features

Kotlin is a great language, with many great features which are missing in Java, including:

* Null-safe type-system
* short syntax, e.g. optional semicolons or functions with expression body
* objects instead of static members
* top-level and local functions
* trailing lambda syntax
* compilable to JVM, JavaScript and native applications

At the same time, calling Java code works almost always, and there are annotations to make calling Kotlin code from Java easier. Generally Kotlin is a great choice as a programming language, even though Java improved considerably in the last years.

As mentioned in the preface, this book assumes that the reader has basic Kotlin knowledge. However, DSLs often use little-known language features, or they use some features in other ways than common code. Sometimes, even the users of the DSL might not be aware of the kind of "machinery" used to make it work.

This chapter gives a short overview of language features that might be relevant for writing DSLs. I hope that after reading the chapter, you better understand how some DSL "tricks" work.

=== Backtick Identifiers (((Backtick Identifiers)))

Kotlin allows almost arbitrary identifiers, as long as they are enclosed in backticks. The main reason for introducing this feature was to allow the usage of identifiers which are keywords in Kotlin but not in Java, like `fun` or `when`. For DSLs, we can use them when we need descriptive identifiers which don't follow the usual syntactic rules.

Backtick identifiers start and end with a backtick `{backtick}` - these are not part of the identifier, but just delimiters - and can contain almost all characters. E.g. for Kotlin on the JVM, all characters except `\r\n,.;:\|/[]<>{backtick}` are allowed.

A typical use case for backticks are DSLs for test libraries. While Java limits you to underscores and camelCase, Kotlin allows very descriptive names for test functions by using the backtick syntax:

[source]
----
fun `check that the slithy toves gyre and gimble in the wabe` {
   ...
}
----

Another common use case is to simulate an operator with an infix function, e.g. the exponentiation of numbers could be written as `5 {backtick}^{backtick} 3`.

=== Named Arguments and Default Values

Java relies on the order of the parameters when calling a method or constructor, which can get confusing very quickly. In contrast, Kotlin allows you to address arguments by name, which is much more readable, and doesn't require you to remember the order of parameters:

[source,kotlin]
----
fun makeColor(red: Int, green: Int, blue: Int, alpha: Int)
   = Color(red, green, blue, alpha)

// call by parameter order
val color1 =
    makeColor(255, 255, 100, 128)

// call by parameter name
val color2 =
    makeColor(alpha = 128, red = 255, green = 255, blue = 100)
----

In Java, a similar naming behavior is imitated by using the builder pattern, but in many cases Kotlin's built-in solution is more convenient.

Function and constructor arguments can also have default values assigned. In Java, you would have to write multiple methods or constructors with different combinations of default values set, which leads to a lot of hard to read, boilerplate code. In the example above, it would be sensible to set the alpha value to 255, as it is more common to define an opaque color than a translucent one:

[source,kotlin]
----
// function with a default value of 255 for alpha
fun makeColor(red: Int, green: Int, blue: Int, alpha: Int = 255)
   = Color(red, green, blue, alpha)

// setting all parameters
val color1 =
    makeColor(255, 255, 100, 128)

// using the default value 255 for alpha
val color2 =
    makeColor(255, 255, 100)
----

Both language features are useful on their own, but they complement each other very well. A nice example is the autogenerated `copy()` method in data classes:

[source,kotlin]
----
data class Person(val firstName: String, val lastName: String, val age: Int) {
    // the method is autogenerated, but would look like this:
    fun copy(firstName: String = this.firstName,
             lastName: String = this.lastName,
             age: Int = this.age ) =
        Person(firstName, lastName, age)
}

val person = Person("John", "Doe", 23)

val happyBirthday = person.copy(age = person.age + 1)
----

The values of the current object are set as default values of the new instance, and thanks to the named argument feature you can pick the arguments which should be changed, and leave all others untouched.

=== Trailing Lambda Arguments

If a method expects an argument of a function type, you can use the usual lambda syntax with curly braces when you call it. E.g. you can merge a list of strings using then `fold()` method as follows:

[source,kotlin]
----
listOf("one", "two", "three").fold("", { s, t -> s + t })
----

However, if such an argument is the last one, you can "pull it out" of the argument list:

[source,kotlin]
----
listOf("one", "two", "three").fold("") {
   s, t -> s + t
}
----

And if it is the only argument, you don't have to write the empty parenthesis. The `map()` method is an example for a method with a single function argument:

[source,kotlin]
----
listOf("one", "two", "three").map {
    s -> s.length
}
----

While this syntactic sugar doesn't look very impressive at the first glance, it allows to write very natural looking DSLs for nested structures. Here is an example from the Kotlin documentation:

[source,kotlin]
.https://kotlinlang.org/docs/type-safe-builders.html#how-it-works
----
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
----

=== Varargs

Varargs are already part of Java, and allow to call a method with a variable number of arguments. Kotlin has them too, but made them more safe and convenient:

One change is that the syntax is now unambiguous. In Java, there were cases when it wasn't clear whether an array was meant to be a single argument of a vararg, or if its elements should be used as arguments. Kotlin introduced the "spread operator" `*`, which indicates that the elements of an array should be used as arguments in a varargs. Further, Kotlin allows to combine single value arguments and elements of spread arrays freely, e.g. you can write: `val list = listOf(2, 0, *someArray, 4)`.

==== Vararg Position and Trailing Lambda Syntax

In contrast to Java, where a vararg must occur as last argument, Kotlin allows to put the vararg anywhere, even though you might have to use named arguments in order to avoid ambiguity:

[source,kotlin]
----
fun someMethod(vararg numbers: Int, someString: String) { ... }

someMethod(1, 2, 3, someString = "Hi!")
----

At first glance, having the choice to put varargs wherever you want doesn't seem to be terribly useful. But one use case makes this feature interesting from a DSL design perspective: You can put a vararg as second to last argument before a trailing lambda argument.

[source,kotlin]
----
fun someMethod(someString: String, vararg numbers: Int, block: () -> Unit) { ... }

someMethod("Hi!", 1, 2, 3) {
    ...
}
----

As the code snippet shows, in this case there are no named arguments required. I think this feature shows very well how much attention to detail was paid when designing the language.

=== Property-Syntax

Kotlin allows to control how properties are read and written. This makes it easy to hide DSL functionality in plain sight. A straightforward example is checking preconditions:

[source,kotlin]
----
class TemperatureSensor {
    var celsius: Double = 0.0
        set(value) {
            if(value < -273.15) {
                throw IllegalArgumentException("Temperature is under absolute zero.")
            }
            field = value
       }
   ...
}
----

There are many things you can do with explicit setters or getters, like caching or input sanitation. Later in the extensions section we'll discuss another use of the property syntax.

=== Operator Overloading

Kotlin allows operator overloading, but is conservative in the sense that it permits only a fixed set of operators:

* the unary operators `+`, `-` and `!`
* the binary arithmetic operators `+`, `-`, `*`, `/` and `%`
* the augmented assignments for these: `+=`, `-=`, `*=`, `/=` and `%=`
* the range operator `..`
* the in operator `in`
* the index access operator `[]`
* the invoke operator `()`
* the equality operators `==` and `!=`
* the comparison operators `<`, `<{zwsp}=`, `>`, `>=`

Note that the boolean operators `&&` and `||` cannot be overloaded. Kotlin 1.7.20 introduces the _experimental_ `..<` open-ended range operator, which will be enabled by default in language version 1.8.

There are many use cases for operators, but please don't overuse them. There should be at least some association or analogy between the operation and the chosen operator. E.g. for concatenating a path, `/` would be fine, as it is a common path separator. If you want to "add" a single value inside a trailing lambda block in some sense, using the unary `+` has become a kind of standard. It might be also okay to use `..` instead of a `:`, because of the visual similarity.

But at some point you need to draw a line, e.g. inverting a matrix by using `!` would be in my opinion a bit of a stretch. Also, it can be confusing when you reuse an operator too often, like "adding" an address, phone number, email or website to a person. Often it is better to use an infix function with a meaningful name instead of letting the users guess what an operator could mean.

.Don't be too clever
****
There is a temptation to be "too clever" when designing a DSL, by assuming that other people will have the same associations as oneself when looking at certain DSL elements. You may think, "A percent sign looks like a little fraction", but others may not have the same association as you. It's the same awkward situation as for a joke not everyone gets. So try to avoid "clever" assumptions, which make it actually harder to understand your DSL.
****

That said, you can do some sneaky things with operators. E.g. the invoke operator can be used to simulate the syntax of a function call, so you can e.g. camouflage objects to look like functions. Similarly, the index access operator can be used to mimic e.g. arrays and maps.

=== Extensions

One of the most important features for DSL design are functions, lambdas and properties with receivers. This can be understood as putting the function body in the scope of the receiver, so you can access its public fields, methods etc., and also refer to the receiver itself using `this`. From the user's point of view, the call with receiver looks exactly how a normal method call on the receiver instance would look like. This makes extension methods a great tool to add DSL features to classes that you have no control over.

==== Type narrowing

Interestingly, generic extension functions have a capability that normal instance methods haven't: They can "fix" generic parameters to a certain type, narrowing down the range of possible receivers. Here is an example for calculating the product of numbers as an extension function for a list:

[source,kotlin]
----
fun List<Double>.product() = fold(1.0, Double::times)

val p = listOf(1.0, 2.0, 3.0).product()  // p == 6.0
----

The call to `Double::times` is only possible because the receiver is not just any list, but specifically a `List<Double>`, and this additional type information is also carried over to the function body. This feature of extension methods can be used in DSLs e.g. for performing compile-time checks, making the DSL safer to use.

==== Loan Pattern

****
The idea of the Loan Pattern is to hide construction and disposal of an instance (often a resource) from client code. The caller gets only access to the already initialized instance, and isn't responsible for terminal operations like closing connections at the end.
****

Lambdas can have receivers too, which is practical when applying the Loan Pattern. Using this pattern can be beneficial for DSLs, as it helps to control the life-cycle of the receiver class. Take this example:

[source,kotlin]
----
fun sb(block: StringBuilder.() -> Unit): String =
    StringBuilder()
        .apply { block.invoke(this) }
        .toString()

val s: String = sb {
    append("World")
    insert(0, "Hello ")
    append('!')
}
----

This may look a little confusing at first, but the main point is that you can use extension methods to create a block where `this` is a certain receiver class, and you don't have to care about its construction or final steps like calling a `build()` - or
in the example the `toString()` - method.

Building DSLs based on this feature is very common, as it has several advantages over the classic Builder Pattern.

==== The @DslMarker annotation

When you nest several extension functions, there can be a scope problem : Things visible in the outer blocks are also visible in the inner ones. E.g. in a DSL for HTML generation, one could write:

[source,kotlin]
----
html {
    head {...}
    body {
        head {} // ouch, head() is defined in html's scope, but also visible here
    }
}
----

To avoid this problem, there is a mechanism for scope control:

* Define a custom annotation
* Annotate this annotation with `@DslMarker`
* Mark all involved receiver classes (or a common super class) with your annotation
* Now, you can't directly access things from the outer scope. You still can refer them indirectly, e.g. using the syntax `this@html.head{...}`

In our example, such an annotation could look like this:

[source,kotlin]
----
@DslMarker
annotation class HtmlMarker
----

When the receiver classes of the `head()` and `body()` extension methods are annotated that way, the example above wouldn't compile any longer.

==== Extension properties

You can not only define extension functions and lambdas, but also extension properties. Generally, they aren't used nearly as much as extension functions, but they can help to make DSLs prettier, as they don't require to write empty parentheses:

[source,kotlin]
----
data class Amount(val value: BigDecimal, val currency: String)

val Double.USD
    get() = Amount(this.toBigDecimal(), "USD")

// with an extension function, this would be 22.46.USD()
val money: Amount = 22.46.USD
----

The infix notation covered in the next paragraph uses extension function syntax as well.

=== Infix Notation for Functions

The infix notation allows names of functions to be used like binary operators. Well-known examples in the Kotlin API include `to` for creating pairs, and `until` and `downTo` for creating ranges.

The function must be a receiver function, and have one argument. The receiver-`this` becomes the left-hand side, and the argument becomes the right-hand side of the operator. Note that you can still use the normal function call syntax. Here is an example for checking preconditions:

[source,kotlin]
----
infix fun <T> T.shouldBe(expected: T) {
    require(this == expected)
}

fun testIfExpected(s: String) {
    s.shouldBe("expected") // normal syntax
    s shouldBe "expected" // infix syntax
}
----

A weakness of the infix notation is that you can't explicitly specify generics using this syntax. In this case, you can fall back to the normal function call syntax - but users of the DSL might not know this.

[#functionalInterfaces]
=== Functional Interfaces

Imagine you have an interface for string tests, with a single abstract function, and you need an anonymous implementation:

[source,kotlin]
----
interface Test {
    fun check(s: String): Boolean
}

val shortString = object : Test {
    override fun check(s: String) = s.length < 10
}
----

That is quite ugly, and way too verbose to expect a DSL user to implement your interface this way. But as the interface has only a single abstract method (abbreviated as "SAM"), it can be written as functional interface, which allows to use a simplified syntax to implement it anonymously:

[source,kotlin]
----
//not the "fun"
fun interface Test {
    fun check(s: String): Boolean
}

val shortString = Test { s -> s.length < 10 }
----

The lambda will be automatically translated back to an implementation as shown above. This process is called a "SAM conversion". I think you would agree that this syntax looks much better, in fact good enough to make it useful for DSLs.

=== Generics

Generics are a useful abstraction over concrete types in all kinds of contexts, including DLS design. A specific use case is the implementation of compile time checks. Here is a simple example modelling currencies:

[source,kotlin]
----
import java.math.BigDecimal

interface Euro
interface BritishPound

data class Currency<T>(val value: BigDecimal)

val Double.EUR
    get() = Currency<Euro>(this.toBigDecimal())
val Double.GBP
    get() = Currency<BritishPound>(this.toBigDecimal())

operator fun <T> Currency<T>.plus(that: Currency<T>) =
    copy(value = this.value + that.value)

val works = 3.1.EUR + 4.5.EUR // 7.6 €
val worksToo = 2.1.GBP + 4.2.GBP // 6.3 £

//this doesn't compile:
//val oops = 3.1.EUR + 4.5.GBP
----

Adding amounts of different currencies together isn't possible, because the definition of `+` ensures that both amounts belong to the same currency.

.Type-level Programming and Phantom Types
****
Type-level programming is a technique, where the compiler is used to perform checks or even calculations, which gives more control over the behavior of the affected classes. That includes restricting unwanted operations, or a more flexible behavior of the type system.

A type parameter which doesn't relate to any field, argument, etc. of its  class is called a "phantom type", and is commonly used for type-level programming.
****

[#reifiedGenerics]
==== Reified Generics

One great feature of Kotlin is reified generics. The JVM implements generics using "type erasure", which means that (while the compiler checks them and even adds type casts and auxiliary methods) at runtime the JVM basically "forgets" them. In Kotlin, you can access that type information under certain circumstances:

[source,kotlin]
----
inline fun <reified T> List<T>.combine(): Unit = when(T::class) {
    Int::class -> (this as List<Int>).sum()
    String::class -> (this as List<String>).fold("", String::plus)
    else -> this.toString()
}.let { println(it) }

fun main() {
    listOf<Int>().combine() // 0
    listOf(1,2,3).combine()  // 6
    listOf("x","y","z").combine() // xyz
    listOf(true, false).combine() // [true, false]
}
----

Note the expression `T::class`, which shouldn't work considering type erasure. However, the function is defined as an `inline` function, and the generic parameter `T` is marked as "reified". The details are beyond the scope of this book, but basically the inlining allows the compiler to gather the generic type information already at compile time, and make it look like as there is no type erasure happening. It should be noted that inline functions are subjected to some restrictions, and show differences to "normal" functions regarding their return behavior.

[#annotations]
=== Annotations

You can write whole DSLs using annotations, but more often annotations can support DSLs, e.g. by pointing out how certain fields or classes should be handled. They are especially powerful when your DSL shows a certain default behavior, but needs to consider some edge cases or exceptions, like "don't persist this property".

Another useful application for annotations is code generation(((Code Generation))). E.g. the already mentioned AutoDSL library uses the information provided via annotations to construct the DSL classes for you.

.Annotation Processors
****
Annotation processors allow to execute custom processor code during the build process, according to the annotations present in the application code. Kotlin features two annotation processors, the older https://kotlinlang.org/docs/kapt.html[kapt], which won't be developed further, and the recommended https://kotlinlang.org/docs/ksp-overview.html[Kotlin Symbol Processing API] (KSP). While the topic is beyond the scope of this book, it might be a good idea to get familiar with this concept, especially when developing annotation-based DSLs.
****

[#reflection]
=== Reflection

Sometimes you need to inspect or deconstruct classes, call unknown methods, react to annotations etc., which can be done using reflection. If you need more than the most basic reflection in Kotlin, you have to import a separate dependency:

[source,kotlin]
.Gradle (.kts)
----
dependencies {
    implementation("org.jetbrains.kotlin:kotlin-reflect:1.7.10")
}
----

[source,xml]
.Maven
----
<dependencies>
  <dependency>
      <groupId>org.jetbrains.kotlin</groupId>
      <artifactId>kotlin-reflect</artifactId>
  </dependency>
</dependencies>
----

Depending on your use case, you might also consider alternatives like https://github.com/Kotlin/kotlinx.reflect.lite[kotlinx.reflect.lite].