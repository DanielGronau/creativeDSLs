== Relevant Language Features

As mentioned in the preface, this book assumes basic Kotlin knowledge from the reader. However, DSLs use often lesser common language features, or they use features in other ways than common code. This chapter wants to give a short overview of language features that are relevant for writing DSLs.

=== Backtick Identifiers

Sometimes, you need very descriptive identifiers in a DSL, which shouldn't have to follow the usual rules. Kotlin allows almost arbitrary identifiers, as long as they are enclosed in backticks. For the JVM all characters except `\r\n,.;:\|/[]<>`` are allowed in backtick identifiers.

A typical use case are DSLs for test libraries. While Java limits you to underscores and camelCase, in Kotlin very descriptive names for test function are possible by using the backtick syntax:

[source,kotlin]
----
@Test
fun `check that the slithy toves gyre and gimble in the wabe` {
   ...
}
----

=== Named Arguments and Default Values

Method and constructor arguments can be accessed using their names, which increases the readability especially for longer argument lists. In Java, this behavior is often imitated by using a builder, but in many cases Kotlin's built-in solution is more convenient.

Further, method and constructor arguments can also have default values assigned. Both language features are useful on their own, but together they complement each other very well. A nice example is the autogenerated `copy()` method in data classes:

[source,kotlin]
----
data class Person(val firstName: String, val lastName: String, val age: Int) {
    ...
    // the method is autogenerated, but would look like this:
    fun copy(firstName: String = this.firstName,
             lastName: String = this.lastName,
             age: Int = this.age ) = Person(firstName, lastName, age)
}

val person = Person("John", "Doe", 23)

val happyBirthday = person.copy(age = person.age + 1)
----

As you can see, the values of the current object are set as default values of the new instance, and thanks to the named argument feature one can pick the arguments which must be changed, and leave all others untouched.

=== Trailing Lambda Arguments

If a method expects an argument of a function type, you can use the usual lambda syntax with curly braces when you call it. E.g. you can merge a list of strings using then `fold()` method as follows:

[source,kotlin]
----
listOf("one", "two", "three").fold("", { s, t -> s + t })
----

However, if such an argument is the last one, you can "pull it out" of the argument list:

[source,kotlin]
----
listOf("one", "two", "three").fold("") {
   s, t -> s + t
}
----

And if it is the only argument, you don't have to write the empty parenthesis. The `map()` method is an example for a method with a single function argument:

[source,kotlin]
----
listOf("one", "two", "three").map {
    s -> s.length
}
----

While this syntactic sugar doesn't look very impressive at the first glance, it allows to write very natural looking DSLs for nested structures. Here is an example from the Kotlin documentation:

[source,kotlin]
.https://kotlinlang.org/docs/type-safe-builders.html#how-it-works
----
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
----

=== Varargs

Varargs are already part of Java, and allow to call a method with a variable number of arguments. Kotlin has them too, but made them more safe and convenient:

One change is that the syntax is now unambiguous. In Java, there were cases when it wasn't clear whether an array was meant to be a single argument of a vararg, or if its elements should be used as arguments. Kotlin introduced the "spread operator" `*`, which makes clear that the elements of an array should be used for the vararg. Also, Kotlin allows to combine arguments from single values and from spread arrays freely, e.g. you can write: `val list = listOf(2, 0, *someArray, 4)`.

==== Vararg Position

In Java a vararg has to be the last argument. Kotlin allows to put the vararg anywhere, even though you might have to use named arguments in order to avoid ambiguity:

[source,kotlin]
----
fun someMethod(vararg numbers: Int, someString: String) { ... }

someMethod(1, 2, 3, someString = "Hi!")
----

==== Varargs and Trailing Lambda Syntax

At the first glance, having the choice to put varargs wherever you want doesn't seem to be terribly useful. But there is one use case which makes this feature interesting from a DSL design perspective: You can put a vararg as second to last element before a trailing lambda argument:

[source,kotlin]
----
fun someMethod(someString: String, vararg numbers: Int, block: () -> Unit) { ... }

someMethod("Hi!", 1, 2, 3) {
    ...
}
----

As you can see, you don't need named arguments for clarification in this case.

=== Property-Syntax

Kotlin allows to control how properties are read and written. This makes it easy to hide DSL functionality in plain sight. An easy example is checking preconditions:

[source,kotlin]
----
class TemperatureSensor {
    var celsius: Double = 0.0
        set(value) {
            if(value < -273.15) {
                throw IllegalArgumentException("Temperature is under absolute zero.")
            }
            field = value
       }
   ...
}
----

Later in the extensions section we'll discuss another use of the property syntax.

=== Operator Overloading

Kotlin allows operator overloading, but is quite conservative in the sense that it permits only a fixed and quite limited set of operators:

* the unary operators `+`, `-` and `!`
* the binary arithmetic operators `+`, `-`, `*`, `/` and `%`
* the augmented assignments for these: `+=`, `-=`, `*=`, `/=` and `%=`
* the range operator `..`
* the in operator `in`
* the index access operator `[]`
* the invoke operator `()`
* the equality operators `==` and `!=`
* the comparison operators `<`, `<{zwsp}=`, `>`, `>=`

Note that the boolean operators `&&` and `||` cannot be overloaded.

There are many use cases for operators, but please don't overuse them. There should be at least some association or analogy between the operation and the chosen operator. E.g. for concatenating a path, `/` would be fine, as it is a common path separator. If you want to "add" a single value to a block in some sense, using the unary `+` has become a kind of standard. It might be also okay to use `..` instead of a `:`, because of the visual similarity.

But at some point you need to draw a line, e.g. inverting a matrix by using `!` would be in my opinion a bit of a stretch. Also, it can be confusing when you reuse an operator too often, like "adding" an address, phone number, email or website to a person. Often it is better to use an infix function with a meaningful name instead of letting the users guess what an operator could mean.

That said, you can do some sneaky things with operators. E.g. the invoke operator can be used to simulate the syntax of a function call. That makes it possible to camouflage objects as functions, when you need to store state:

[source,kotlin]
----
object count{
    var n = 1
    operator fun invoke(): Int = n++
}

count() // increases n by 1
----

Similarly, the index access operator can be used to mimic e.g. arrays and maps.

=== Extensions

One of the most important features for DSL design are functions and lambdas with receivers. This can be understood of putting the function body in the scope of the receiver, so you can access its public fields, methods etc., and also refer to the receiver via `this`. In case of extension functions, the call looks like a normal method call on a receiver instance.

Interestingly, you can do something using generic extension functions that isn't possible with instance methods: You can fix generic parameters to a certain type, and write a "specialized" function for this particular type. Here is an example for calculating the product of numbers as an extension function of `List`:

[source,kotlin]
----
fun List<Double>.product() = fold(1.0, Double::times)

val p = listOf(1.0, 2.0, 3.0).product()  // p == 6.0
----

==== Loan Pattern

Lambdas can have receivers too, and this plays nicely with the Loan Pattern. Applying the Loan Pattern means that construction and disposal of an instance (e.g. often a resource) is hidden from client code, which gets access to the already fully initialized instance, and isn't responsible for things like closing connections at the end. This is very useful for DSLs, because it helps to control the life-cycle of the receiver class. Take this example:

[source,kotlin]
----
fun sb(block: StringBuilder.() -> Unit): String =
    StringBuilder()
      .also { block.invoke(this) }
      .toString()

val s: String = sb {
   append("World")
   insert(0, "Hello ")
   append('!')
}
----

This may look a little confusing at first, and the details will be discussed later, but the point is that you can use a block where `this` is a certain receiver class (here `StringBuilder`), and you don't have to care about its construction or final steps (like calling a `build()` method).

==== The @DslMarker annotation

There is a scope problem when you nest several extension functions: Things visible in the outer blocks are also visible in the inner ones. E.g. in a DSL for HTML generation, one could write:

[source,kotlin]
----
html {
    head {...}
    body {
        head {} // ouch, head() is defined in html's scope, but also visible here
    }
}
----

To avoid this problem, there is a mechanism for scope control:

* Define a custom annotation
* Annotate this annotation with `@DslMarker`
* Mark all involved receiver classes (or a common super class) with your annotation
* After this, you can't directly access things from the outer scope. You still can refer them indirectly, like with `this@html.head{...}`

It should be noted that you can also define extension properties. Generally, they aren't used nearly as much as extension functions, but they can help to make DSLs prettier, as they don't require the empty parentheses an equivalent extension function would need:

[source,kotlin]
----
data class Amount(val value: BigDecimal, val currency: String)

val Double.EUR
    get() = Currency(this.toBigDecimal(), "EUR")

// with an extension function, this would be 22.46.EUR()
val money = 22.46.EUR
----

The infix notation covered in the next paragraph uses extension function syntax as well.

=== Infix Notation for Functions

The infix notation allows names of functions to be used like binary operators. Well-known examples in the Kotlin API include `to` for creating pairs, and `until` and `downTo` for creating ranges.

The function must be a receiver function, and have one argument. The receiver-`this` becomes the left-hand side, and the argument the right-hand side of the operator. Note that you can still use the normal function call syntax. Here is an example for checking preconditions:

[source,kotlin]
----
infix fun <T> T.shouldBe(expected: T) {
    require(this == expected)
}

val x: String = ...
x.shouldBe("expectedValue") // normal syntax
x shouldBe "expectedValue" // infix syntax
----

A weak point of infix notation that you can't explicitly specify generics using this syntax. In this case, you can fall back to the normal function call syntax - but users of the DSL might not know this.

=== Generics

Generics are a useful abstraction over concrete types in all kinds of contexts, including DLS design. A specific use case is the implementation of compile time checks, e.g. by using phantom types. Here is a simple example modelling currencies:

[source,kotlin]
----
object Eur
object Usd

data class Currency<T>(val value: BigDecimal, val currency: T)

val Double.EUR
    get() = Currency(this.toBigDecimal(), Eur)
val Double.USD
    get() = Currency(this.toBigDecimal(), Usd)

operator fun <T> Currency<T>.plus(that:Currency<T>) = copy(value = this.value + that.value)

val works = 3.1.EUR + 4.5.EUR // 7.6 EUR
val oops = 3.1.EUR + 4.5.USD // doesn't compile
----

The `Amount` class holds the `currency` field, which could be used for runtime checks. But with generics, we can do better: Adding amounts of different currencies together isn't possible, because the definition of `+` ensures that both amounts have the same currency type.

==== Reified Generics

One great feature of Kotlin is reified generics. The JVM implements generics using "type erasure", which means that (while the compiler checks them and even adds type casts and auxiliary methods) at runtime the JVM basically "forgets" them. In Kotlin, you can access that type information under certain circumstances:

[source,kotlin]
----
inline fun <reified T> List<T>.combine() = println(when(T::class) {
    Int::class -> (this as List<Int>).sum()
    String::class -> (this as List<String>).fold("", String::plus)
    else -> this
})
...
listOf<Int>().combine() // 0
listOf(1, 2, 3).combine() // 6
listOf("x", "y", "z").combine() // xyz
listOf(true, false).combine() // [true, false]
----

Note the expression `T::class`, which shouldn't work considering type erasure. However, the function is defined as an `inline` function, and the generic parameter `T` is marked as "reified". The details are beyond the scope of this book, but basically the inlining allows the compiler to gather the generic type information already at compile time, and make it look like as there is no type erasure happening. It should be noted that inline functions are subjected to some restrictions, and show subtle differences to not inlined functions.

=== Annotations

You can write whole DSLs using annotations, but more often annotations can support DSLs, e.g. by pointing out how certain fields or classes should be handled. They are especially powerful when your DSL shows a certain default behavior, but needs to consider some edge cases or exceptions, like "don't persist this property".

Another useful application for annotations is code generation. E.g. the already mentioned AutoDSL library uses the information provided via annotations to construct the DSL classes.

=== Reflection

Sometimes you need to inspect or deconstruct classes, call unknown methods, react to annotations etc., which can be done using reflection. If you need more than the most basic reflection in Kotlin, you have to import a separate dependency:

[source,kotlin]
.Gradle (.kts)
----
dependencies {
    implementation("org.jetbrains.kotlin:kotlin-reflect:1.7.10")
}
----

[source,xml]
.Maven
----
<dependencies>
  <dependency>
      <groupId>org.jetbrains.kotlin</groupId>
      <artifactId>kotlin-reflect</artifactId>
  </dependency>
</dependencies>
----

Depending on your use case, you might also consider alternatives like https://github.com/Kotlin/kotlinx.reflect.lite[kotlinx.reflect.lite].