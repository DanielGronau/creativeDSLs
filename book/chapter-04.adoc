== Relevant Language Features
:source-highlighter: rouge
:icons: font

As mentioned in the preface, this book assumes basic Kotlin knowledge from the reader. However, DSLs use other language features, or they use them in other ways than common code. This chapter wants to give a short overview of language features that are relevant for writing DSLs.

=== Backtick Identifiers

Sometimes, you need very descriptive identifiers in a DSL, which shouldn't have to follow the usual rules. Kotlin allows almost arbitrary identifiers, as long as they are enclosed in backticks. For the JVM all characters except `\r\n,.;:\|/[]<>`` are allowed in backtick identifiers.

A typical use case are DSLs for test libraries. While Java limits you to underscores and camelCase, in Kotlin very descriptive names for test function are possible by using the backtick syntax:

[source,kotlin]
----
@Test
fun `check that the slithy toves gyre and gimble in the wabe` {
   ...
}
----

=== Named Arguments and Default Values

Method and constructor arguments can be accessed using their names, which increases the readability especially for longer argument lists. In Java, this behavior is often imitated by using a builder, but in many cases Kotlin's built-in solution is more convenient.

Further, method and constructor arguments can also have default values assigned. Both language features are useful on their own, but together they complement each other very well. A nice example is the autogenerated `copy()` method in data classes:

[source,kotlin]
----
data class Person(val firstName: String, val lastName: String, val age: Int) {
    ...
    // the method is autogenerated, but would look like this:
    fun copy(firstName: String = this.firstName,
             lastName: String = this.lastName,
             age: Int = this.age ) = Person(firstName, lastName, age)
}

val person = Person("John", "Doe", 23)

val happyBirthday = person.copy(age = person.age + 1)
----

As you can see, the values of the current object are set as default values of the new instance, and thanks to the named argument feature one can pinpoint the arguments which must be changed, and leave all others untouched.

=== Trailing Lambda Arguments

If a method expects an argument of a function type, you can use the usual lambda syntax with curly braces when you call it. E.g. you can map a list of strings to their lengths as follows:

[source,kotlin]
----
listOf("one", "two", "three").map({ s -> s.length })
----

However, if such an argument is the last one, you can pull it out of the argument list. And if it is the only one, you also don't have to write the empty parenthesis. That's the usual syntax:

[source,kotlin]
----
listOf("one", "two", "three").map{ s -> s.length }
----

While this syntactic sugar doesn't look very impressive at the first glance, it allows to write very natural looking DSLs for nested structures. Here is an example from the Kotlin documentation:

[source,kotlin]
.https://kotlinlang.org/docs/type-safe-builders.html#how-it-works
----
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
----

=== Varargs

Varargs are already part of Java, and allow to call a method with a variable number of arguments. Kotlin has them too, but made them more safe and more convenient at the same time:

One change is that the syntax is now unambiguous. In Java, there were cases when it wasn't clear whether an array was meant to be a single argument of a vararg, or if its elements should be used. Kotlin introduced the "spread operator" `*`, which makes clear that the elements of an array should be used for the vararg. Also, Kotlin allows to combine arguments from single values and from spread arrays freely, e.g. you can write: `val list = listOf(2, 0, *someArray, 4)`.

In Java a vararg has to be the last argument. Kotlin allows to put them anywhere, even though you might need tu use named arguments in order to avoid ambiguity:

[source,kotlin]
----
fun someMethod(vararg numbers: Int, someString: String) { ... }

someMethod(1, 2, 3, someString = "Hi!")
----

At the first glance, having the choice to put varargs wherever you want doesn't seem to be terribly useful. But there is one use case which makes this feature interesting from a DSL design perspective: You can put a vararg as second to last element before a trailing function argument:

[source,kotlin]
----
fun someMethod(someString: String, vararg numbers: Int, block: () -> Unit) { ... }

someMethod("Hi!", 1, 2, 3) {
    ...
}
----

=== Property-Syntax

Kotlin allows to control how properties are read and written. This makes it easy to hide DSL functionality in plain sight. An easy example is checking preconditions:

[source,kotlin]
----
class TemperatureSensor {
    var celsius: Double = 0.0
        set(value) {
            if(value < -273.15) {
                throw IllegalArgumentException("Temperature is under absolute zero.")
            }
            field = value
       }
   ...
}
----

=== Operator Overloading

Kotlin allows operator overloading, but is quite conservative in the sense that it permits only a fixed and quite limited set of operators:

* the unary operators `+`, `-` and `!`
* the binary arithmetic operators `+`, `-`, `*`, `/` and `%`
* the augmented assignments for these: `+=`, `-=`, `*=`, `/=` and `%=`
* the range operator `..`
* the in operator `in`
* the index access operator `[]`
* the invoke operator `()`
* the equality operators `==` and `!=`
* the comparison operators `<`, `<{zwsp}=`, `>`, `>=`

Note that the boolean operators `&&` and `||` cannot be overloaded.

There are many use cases for operators, but please don't overuse them. There should be at least some association or analogy between the operation and the chosen operator. E.g. for concatenating a path, `/` would be fine, as it is a common path separator. If you want to "add" a single value to a block in some sense, using the unary `+` has become a kind of standard. It might be also okay to use `..` instead of a `:`, because of the visual similarity.

But at some point you need to draw a line, e.g. inverting a matrix by using `!` would be in my opinion a bit of a stretch. Also, it can be confusing when you reuse an operator too often, like "adding" an address, phone number, email or website to a person. Often it is better to use an inline function with a meaningful name instead of letting the users guess what an operator could mean.

That said, you can do some sneaky things with operators. E.g. the invoke operator can be used to simulate the syntax of a function call. That makes it possible to camouflage objects as functions, when you need to store state:

[source,kotlin]
----
object count{
    var n = 1
    operator fun invoke(): Int = n++
}

count() // increases n by 1
----

Similarly, the index access operator can be used to mimic e.g. arrays and maps.

=== Extension Functions and Receiver Lambdas

One of the most important features for DSL design are functions and lambdas with receivers. This can be understood of putting the function body in the scope of the receiver, so you can access its public fields, methods etc., and also refer to the receiver via `this`. In case of extension functions, the call looks like

Interestingly, you can do something using generic extension functions that isn't possible with instance methods: You can fix generic parameters to a certain type, and write a "specialized" function for this particular type. Here is an example for calculating the product of numbers as an extension function of `List`:

[source,kotlin]
----
fun List<Double>.product() = fold(1.0, Double::times)

val p = listOf(1.0, 2.0, 3.0).product()  // p == 6.0
----

Lambdas can have receivers too, and this plays nicely with the Loan Pattern. This is very useful for DSLs, because it helps to control the life-cycle of the receiver class. Take this example:

[source,kotlin]
----
fun sb(block: StringBuilder.() -> Unit): String =
    StringBuilder()
      .also { block.invoke(this) }
      .toString()

val s: String = sb {
   append("World")
   insert(0, "Hello ")
   append('!')
}
----

This may look a little confusing at first, and the details will be discussed later, but the point is that you can use a block where `this` is a certain receiver class (here `StringBuilder`), and you don't have to care about its construction or final steps.

There is a scope problem when you nest several extension functions: Things visible in the outer blocks are also visible in the inner ones. E.g. in a DSL for HTML generation, one could write:

[source,kotlin]
----
html {
    head {...}
    body {
        head {} // ouch, head() is defined in html's scope, but also visible here
    }
}
----

To avoid this problem, there is a mechanism for scope control:

* Define a custom annotation
* Annotate this annotation with `@DslMarker`
* Mark all involved receiver classes (or a common super class) with your annotation
* After this, you can't directly access things from the outer scope. You still can refer them indirectly, like with `this@html.head{...}`

It should be noted that you can also define extension fields, which will only allow getters. They aren't used nearly as much as extension functions, but it is good to know that they exist.

The infix notation covered in the next paragraph uses extension function syntax as well.

=== Infix Notation for Functions

The infix notation allows names of functions to be used like binary operators. Well-known examples in the Kotlin API include `to` for creating pairs, and `until` and `downTo` for creating ranges.

The function must be a receiver function, and have one argument. The receiver-`this` becomes the left-hand side, and the argument the right-hand side of the operator. Note that you can still use the normal function call syntax. Here is an example for checking preconditions:

[source,kotlin]
----
infix fun <T> T.shouldBe(expected: T) {
    require(this == expected)
}

val x: String = ...
x.shouldBe("expectedValue") // normal syntax
x shouldBe "expectedValue" // infix syntax
----

A weak point of infix notation that you can't explicitly specify generics using this syntax. In this case, you can fall back to the normal function call syntax - but the users of the DSL might not know this.

=== Generics

+ reified generics

=== Annotationen

=== Reflection

