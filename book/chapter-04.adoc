[#relevant_language_features]
== Relevant Language Features

Kotlin is a modern and beautiful programming language that offers several key features not found in Java.Here are some of the most notable features that set Kotlin apart:

* *Null-Safe Type System:* Kotlin's null-safety feature is a major improvement over Java, where null values can cause null pointer exceptions.This feature ensures that a variable cannot be null unless explicitly declared as such, reducing the risk of runtime errors.
* *Concise Syntax:* Kotlin's syntax is designed to be as concise as possible, reducing the amount of boilerplate code that developers need to write. Optional semicolons, operator overloading and expression-body functions are just a few examples of the syntactical sugar that makes Kotlin code not only more readable and easier to maintain, it also helps to write expressive DSLs.
* *Object-Oriented Design:* Kotlin takes a more object-oriented approach than Java, replacing static members with object declarations that can be used in a more flexible and modular way.
* *Functional Programming Features:* Kotlin also supports functional programming, including top-level and local functions, as well as trailing lambda syntax.
* *Multiplatform Support:* Kotlin can be compiled to run on multiple platforms, notably the JVM, JavaScript, and as a native application

In addition, Kotlin has excellent interoperability with Java,(((Java Interoperability))) making it easy to call Java code from Kotlin and vice versa. Kotlin also includes several annotations that make it easier to call Kotlin code from Java, ensuring that the two languages can work together seamlessly.

As mentioned in the preface, this book assumes that the reader has basic Kotlin knowledge. However, DSLs often use little-known language features, or they use some features in other ways than common code. Sometimes, even the users of the DSL might not be aware of the kind of "machinery" used to make it work.

This chapter gives a short overview of language features that might be relevant for writing DSLs. After reading this chapter, you should have a better understanding of how some common DSL "tricks" work.

[#backtickIdentifiers]
=== Backtick Identifiers (((Backtick Notation)))

Kotlin allows almost arbitrary identifiers, as long as they are enclosed in backticks. The main reason for introducing this feature was to allow the usage of identifiers that are keywords in Kotlin but not in Java, like `fun` or `when`. For DSLs, we can use them when we need descriptive identifiers which don't follow the usual syntactic rules.

Backtick identifiers start and end with a backtick `{backtick}` - these are not part of the identifier, but just delimiters - and can contain almost all characters. E.g. for Kotlin on the JVM, all characters except `\r\n,.;:\|/[]<>{backtick}` are allowed.

A typical use case for backticks are DSLs for test libraries. While Java limits you to underscores and camelCase, Kotlin allows very descriptive names for test functions by using the backtick syntax:

[source,kotlin]
----
fun `check that the slithy toves gyre and gimble in the wabe`() {
   ...
}
----

Another common use case is to simulate an operator with an infix function, e.g. you could define an exponentiation operation using a syntax like `5.0 {backtick}^{backtick} 3` (see section <<infix_notation, Infix Notation for Functions>>).

=== Named Arguments (((Named Arguments))) and Default Values (((Default Values)))

Java relies on the order of the parameters when calling a method or constructor, which can get confusing very quickly. In contrast, Kotlin allows you to address arguments by name, which is much more readable, and doesn't require you to remember the order of parameters:

[source,kotlin]
----
fun makeColor(red: Int, green: Int, blue: Int, alpha: Int)
   = Color(red, green, blue, alpha)

// call by argument order
val color1 =
    makeColor(220, 200, 100, 128)

// call by named argument
val color2 =
    makeColor(
        alpha = 128,
        red = 220,
        green = 200,
        blue = 100
    )
----

In Java, a similar naming behavior can be imitated by using the builder pattern, but in many cases Kotlin's built-in solution is more convenient.

In Kotlin, you can also assign default values to function and constructor arguments, which greatly simplifies the code compared to Java, where you need to write multiple methods or constructors with different combinations of default values to achieve the same effect. Therefore, Kotlin's default-value approach reduces boilerplate code and enhances readability. In the example above, it would be sensible to set the alpha value to 255, as it is more common to define an opaque color than a translucent one:

[source,kotlin]
----
fun makeColor(
        red: Int,
        green: Int,
        blue: Int,
        alpha: Int = 255 // setting a default value
    ) = Color(red, green, blue, alpha)

// setting all parameters
val color1 =
    makeColor(220, 200, 100, 128)

// using the default value 255 for alpha
val color2 =
    makeColor(220, 200, 100)
----

Both language features are useful on their own, but they complement each other very well. A nice example is the autogenerated `copy()` method (((Copy Method))) in data classes: (((Data Classes)))

[source,kotlin]
----
data class Person(val firstName: String, val lastName: String, val age: Int) {
    // the method is autogenerated, but would look roughly like this:
    fun copy(firstName: String = this.firstName,
             lastName: String = this.lastName,
             age: Int = this.age
        ) = Person(firstName, lastName, age)
}

val person = Person("John", "Doe", 23)

val agedPerson = person.copy(age = person.age + 1)
----

In the `copy()` method, the values of the current object are set as default values of the new instance, and thanks to the named argument feature you can pick just the arguments which should be changed, and leave all others untouched.

(((Lenses)))
[TIP]
====
While the `copy()` method is convenient when working with immutable data classes, it doesn't scale well for nested data classes: Imagine you need a copy of a company, with the email of the address of the CEO changed. That means you need nested `copy()` calls as well, going down level by level. This is lengthy, hard to read and error-prone.

In functional programming, this problem is often solved with an "optics" package, containing "lenses" and similar abstractions, which allow to easily compose copy operations for different nesting levels. If you want to learn more about this topic, I would suggest to check out https://arrow-kt.io/learn/immutable-data/intro[Arrow Optics].
====

=== Trailing Lambda Arguments (((Trailing Lambda)))

If a method expects an argument of a function type, you can use the usual lambda syntax with curly braces when you call it. E.g. you can merge a list of strings using the `fold()` method as follows:

[source,kotlin]
----
listOf("one", "two", "three").fold("", { s, t -> s + t })
----

However, if such an argument comes last, you can "pull it out" of the argument list, and append it inside its curly braces:

[source,kotlin]
----
listOf("one", "two", "three").fold("") {
   s, t -> s + t
}
----

In case the function type is the only argument, you don't have to write the empty parentheses. The `map()` method is an example for a method with a single lambda argument:

[source,kotlin]
----
listOf("one", "two", "three").map {
    s -> s.length
}
----

While this syntactic sugar might not look very impressive at first glance, it allows to write very natural looking DSLs for nested structures. Here is an example from the Kotlin documentation:

[source,kotlin]
.https://kotlinlang.org/docs/type-safe-builders.html#how-it-works
----
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
----

=== Varargs (((Varargs)))

Varargs (from "variable arguments") are a useful feature in both Java and Kotlin, allowing methods to accept a variable number of arguments. However, Kotlin has made several improvements to varargs, making them safer and more convenient to use.

One of the main improvements in Kotlin is that the syntax for varargs is now unambiguous. In Java, it was sometimes difficult to tell whether an array was intended to be a single argument for a vararg, or if its elements should be used as individual arguments. Kotlin addressed this problem by introducing the unary "spread operator" `*`, which indicates that the elements of an array (and not the array itself) should be used as arguments for a vararg.

Furthermore, Kotlin allows for a more flexible use of varargs. You can freely combine single-value arguments with elements from spread arrays, which looks like this:

[source,kotlin]
----
val someArray = arrayOf(4, 6, 8)
val list = listOf(2, 0, *someArray, 5) // contains 2, 0, 4, 6, 8, 5
----

==== Vararg Position and Trailing Lambda Syntax

In contrast to Java, where a vararg must always occur as last argument, Kotlin allows to put the vararg anywhere, even though you might need to use named arguments in order to avoid ambiguity:

[source,kotlin]
----
fun varargMethod(vararg numbers: Int, someString: String) { ... }

varargMethod(1, 2, 3, someString = "Hi!")
----

At first glance, having the choice to put varargs wherever you want doesn't seem to be terribly useful. But there is one particular use case which is very interesting from a DSL design perspective: You can put a vararg as second to last argument before a trailing lambda argument.

[source,kotlin]
----
fun varargAndLambda(someString: String, vararg numbers: Int, block: () -> Unit) { ... }

varargAndLambda("Hi!", 1, 2, 3) {
    ...
}
----

As the code snippet shows, in this case there are no named arguments required.

=== Property-Syntax (((Properties)))

Kotlin allows to control how properties are read and written. This makes it easy to hide DSL functionality in plain sight. A straightforward example is checking preconditions before setting a value:

[source,kotlin]
----
class TemperatureSensor {
    var celsius: Double = 0.0
        set(value) {
            require(value >= -273.15) { "Temperature is under absolute zero." }
            field = value
        }
}
----

Similarly, you can perform additional actions when reading a value (or even change the return value itself):

[source,kotlin]
----
class SensitiveData {
    val logger = Logger.getLogger(this::class.java.name)

    var secretValue: Int = 42
        get() {
            logger.info("Access to secret value $field at ${LocalDateTime.now()}")
            return field
        }
}
----

There are many more things you can do with properties, like caching, lazy evaluation, delegation to other properties or input sanitation. Later in the <<extensions_and_receivers, Extensions and Receivers>> section we'll discuss another use of the property syntax.

[#extensions_and_receivers]
=== Extensions (((Extensions))) and Receivers (((Receivers)))

One of the most important Kotlin features for DSL design are extension functions, lambdas and properties, which allow to add functionality to existing classes - even final ones - without touching them. These extensions are stand-alone constructs operating on a so-called receiver, which is the target class they are extending. The function body is put in the scope of the receiver, so you can access its public fields, methods etc., and you can also refer to the receiver itself using `this`. Here is how an extension function looks like:

[source,kotlin]
----
fun Int.digits(base: Int = 10): List<Int> =
    generateSequence(this.absoluteValue) {
        (it / base).takeIf { it > 0 }
    }.map { it % base }.toList().reversed()

val zero = 0.digits() // [0]
val taxiCab = 1729.digits() // [1, 7, 2, 9]
val taxiBin = 1729.digits(2) // [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1]
val taxiHex = 1729.digits(16) //[6, 12, 1]
----

From the user's point of view, the call with receiver looks exactly how a normal method call (or property access) on a receiver instance would look like. This makes extension functions a great tool for adding DSL features to classes that you have no control over. A great example are the `apply()`, `run()`, `let()` and `also()` functions in the Kotlin API, which make it easier to use e.g. expression body syntax for functions, or succinct variable assignments.

.Extension Method History
****
Extension methods, initially introduced in C#, found their way into Kotlin as "extension functions", especially with the seamless integration of Java classes into the Kotlin ecosystem in mind. This approach was chosen over Scala's implicit conversion approach, which, although more powerful, was deemed more complex to comprehend and manage. The advantages of extension methods became so evident that they were incorporated in Scala 3 as well. It is safe to say that extension methods are an important and successful advancement in contemporary object-oriented programming.
****

[#typeNarrowing]
==== Type Narrowing (((Type Narrowing)))

Interestingly, generic extension functions have a capability that normal instance methods don't have: They can fixate generic parameters on a certain type, narrowing down the range of possible receivers. Here is an example for calculating the product of numbers as an extension function for a list:

[source,kotlin]
----
fun List<Double>.product() = fold(1.0, Double::times)

val p = listOf(1.0, 2.0, 3.0).product()  // p == 6.0
----

The call to `Double::times` is only possible because the receiver is not just any list, but specifically a `List<Double>`, and this additional type information is also carried over to the function body. This feature of extension methods can be used in DSLs for performing compile-time checks.

==== Loan Pattern (((Loan Pattern)))

.What is the Loan Pattern?
****
The Loan Pattern is a design pattern in object-oriented programming that involves encapsulating the usage of a resource (such as a database connection or file handle) within a limited scope or block of code. The pattern is designed to ensure that the resource is properly acquired, used, and released, without the risk of resource leaks or conflicts with other code that may be accessing the same resource.

In essence, the Loan Pattern involves creating a resource object or acquiring a resource handle at the beginning of a block of code, using the resource as needed within the block, and then releasing or disposing of the resource at the end of the block. This ensures that the resource is only used for the duration of the block, and that it is properly cleaned up when the block completes, even if an error or exception occurs during the block.

The Loan Pattern is particularly useful when resources are limited or expensive to acquire. It can also help to improve the maintainability and robustness of code, by making it easier to reason about the usage of resources and ensuring that they are properly managed throughout the program.
****

Lambdas can have receivers too, which is practical when applying the Loan Pattern. Using this pattern can be beneficial in DSLs, as it helps to control the life-cycle of the receiver class, and to hide the steps necessary for initializing and finalizing the instance creation or operation.

Take for instance the well known `java.util.StringBuilder` class. It allows to do perform complex String operations, but in order to use it, you need to construct it, and to call its `toString()` method at the end. When applying the Loan Pattern, these steps can be hidden, and the code looks cleaner:

[source,kotlin]
----
val theUsualWay: String = StringBuilder()
    .append("World")
    .insert(0, "Hello ")
    .append('!')
    .toString()

// the extension method
fun sb(block: StringBuilder.() -> Unit): String =
    StringBuilder()
        .apply { block(this) }
        .toString()

val usingTheLoanPattern: String = sb {
    append("World")
    insert(0, "Hello ")
    append('!')
}
----

Building DSLs based on this pattern is very common, as it has several advantages over the classic builder pattern.

[#dslMarker]
==== The @DslMarker annotation (((@DslMarker)))

When you nest several extension functions, the overlapping scopes can pose a problem: Things visible in the outer code blocks are also visible in the inner ones. E.g. in a DSL for HTML generation, one could write:

[source,kotlin]
----
html {
    head {...}
    body {
        head {} // ouch, head() is defined in html's scope, but also visible here
    }
}
----

To avoid this problem, Kotlin provides a mechanism for scope control:

* Define a custom annotation
* Annotate this annotation with `@DslMarker`
* Mark all involved receiver classes (or a common super class) with your annotation
* Now, you can't directly access elements from the outer scope. You still can refer them indirectly, e.g. using the syntax `this@html.head{...}`

In our example, such an annotation could look like this:

[source,kotlin]
----
@DslMarker
annotation class HtmlMarker
----

When the receiver classes of the lambda arguments of the `head()` and `body()` functions are annotated with `@HtmlMarker`, the example above wouldn't compile any longer.

==== Extension properties (((Extension Property)))

You can not only define extension functions and lambdas, but also extension properties. Generally, they aren't used nearly as much as extension functions, but they can help to beautify DSLs, as they don't require to write empty parentheses. In the following example, we want to create a custom `Amount` class by adding extension properties for the different currencies to `Double`:

[source,kotlin]
----
data class Amount(val value: BigDecimal, val currency: String)

val Double.USD
    get() = Amount(this.toBigDecimal(), "USD")

val Double.EUR
    get() = Amount(this.toBigDecimal(), "EUR")

val usdAmount: Amount = 22.46.USD

val eurAmount: Amount = 17.11.EUR
----

With an extension function, the best syntax we could achieve is `22.46.USD()`, but the parentheses are no longer needed when using extension properties.

==== Context Receivers (((Context Receivers)))

https://github.com/Kotlin/KEEP/blob/master/proposals/context-receivers.md[Context receivers] are still an experimental feature in Kotlin, so some details could change in the future. We won't use them in this book, but they are an interesting concept, and might turn out very useful for writing DSLs. The basic idea is to get a class providing a certain service into scope:

[source,kotlin]
----
interface EnvironmentContext {
    fun getProperty(name: String): String
}

context(EnvironmentContext)
fun methodWithContext() {
    val userName = getProperty("userName")
    ...
}
----

Here, `methodWithContext()` can access members of the given `EnvironmentContext` class, similar as in an extension function. The difference is that you don't call the method on an instance of the context, it is just available. This also allows to have multiple contexts in scope.

To call `methodWithContext()`, an `EnvironmentContext` implementation must be provided:

[source,kotlin]
----
fun test() {
    val environmentContext = EnvironmentContextImpl()
    with(environmentContext) {
        methodWithContext()
    }
}
----

Context receivers in Kotlin share similarities with extension functions but lean more towards the concept of dependency injection. They come into play when there's a need to incorporate global information within a specific scope while maintaining flexibility to accommodate different versions. By using a context receiver to offer DSL functionality, you gain control over the scope, can influence the general behavior of the DSL and can prevent potential name conflicts.

=== Operator Overloading (((Operator Overloading)))

Kotlin allows operator overloading, but is conservative in the sense that it permits only a fixed set of operators.

NOTE: The boolean operators `&&` and `||`, the access operators `.`, `?.` and `!!`, the (unary) spread operator `*` and the Elvis operator `?:` cannot be overloaded.

Some overloading functions require specific return types. The type `R` is used in the following tables to indicate that there are no such restrictions.

==== Unary Operators (((Unary Operator)))

[cols="1a,2a,3a"]
|===
|Operator |Overwriting Function | Remarks

| `+a` | `fun A.unaryPlus(): R` |
| `-a` | `fun A.unaryMinus(): R` |
| `!a` | `fun A.not(): R` |
| `++a` | `fun A.inc(): A`| Assigns the result to `a` and returns it
| `a++` | `fun A.inc(): A`| Assigns the result to `a` and returns the original value
| `--a` | `fun A.dec(): A`| Assigns the result to `a` and returns it
| `a--` | `fun A.dec(): A`| Assigns the result to `a` and returns the original value
|===

==== Binary Arithmetic Operators (((Binary Operator)))

[cols="1a,2a,3a"]
|===
|Operator |Overwriting Function | Remarks

| `a + b` | `fun A.plus(b: B): R` |
| `a - b` | `fun A.minus(b: B): R` |
| `a * b` | `fun A.times(b: B): R` |
| `a / b` | `fun A.div(b: B): R`|
| `a % b` | `fun A.rem(b: B): R`| Until Kotlin 1.1, `mod` was used, but is now deprecated.
|===

When these operators are defined, `a` is mutable, and left hand side and right hand side have matching types (`B` is a subtype of `A`), they can be also used in the assignments  `+=`, `-=`, `*=`, `/=` and `%=`.

When you don't want the normal binary form, but only the assignment, you can define it explicitly:

[cols="1a,2a,3a"]
|===
|Operator |Overwriting Function | Remarks

| `a += b` | `fun A.plusAssign(b: B): Unit` |
| `a -= b` | `fun A.minusAssign(b: B): Unit` |
| `a *= b` | `fun A.timesAssign(b: B): Unit` |
| `a /= b` | `fun A.divAssign(b: B): Unit`|
| `a %= b` | `fun A.remAssign(b: B): Unit`|
|===

Again, `a` must be mutable, `B` must be a subtype of `A`. Also, the return type for the function must be `Unit`. Having both the binary and the assignment version of an operator in scope leads to an ambiguity error.

==== Range (((Range Operator))) and In Operators (((In Operator)))

[cols="1a,2a,3a"]
|===
|Operator |Overwriting Function | Remarks

| `a .. b` | `fun A.rangeTo(b: B): R` |
| `a ..< b` | `fun A.rangeUntil(b: B): R` | Introduced in Kotlin 1.8, experimental in 1.7.20
| `a in b` | `fun B.contains(a: A): R` | Defines also `!in`.
|===

The `..<` operator is new, and is thought as a replacement for the `until` infix function.

==== Index Access (((Index Access Operator))) and Invoke Operators (((Invoke Operator)))

[cols="1a,2a,3a"]
|===
|Operator |Overwriting Function | Remarks

| `a[b]` | `fun A.get(b: B): R` |
| `a[b, c]` | `fun A.get(b: B, c: C): R` | Or more arguments
| `a[b] = x` | `fun A.set(b: B, x: X): Unit` |
| `a[b, c] = x` | `fun A.set(b: B, c: C, x: X): Unit` | Or more arguments
| `a()` | `fun A.invoke(): R` |
| `a(b)` | `fun A.invoke(b: B): R` |
| `a(b, c)` | `fun A.invoke(b: B, c: C): R` | Or more arguments
|===

Note that the index access operator `[]` requires at least one element, while the invoke operator `()` can be also used without arguments.

==== Equality (((Equality Operator))) and Comparison Operators (((Comparison Operator)))

[cols="1a,2a,3a"]
|===
|Operator |Overwriting Function | Remarks

| `a == b` | `fun equals(b: Any): Boolean` | Must be defined in `class A`. Also defines `!=`.
| `a < b` | `fun A.compareTo(b: B): Int` | Evaluates `a.compareTo(b) < 0`
| `a <{zwsp}= b` | `fun A.compareTo(b: B): Int` | Evaluates `a.compareTo(b) <{zwsp}= 0`
| `a > b` | `fun A.compareTo(b: B): Int` | Evaluates `a.compareTo(b) > 0`
| `a >= b` | `fun A.compareTo(b: B): Int` | Evaluates `a.compareTo(b) >= 0`
|===

==== Overload Responsibly

While overloaded operators can be a powerful tool in designing DSLs, it is important to use them judiciously and with care. While there are many potential applications for overloaded operators, it is important to ensure that there is some clear association or analogy between the operation being performed and the chosen operator.

For example, using the `/` operator to concatenate file paths makes sense, as it is a common path separator. Similarly, using the unary `+` operator to "add" a single value inside a trailing lambda block has become a standard convention. And using `..` instead of `:` may be acceptable due to its visual similarity.

However, at some point overloading operators can become confusing or even counterproductive. For example, using the `!` operator to invert a matrix may be a stretch, as it does not have a clear association with matrix inversion. In general, it is important to avoid being too clever when designing a DSL, as users may not have the same associations or understandings of certain symbols or operators.

One solution is to use meaningful infix functions (((Infix Notation))) with expressive names instead of relying solely on overloaded operators. While this may be less concise, it can make code easier to understand and less prone to confusion. Ultimately, the goal should be to create a DSL that is intuitive and easy to use, without sacrificing clarity or consistency.

[#infix_notation]
=== Infix Notation for Functions (((Infix Notation)))

The infix notation allows names of functions to be used like binary operators. Well-known examples in the Kotlin API include `to` for creating pairs, and `until` and `downTo` for creating ranges.

The respective function must be an extension function with one argument.The receiver becomes the left-hand side and the argument becomes the right-hand side of the operator.Note that you can still use the normal function call syntax. Here is an example for checking preconditions:

[source,kotlin]
----
infix fun <T> T.shouldBe(expected: T) {
    require(this == expected)
}

fun testIfExpected(s: String) {
    s.shouldBe("expected") // normal syntax
    s shouldBe "expected" // infix syntax
}
----

A weakness of the infix notation is that you can't explicitly specify generics. In this case, you can fall back to the normal function call syntax - but users of the DSL might not know this.

As already mentioned, combining infix and backtick notation allows to define at least visually new "operators":

[source,kotlin]
----
infix fun Double.`^`(exponent: Int) = this.pow(exponent)

val result = 1.2 `^` 3
----

[#functionalInterfaces]
=== Functional Interfaces (((Functional Interfaces))) (((SAM))) (((Single Abstract Method)))

Imagine you have an interface for checking strings, with a single abstract function, and you need an anonymous implementation:

[source,kotlin]
----
interface StringCheck {
    fun check(s: String): Boolean
}

val shortStringCheck = object : StringCheck {
    override fun check(s: String) = s.length < 10
}
----

Such code is quite ugly, and way too verbose to expect a DSL user to implement your interface this way. But as the interface has only a single abstract method (abbreviated as "SAM"), it can be written as a functional interface, which allows to use a simplified syntax to implement it anonymously:

[source,kotlin]
----
// note the "fun" keyword
fun interface StringCheck {
    fun check(s: String): Boolean
}

val shortStringCheck = StringCheck { s -> s.length < 10 }
----

The lambda will be automatically translated back to an implementation as shown above (this process is called a "SAM conversion"). I think you agree that this syntax looks much better, making it useful for DSLs.

=== Generics (((Generics)))

Generics are a useful abstraction over concrete types in all kinds of contexts, including DLS design. A specific use case is the implementation of compile time checks. Here is a simple example modelling currencies (similar to the code shown for extension properties):

[source,kotlin]
----
import java.math.BigDecimal

interface Euro
interface BritishPound

data class Currency<T>(val value: BigDecimal)

val Double.EUR
    get() = Currency<Euro>(this.toBigDecimal())

val Double.GBP
    get() = Currency<BritishPound>(this.toBigDecimal())

operator fun <T> Currency<T>.plus(that: Currency<T>) =
    copy(value = this.value + that.value)

val works = 3.1.EUR + 4.5.EUR // 7.6 €
val worksToo = 2.1.GBP + 4.2.GBP // 6.3 £

//this doesn't compile:
//val oops = 3.1.EUR + 4.5.GBP
----

Adding amounts of different currencies together isn't possible, because the definition of `+` ensures that both amounts belong to the same currency. The generic type parameter `T` is called a "phantom type", and this code is a very simple example for type-level programming.

[#typeLevelProgramming]
.Type-level Programming (((Type Level Programming))) and Phantom Types (((Phantom Types)))
****
*Type-level programming* is a programming paradigm where types themselves are used as values that can be manipulated and computed upon at compile-time, rather than just being used to check the correctness of program syntax and logic. In other words, type-level programming involves using types to encode complex computations and algorithms, which are evaluated by the compiler at compile-time instead of runtime. Type-level programming can be used to achieve a wide range of goals, such as improving program performance, reducing runtime errors, and enforcing stronger type constraints.

*Phantom types* are a type-level programming technique where a type is used to encode additional information about the data that it represents, without actually storing any data at runtime. Phantom types are types that have no values, but are used purely for their type-level information. They can be used to enforce stronger type constraints, such as ensuring that only certain operations are performed on certain types of data. This can help to reduce runtime errors and improve the safety of the program.
****

[#reifiedGenerics]
==== Reified Generics (((Generics))) (((Reified Generics)))

Kotlin offers a interesting feature called "reified generics", which helps to overcome Java's type erasure for generics on the JVM in some situations. Type erasure is a JVM technique that allows Java to check generics at compile time, while discarding type information at runtime. In contrast, reified generics in Kotlin make it possible to retain type information at runtime. This means that developers can perform type-safe operations at runtime without having to resort to workarounds or unsafe casts.

[source,kotlin]
----
inline fun <reified T> List<T>.combine(): Unit = when(T::class) {
    Int::class -> (this as List<Int>).sum()
    String::class -> (this as List<String>).fold("", String::plus)
    else -> this.toString()
}.let { println(it) }

fun main() {
    listOf<Int>().combine() // 0
    listOf(1,2,3).combine()  // 6
    listOf("x","y","z").combine() // xyz
    listOf(true, false).combine() // [true, false]
}
----

Note the expression `T::class`, which shouldn't work considering that type erasure eliminates any generic type information at runtime. However, the function is defined as an `inline` function, and the generic parameter `T` is marked as "reified". The details are beyond the scope of this book, but basically the inlining allows the compiler to obtain the generic type information from the place where the inlining is happening, and make it look like as there were no type erasure. It should be noted that inline functions are subjected to some restrictions and vary slightly from normal functions, e.g. regarding their return behavior.

=== Value Classes (((Value Classes)))

Value classes are a feature introduced in Kotlin 1.5 that allow developers to create lightweight, efficient classes that represent simple values. Value classes are designed to be used for values that are frequently used and require little to no additional functionality beyond what is already provided by the underlying data type.

In Kotlin, a value class is defined using the "value" modifier, and must have a single primary constructor with exactly one parameter. The parameter must be a non-nullable type, such as Int, Long, or String. Value classes cannot extend other classes, and they cannot be extended by other classes.

Value classes are optimized for performance, as they are designed to avoid the overhead of creating a full object instance whenever possible. Instead, the value of a value class is typically represented directly in memory or as a primitive type, depending on the underlying data type.

One of the main benefits of value classes is that they can be used to create more expressive and type-safe APIs. For example, a value class representing a specific measurement unit can help to ensure that only valid unit conversions are performed, and can help to catch errors at compile-time rather than runtime.

NOTE: For the JVM backend, a `@JvmInline` annotation is required, which may be no longer needed in the future. Further, the single constructor argument restriction might be dropped as well. This depends on the introduction of https://openjdk.org/projects/valhalla/[Project Valhalla], which aims to introduce value class functionality to Java.

[source,kotlin]
----
@JvmInline
value class Kilometers(val value: Double)

@JvmInline
value class Miles(val value: Double)

fun Kilometers.toMiles() : Miles =
    Miles(this.value * 0.6214)

val marathonInMiles = Kilometers(42.195).toMiles() // Miles(value=26.219973)
----

[#annotations]
=== Annotations (((Annotations)))

You can write whole DSLs using annotations, but more often annotations can support DSLs, e.g. by describing out how certain fields or classes should be handled. They are especially powerful when your DSL shows a certain default behavior, but needs to consider some edge cases or exceptions, like "don't persist this property".

Another useful application for annotations is code generation(((Code Generation))). E.g. the AutoDSL library (((AutoDSL))) uses the information provided via annotations to construct the DSL classes for you.

.Annotation Processors (((Annotation Processors))) (((KSP))) (((kapt))) (((Kotlin Symbol Processing API)))
****
Annotation processors allow to execute custom processor code during the build process, according to the annotations present in the application code. Kotlin features two annotation processors, the older https://kotlinlang.org/docs/kapt.html[kapt], which won't be developed further, and the recommended https://kotlinlang.org/docs/ksp-overview.html[Kotlin Symbol Processing API] (KSP), which will be covered in <<chapter-12.adoc#annotationProcessor,chapter 12>>.
****

[#reflection]
=== Reflection (((Reflection))) (((Kotlin-Reflect)))

Sometimes you need to inspect or deconstruct classes, call unknown methods, react to annotations etc., which can be done using reflection. If you need more than the most basic reflection in Kotlin, you have to import a separate dependency:

[source,kotlin]
.Gradle (.kts)
----
dependencies {
    implementation("org.jetbrains.kotlin:kotlin-reflect:1.8.10")
}
----

[source,xml]
.Maven
----
<dependencies>
  <dependency>
      <groupId>org.jetbrains.kotlin</groupId>
      <artifactId>kotlin-reflect</artifactId>
  </dependency>
</dependencies>
----

Depending on your use case, you might also consider alternatives like https://github.com/Kotlin/kotlinx.reflect.lite[kotlinx.reflect.lite].

=== Conclusion

This chapter provided a concise and high-level overview of numerous Kotlin language features that are relevant from a DSL standpoint. While further details can be explored in the comprehensive Kotlin documentation, this brief tour should have already given you a solid understanding of the extensive toolkit available for building DSLs. Kotlin offers remarkable creative freedom in this domain, empowering you to use your imagination to create powerful and intuitive DSLs.

