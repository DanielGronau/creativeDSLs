== Relevant Language Features
:source-highlighter: rouge
:icons: font

As mentioned in the preface, this book assumes basic Kotlin knowledge from the reader. However, DSLs use other language features, or they use them in other ways than common code. This chapter wants to give a short overview of language features that are relevant for writing DSLs.

=== Backtick Identifiers

Sometimes, you need very descriptive identifiers in a DSL, which shouldn't have to follow the usual rules. Kotlin allows almost arbitrary identifiers, as long as they are enclosed in backticks. For the JVM all characters except `\r\n,.;:\|/[]<>`` are allowed in backtick identifiers.

A typical use case are DSLs for test libraries. While Java limits you to underscores and camelCase, in Kotlin very descriptive names for test function are possible by using the backtick syntax:

[source,kotlin]
----
@Test
fun `check that the slithy toves gyre and gimble in the wabe` {
   ...
}
----

=== Named Arguments and Default Values

Method and constructor arguments can be accessed using their names, which increases the readability especially for longer argument lists. In Java, this behavior is often imitated by using a builder, but in many cases Kotlin's built-in solution is more convenient.

Further, method and constructor arguments can also have default values assigned. Both language features are useful on their own, but together they complement each other very well. A nice example is the autogenerated `copy()` method in data classes:

[source,kotlin]
----
data class Person(val firstName: String, val lastName: String, val age: Int) {
    ...
    // the method is autogenerated, but would look like this:
    fun copy(firstName: String = this.firstName,
             lastName: String = this.lastName,
             age: Int = this.age ) = Person(firstName, lastName, age)
}

val person = Person("John", "Doe", 23)

val happyBirthday = person.copy(age = person.age + 1)
----

As you can see, the values of the current object are set as default values of the new instance, and thanks to the named argument feature one can pinpoint the arguments which must be changed, and leave all others untouched.

=== Trailing Lambda Arguments

If a method expects an argument of a function type, you can use the usual lambda syntax with curly braces when you call it. E.g. you can map a list of strings to their lengths as follows:

[source,kotlin]
----
listOf("one", "two", "three").map({ s -> s.length })
----

However, if such an argument is the last one, you can pull it out of the argument list. And if it is the only one, you also don't have to write the empty parenthesis. That's the usual syntax:

[source,kotlin]
----
listOf("one", "two", "three").map{ s -> s.length }
----

While this syntactic sugar doesn't look very impressive at the first glance, it allows to write very natural looking DSLs for nested structures. Here is an example from the Kotlin documentation:

[source,kotlin]
.https://kotlinlang.org/docs/type-safe-builders.html#how-it-works
----
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
----

=== Varargs

Varargs are already part of Java, and allow to call a method with a variable number of arguments. Kotlin has them too, but made them more safe and more convenient at the same time:

One change is that the syntax is now unambiguous. In Java, there were cases when it wasn't clear whether an array was meant to be a single argument of a vararg, or if its elements should be used. Kotlin introduced the "spread operator" `*`, which makes clear that the elements of an array should be used for the vararg. Also, Kotlin allows to combine arguments from single values and from spread arrays freely, e.g. you can write: `val list = listOf(2, 0, *someArray, 4)`.

In Java a vararg has to be the last argument. Kotlin allows to put them anywhere, even though you might need tu use named arguments in order to avoid ambiguity:

[source,kotlin]
----
fun someMethod(vararg numbers: Int, someString: String) { ... }

someMethod(1, 2, 3, someString = "Hi!")
----

At the first glance, having the choice to put varargs wherever you want doesn't seem to be terribly useful. But there is one use case which makes this feature interesting from a DSL design perspective: You can put a vararg as second to last element before a trailing function argument:

[source,kotlin]
----
fun someMethod(someString: String, vararg numbers: Int, block: () -> Unit) { ... }

someMethod("Hi!", 1, 2, 3) {
    ...
}
----

### Property-Syntax

### Operator-Überladung

...

Der Invoke-Operator kann verwendet werden, um die Syntax eines
Funktionsaufrufs zu simulieren. So können sich z.B. Objekte als
Funktionen "tarnen", aber dabei State speichern:

```kotlin
object count {
    private var n = 1
    operator fun invoke(): Int = n++
}
```

### Inline Funktionen

### Erweiterungs-Funktionen

### Receiver-Funktionen und -Lambdas

### Die @DslMarker-Annotation

## Properties

## Annotationen

## Reflection

