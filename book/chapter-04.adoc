== Relevant Language Features
:srcdir: ../src/main/kotlin/creativeDsls

As mentioned in the preface, this book assumes basic Kotlin knowledge from the reader. However, DSLs use often lesser common language features, or they use features in other ways than common code. This chapter wants to give a short overview of language features that are relevant for writing DSLs.

=== Backtick Identifiers

Sometimes, you need very descriptive identifiers in a DSL, which shouldn't have to follow the usual rules. Kotlin allows almost arbitrary identifiers, as long as they are enclosed in backticks. For the JVM all characters except `\r\n,.;:\|/[]<>`` are allowed in backtick identifiers.

A typical use case are DSLs for test libraries. While Java limits you to underscores and camelCase, in Kotlin very descriptive names for test function are possible by using the backtick syntax:

[source,kotlin]
----
@Test
fun `check that the slithy toves gyre and gimble in the wabe` {
   ...
}
----

=== Named Arguments and Default Values

Method and constructor arguments can be accessed using their names, which increases the readability especially for longer argument lists. In Java, this behavior is often imitated by using a builder, but in many cases Kotlin's built-in solution is more convenient.

Further, method and constructor arguments can also have default values assigned. Both language features are useful on their own, but together they complement each other very well. A nice example is the autogenerated `copy()` method in data classes:

[source,kotlin]
----
data class Person(val firstName: String, val lastName: String, val age: Int) {
    // the method is autogenerated, but would look like this:
    fun copy(firstName: String = this.firstName,
             lastName: String = this.lastName,
             age: Int = this.age ) = Person(firstName, lastName, age)
}

val person = Person("John", "Doe", 23)

val happyBirthday = person.copy(age = person.age + 1)
----

As you can see, the values of the current object are set as default values of the new instance, and thanks to the named argument feature one can pick the arguments which must be changed, and leave all others untouched.

=== Trailing Lambda Arguments

If a method expects an argument of a function type, you can use the usual lambda syntax with curly braces when you call it. E.g. you can merge a list of strings using then `fold()` method as follows:

[source,kotlin]
----
listOf("one", "two", "three").fold("", { s, t -> s + t })
----

However, if such an argument is the last one, you can "pull it out" of the argument list:

[source,kotlin]
----
listOf("one", "two", "three").fold("") {
   s, t -> s + t
}
----

And if it is the only argument, you don't have to write the empty parenthesis. The `map()` method is an example for a method with a single function argument:

[source,kotlin]
----
listOf("one", "two", "three").map {
    s -> s.length
}
----

While this syntactic sugar doesn't look very impressive at the first glance, it allows to write very natural looking DSLs for nested structures. Here is an example from the Kotlin documentation:

[source,kotlin]
.https://kotlinlang.org/docs/type-safe-builders.html#how-it-works
----
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
----

=== Varargs

Varargs are already part of Java, and allow to call a method with a variable number of arguments. Kotlin has them too, but made them more safe and convenient:

One change is that the syntax is now unambiguous. In Java, there were cases when it wasn't clear whether an array was meant to be a single argument of a vararg, or if its elements should be used as arguments. Kotlin introduced the "spread operator" `*`, which makes clear that the elements of an array should be used for the vararg. Also, Kotlin allows to combine arguments from single values and from spread arrays freely, e.g. you can write: `val list = listOf(2, 0, *someArray, 4)`.

==== Vararg Position

In Java a vararg has to be the last argument. Kotlin allows to put the vararg anywhere, even though you might have to use named arguments in order to avoid ambiguity:

[source,kotlin]
----
fun someMethod(vararg numbers: Int, someString: String) { ... }

someMethod(1, 2, 3, someString = "Hi!")
----

==== Varargs and Trailing Lambda Syntax

At the first glance, having the choice to put varargs wherever you want doesn't seem to be terribly useful. But there is one use case which makes this feature interesting from a DSL design perspective: You can put a vararg as second to last element before a trailing lambda argument:

[source,kotlin]
----
fun someMethod(someString: String, vararg numbers: Int, block: () -> Unit) { ... }

someMethod("Hi!", 1, 2, 3) {
    ...
}
----

As you can see, you don't need named arguments for clarification in this case.

=== Property-Syntax

Kotlin allows to control how properties are read and written. This makes it easy to hide DSL functionality in plain sight. An easy example is checking preconditions:

[source,kotlin]
----
class TemperatureSensor {
    var celsius: Double = 0.0
        set(value) {
            if(value < -273.15) {
                throw IllegalArgumentException("Temperature is under absolute zero.")
            }
            field = value
       }
   ...
}
----

Later in the extensions section we'll discuss another use of the property syntax.

=== Operator Overloading

Kotlin allows operator overloading, but is quite conservative in the sense that it permits only a fixed and quite limited set of operators:

* the unary operators `+`, `-` and `!`
* the binary arithmetic operators `+`, `-`, `*`, `/` and `%`
* the augmented assignments for these: `+=`, `-=`, `*=`, `/=` and `%=`
* the range operator `..`
* the in operator `in`
* the index access operator `[]`
* the invoke operator `()`
* the equality operators `==` and `!=`
* the comparison operators `<`, `<{zwsp}=`, `>`, `>=`

Note that the boolean operators `&&` and `||` cannot be overloaded.

There are many use cases for operators, but please don't overuse them. There should be at least some association or analogy between the operation and the chosen operator. E.g. for concatenating a path, `/` would be fine, as it is a common path separator. If you want to "add" a single value to a block in some sense, using the unary `+` has become a kind of standard. It might be also okay to use `..` instead of a `:`, because of the visual similarity.

But at some point you need to draw a line, e.g. inverting a matrix by using `!` would be in my opinion a bit of a stretch. Also, it can be confusing when you reuse an operator too often, like "adding" an address, phone number, email or website to a person. Often it is better to use an infix function with a meaningful name instead of letting the users guess what an operator could mean.

That said, you can do some sneaky things with operators. E.g. the invoke operator can be used to simulate the syntax of a function call, so you can e.g. camouflage objects to look like functions. Similarly, the index access operator can be used to mimic e.g. arrays and maps.

=== Extensions

One of the most important features for DSL design are functions and lambdas with receivers. This can be understood as putting the function body in the scope of the receiver, so you can access its public fields, methods etc., and also refer to the receiver itself using `this`. In case of extension functions, the call looks like a normal method call on a receiver instance.

==== Type narrowing

Interestingly, generic extension functions have a capability that normal instance methods haven't: They can "fix" generic parameters to a certain type, narrowing down the range of possible receivers. Here is an example for calculating the product of numbers as an extension function for a list:

[source,kotlin]
----
include::{srcdir}/chapter_04/productSnippet.kt[lines=3..]
----

The call to `Double::times` is only possible because the receiver is not just any list, but specifically a `List<Double>`, and this additional type information is also applied to the function body. This feature of extension methods can be used in DSLs e.g. for performing compile-time checks.

==== Loan Pattern

****
The idea of the Loan Pattern is to hide construction and disposal of an instance (often a resource) from client code. The caller gets only access to the already initialized instance, and isn't responsible for things like closing connections at the end.
****

Lambdas can have receivers too, and this plays nicely with the Loan Pattern. This is very useful for DSLs, because it helps to control the life-cycle of the receiver class. Take this example:

[source,kotlin]
----
include::{srcdir}/chapter_04/stringBuilderSnippet.kt[lines=3..]
----

This may look a little confusing at first, but the main point is that you can use extension methods to create a block where `this` is a certain receiver class (here `StringBuilder`), and you don't have to care about its construction or final steps (like calling a `build()` - or here `toString()` - method).

Building DSLs based on this feature is very common, as it has several advantages over the classic Builder Pattern.

==== The @DslMarker annotation

There is a scope problem when you nest several extension functions: Things visible in the outer blocks are also visible in the inner ones. E.g. in a DSL for HTML generation, one could write:

[source,kotlin]
----
html {
    head {...}
    body {
        head {} // ouch, head() is defined in html's scope, but also visible here
    }
}
----

To avoid this problem, there is a mechanism for scope control:

* Define a custom annotation
* Annotate this annotation with `@DslMarker`
* Mark all involved receiver classes (or a common super class) with your annotation
* After this, you can't directly access things from the outer scope. You still can refer them indirectly, like with `this@html.head{...}`

==== Extension properties

You can not only define extension functions and lambdas, but also extension properties. Generally, they aren't used nearly as much as extension functions, but they can help to make DSLs prettier, as they don't require to write empty parentheses:

[source,kotlin]
----
include::{srcdir}/chapter_04/amountSnippet.kt[lines=5..]
----

The infix notation covered in the next paragraph uses extension function syntax as well.

=== Infix Notation for Functions

The infix notation allows names of functions to be used like binary operators. Well-known examples in the Kotlin API include `to` for creating pairs, and `until` and `downTo` for creating ranges.

The function must be a receiver function, and have one argument. The receiver-`this` becomes the left-hand side, and the argument becomes the right-hand side of the operator. Note that you can still use the normal function call syntax. Here is an example for checking preconditions:

[source,kotlin]
----
include::{srcdir}/chapter_04/shouldBeSnippet.kt[lines=3..]
----

A weakness of the infix notation is that you can't explicitly specify generics using this syntax. In this case, you can fall back to the normal function call syntax - but users of the DSL might not know this.

=== Generics

Generics are a useful abstraction over concrete types in all kinds of contexts, including DLS design. A specific use case is the implementation of compile time checks. Here is a simple example modelling currencies:

[source,kotlin]
----
include::{srcdir}/chapter_04/currencySnippet.kt[lines=5..]
----

The `Amount` class holds the `currency` field, which could be used for runtime checks. But with generics, we can do better: Adding amounts of different currencies together isn't possible, because the definition of `+` ensures that both amounts have the same currency type.

.Type-level Programming and Phantom Types
****
Type-level programming is a technique, where the compiler is used to perform checks or even calculations, which gives more control over the behavior of the affected classes. That includes restricting unwanted operations, or a more flexible behavior of the type system.

A type parameter which doesn't relate to any field, argument, etc. of its  class is called a "phantom type", and is commonly used for type-level programming.
****

==== Reified Generics

One great feature of Kotlin is reified generics. The JVM implements generics using "type erasure", which means that (while the compiler checks them and even adds type casts and auxiliary methods) at runtime the JVM basically "forgets" them. In Kotlin, you can access that type information under certain circumstances:

[source,kotlin]
----
include::{srcdir}/chapter_04/reifiedSnippet.kt[lines=3..]
----

Note the expression `T::class`, which shouldn't work considering type erasure. However, the function is defined as an `inline` function, and the generic parameter `T` is marked as "reified". The details are beyond the scope of this book, but basically the inlining allows the compiler to gather the generic type information already at compile time, and make it look like as there is no type erasure happening. It should be noted that inline functions are subjected to some restrictions, and show differences to "normal" functions regarding their return behavior.

[#annotations]
=== Annotations

You can write whole DSLs using annotations, but more often annotations can support DSLs, e.g. by pointing out how certain fields or classes should be handled. They are especially powerful when your DSL shows a certain default behavior, but needs to consider some edge cases or exceptions, like "don't persist this property".

Another useful application for annotations is code generation.E.g. the already mentioned AutoDSL library uses the information provided via annotations to construct the DSL classes for you.

.Annotation Processors
****
Annotation processors allow to execute custom processor code during the build process, according to the annotations present in the application code. Kotlin features two annotation processors, the older https://kotlinlang.org/docs/kapt.html[kapt], which won't be developed further, and the recommended https://kotlinlang.org/docs/ksp-overview.html[Kotlin Symbol Processing API] (KSP). While the topic is beyond the scope of this book, it might be a good idea to get familiar with this concept, especially when developing annotation-based DSLs.
****

[#reflection]
=== Reflection

Sometimes you need to inspect or deconstruct classes, call unknown methods, react to annotations etc., which can be done using reflection. If you need more than the most basic reflection in Kotlin, you have to import a separate dependency:

[source,kotlin]
.Gradle (.kts)
----
dependencies {
    implementation("org.jetbrains.kotlin:kotlin-reflect:1.7.10")
}
----

[source,xml]
.Maven
----
<dependencies>
  <dependency>
      <groupId>org.jetbrains.kotlin</groupId>
      <artifactId>kotlin-reflect</artifactId>
  </dependency>
</dependencies>
----

Depending on your use case, you might also consider alternatives like https://github.com/Kotlin/kotlinx.reflect.lite[kotlinx.reflect.lite].