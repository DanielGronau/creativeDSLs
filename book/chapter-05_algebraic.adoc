== Algebraic DSLs

A common class of problems deals with objects that exhibit numeric-like behavior. These "algebraic" structures include complex numbers, quaternions, vectors, matrices, physical and monetary quantities, and many more. With Kotlin, it is relatively easy to write DSLs for these problems, especially when the required operators match with the existing ones.

NOTE: As for many other categories of DSLs, there seems to be no established name for this kind of DSL in the literature. I think calling them _Algebraic DSLs_ covers their behavior quite well, but you might find the same concept under different names elsewhere.

The Kotlin API itself contains some nice examples for small Algebraic DSLs, e.g. for `BigInteger` and `BigDecimal`, which can be used pretty much like "normal" numbers.

Even if your problem domain does not possess an inherent algebraic structure, the concepts and ideas presented in this chapter can still be partially applicable. Consider chemical equations as an example: While their components may not be inherently number-like, they do involve operations such as "addition" of molecules and scalar multiplication by coefficients. This demonstrates the versatility and flexibility of algebraic DSLs, as they can be adapted and utilized in various domains beyond traditional numeric applications.

=== Case Study: A DSL for Complex Numbers

In order to keep things realistic, we will use an existing implementation, that you could find in a production environment. We will use the https://github.com/apache/commons-numbers/tree/master/commons-numbers-complex[Apache Commons Numbers: Complex] library, which is written in Java. The implementation behaves pretty much as expected:

[source,kotlin]
----
val a = Complex.ofCartesian(3.0, 4.0)
val b = Complex.ofCartesian(5.0, 6.0)
val c = a.add(b) // 8 + 10i
val d = a.times(b) // -9 + 38i
val e = a.pow(b) // -1.860 + 11.837i
----

There are some static factory methods to create `Complex` objects, like `Complex.ofCartesian()` or `Complex.ofPolar()`, and then you can use some methods like `add()` and `times()` on these objects.

If we follow the steps from chapter 3, we should now come up with an ideal syntax. This is easy, as in mathematics we would simply write `3.0 + 4.0i` instead of `Complex.ofCartesian(3.0, 4.0)`. I think it is acceptable to have no special syntax for other ways to initialize complex numbers, like the polar definition.

When we consider that `4.0i` is actually a multiplication, we are already there: A syntax like `3.0 + 4.0*i` can be implemented in Kotlin.

First, we need to define the imaginary unit `i` with `val i = Complex.I`. This is a bit risky because of possible name clashes, so it would be also an option to import `Complex.I` instead.

Next, the arithmetic operations can be written using operator overloading. We need not only operations between two `Complex` instances, but also between `Complex` and `Double`. Here is an example for addition:

[source,kotlin]
----
operator fun Complex.plus(that: Complex): Complex = this.add(that)
operator fun Complex.plus(that: Double): Complex = this.add(that)
operator fun Double.plus(that: Complex): Complex =
    Complex.ofCartesian(this, 0.0).add(that)
----

The other operations look basically the same. We could also support interoperability with `Int` in addition to `Double`, but it was omitted for the sake of brevity. A little improvement would be a helper method for the conversion from double to complex, instead of relying on the awkward `Complex.ofCartesian` factory.

Next, we need also to support negation of complex numbers (and maybe the unary plus, too, for symmetry reasons). This looks very similar to the code above:

[source,kotlin]
----
operator fun Complex.unaryMinus(): Complex = this.negate()
----

When you can't find an appropriate operator to overload, you can use infix functions instead. In our example, we could define `pow` as exponentiation operation, so we can write e.g. `3.0 + 4.0*i pow 3.0`. The infix operations have lower priority than the overloaded operators, so the example calculation would be interpreted as `(3.0 + 4.0*i) pow 3.0`. Note that the infix extension function can have the same name and arguments as an existing function (here `Complex.pow()`), but in this case it will be only called when using infix notation, else the original method will be called.

[source,kotlin]
----
infix fun Complex.pow(that: Complex): Complex = pow(that)
infix fun Complex.pow(that: Double): Complex = pow(that)
----

Alternatively, we could have used `{backtick}^{backtick}` in <<chapter-04_features.adoc#backtickIdentifiers, backtick notation>>(((Backtick Notation))), which may be more readable than `pow`, but is harder to type.

And that's already it, we have a basic DSL for complex numbers. Here is the complete code:

[source,kotlin]
----
import org.apache.commons.numbers.complex.Complex

val i = Complex.I

operator fun Complex.unaryPlus() = this

operator fun Complex.unaryMinus() = this.negate()

operator fun Complex.plus(that: Complex) = add(that)
operator fun Complex.plus(that: Double) = add(that)
operator fun Double.plus(that: Complex) = fromDouble(this).add(that)

operator fun Complex.minus(that: Complex) = subtract(that)
operator fun Complex.minus(that: Double) = subtract(that)
operator fun Double.minus(that: Complex) = fromDouble(this).subtract(that)

operator fun Complex.times(that: Complex) = multiply(that)
operator fun Complex.times(that: Double) = multiply(that)
operator fun Double.times(that: Complex) = fromDouble(this).multiply(that)

operator fun Complex.div(that: Complex) = divide(that)
operator fun Complex.div(that: Double) = divide(that)
operator fun Double.div(that: Complex) = fromDouble(this).divide(that)

infix fun Complex.pow(that: Complex) = pow(that)
infix fun Complex.pow(that: Double) = pow(that)

private fun fromDouble(d: Double) = Complex.ofCartesian(d, 0.0)
----

Now our usage example can be written as:
[source,kotlin]
----
val a = 3.0 + 4.0*i
val b = 5.0 + 6.0*i
val c = a + b
val d = a * b
val e = a pow b
----

Using complex numbers feels now as intuitive as using one of the built-in numeric types.

=== Case Study: Modular Arithmetic - Dealing with a Context

Imagine you're faced with large modular arithmetic calculations. Often, simply calculating the modulo after an operation isn't enough. Certain operations, such as division, differ significantly from standard arithmetic. In addition, neglecting to optimize operations such as multiplication and exponentiation can result not only in slower performance, but also in arithmetic overflows.

To address this problem, you decide to create a DSL tailored to modular arithmetic. However, a problem arises: where do you specify the modulus for these calculations? A global variable would be a precarious and unsafe solution. Embedding the modulus in each operand proves tedious and raises the question of how to handle operands with different moduli in one operation.

A common solution would be to define a class that holds the modulus, and make the parts of the DSL members of that class, so that they all have access to the modulus information:

[source,kotlin]
----
data class Modulus(val modulus: Long) {
    init {
        require(modulus > 1)
    }

    @JvmInline
    value class Modular(val n: Long)

    val Long.m
        get() = Modular(remainder(this))

    val Int.m
        get() = Modular(remainder(this.toLong()))

    operator fun Modular.plus(that: Modular) =
        Modular(remainder(this.n + that.n))

    operator fun Modular.minus(that: Modular) =
        Modular(remainder(this.n - that.n))

    operator fun Modular.times(that: Modular) =
        Modular(remainder(this.n * that.n))

    operator fun Modular.div(that: Modular) =
        Modular(remainder(this.n * inverse(that.n)))

    private fun remainder(n: Long) = when {
        n < 0 -> (n % modulus) + modulus
        else -> n % modulus
    }

    private data class GcdResult(val gcd: Long, val x: Long, val y: Long)

    private fun inverse(a: Long): Long =
        extendedGCD(a, modulus)
            .run {
                when (gcd) {
                    1L -> remainder(x)
                    else -> throw ArithmeticException(
                        "Can't divide by $a (mod $modulus)"
                    )
                }
            }

    private fun extendedGCD(a: Long, b: Long): GcdResult =
        when (b) {
            0L -> GcdResult(a, 1, 0)
            else -> {
                val result = extendedGCD(b, a % b)
                val x = result.y
                val y = result.x - (a / b) * result.y
                GcdResult(result.gcd, x, y)
            }
        }
}
----

As mentioned above, the division operation requires some arithmetic effort, but otherwise the example is straightforward. One way to use this DSL is to bring the `Modulus` class into scope using the `with()` function:

[source,kotlin]
----
with(Modulus(7)) {
    println(3.m + 5.m) // Modular(n=1)
    println(3.m - 5.m) // Modular(n=5)
    println(3.m * 5.m) // Modular(n=1)
    println(3.m / 5.m) // Modular(n=2)
}
with(Modulus(10)) {
    println(3.m + 5.m) // Modular(n=8)
    println(3.m - 5.m) // Modular(n=8)
    println(3.m * 5.m) // Modular(n=5)
    println(3.m / 5.m) // throws exception "Can't divide by 5 (mod 10)"
    println(3.m / 7.m) // Modular(n=9)
}
----

While this solution functions, its scalability is limited since the entire DSL is confined within a class. Although you could alleviate this by transforming some functions into extension functions to streamline the class, the operators must remain within the class. This constraint is due to the fact that the operators are already extension functions and can only have one receiver, namely their first operand. Another challenge emerges when the DSL requires multiple unrelated information sources, compelling them to be conflated into a single class. In essence, these issues stem from the DSL becoming strongly coupled with its enclosing class.

For those daring enough to delve into an experimental language feature, <<chapter-04_features.adoc#contextReceivers, Context Receivers>>(((Context Receivers))) were specifically designed to address scenarios like these by enabling a more flexible separation between the context scope and its consumers. Here is a rewritten version of the DSL above:

[source,kotlin]
----
data class Modulus(val modulus: Long) {
    init {
        require(modulus > 1)
    }
}

@JvmInline
value class Modular(val n: Long)

context(Modulus)
val Long.m
    get() = Modular(remainder(this))

context(Modulus)
val Int.m
    get() = Modular(remainder(this.toLong()))

context(Modulus)
operator fun Modular.plus(that: Modular) = Modular(remainder(this.n + that.n))

context(Modulus)
operator fun Modular.minus(that: Modular) = Modular(remainder(this.n - that.n))

context(Modulus)
operator fun Modular.times(that: Modular) = Modular(remainder(this.n * that.n))

context(Modulus)
operator fun Modular.div(that: Modular) = Modular(remainder(this.n * inverse(that.n)))

context (Modulus)
private fun remainder(n: Long) = when {
    n < 0 -> (n % modulus) + modulus
    else -> n % modulus
}

private data class GcdResult(val gcd: Long, val x: Long, val y: Long)

context(Modulus)
private fun inverse(a: Long): Long =
    extendedGCD(a, modulus)
        .run {
            when (gcd) {
                1L -> remainder(x)
                else -> throw ArithmeticException(
                    "Can't divide by $a (mod $modulus)"
                )
            }
        }

private fun extendedGCD(a: Long, b: Long): GcdResult =
    when (b) {
        0L -> GcdResult(a, 1, 0)
        else -> {
            val result = extendedGCD(b, a % b)
            val x = result.y
            val y = result.x - (a / b) * result.y
            GcdResult(result.gcd, x, y)
        }
    }
----

The usage pattern hasn't changed, you can use `with()` in exactly the same way to provide the `Modulus` instance. Furthermore, you can easily write new functions that "inherit" an existing scope:

[source,kotlin]
----
context(Modulus)
fun square(n: Modular) = n * n

...

with(Modulus(7)) {
    val x = square(3.m + 5.m) + square(3.m - 5.m)
    println(x) // Modular(n=2)
}
----

In my opinion, context receivers provide an elegant solution in situations where algebraic DSLs need additional information from the environment.

=== Java Interoperability

Java doesn't allow operator overloading, and extension methods become just normal static methods with the receiver as the first argument. That means that our DSL definitely looks no longer elegant in Java. Given that in our case the underlying Apache Commons Numbers library itself is written in Java, we are probably better off using their methods.

However, our DSL is still working, and is quite straightforward to use, when you know how the operators translate to method names: Instead of `val a = 3.0 + 4.0*i`, you would have to write `Complex a = plus(3.0, times(4.0, getI()));` in a Java class.

=== Conclusion

The case studies presented in this chapter serve to illustrate that creating algebraic DSLs is usually not that difficult. However, it is important to consider certain factors when deciding whether to employ an algebraic DSL. While algebraic notation can be powerful and expressive, it may not always be suitable for every use case. For instance, using algebraic notation for sum and product types, such as `Either` and tuples like `Pair` and `Triple`, might be unconventional and potentially confusing to some users, despite the underlying algebraic structure. Additionally, certain behaviors, like non-commutative multiplication found in quaternions and matrices, can introduce unexpected complexities and increase the likelihood of usage errors. Therefore, it is crucial to exercise good judgment and adhere to the _Principle of Least Surprise_ (((Principle of Least Surprise))) when designing algebraic DSLs, rather than simply adopting them because of their ease of implementation.

==== Preferable Use Cases

* Define operations

==== Rating

* image:5_sun.png[] - for Simplicity of DSL design
* image:5_sun.png[] - for Elegance
* image:5_sun.png[] - for Usability
* image:2_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* easy to write
* intuitive to use
* can use infix functions when no operator fits

|* possible name clashes with other DSLs
* operator precedence can't be changed
* difficult to use from Java client code
|===
