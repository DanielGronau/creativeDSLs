== Loan Pattern DSLs (((Loan Pattern DSL)))

> Neither a borrower nor a lender be, +
For loan oft loses both itself and friend, +
And borrowing dulls the edge of husbandry.
-- Shakespeare, Hamlet, Act 1, Scene 3

This pattern is known by several different names, one of which is "builder pattern". This can be particularly confusing because it is similar to, and often used instead of, the classic builder pattern discussed in the last chapter. Another commonly used term is "lambdas with receivers"(((Lambda with Receiver))), but I would argue that this describes an implementation detail rather than the underlying idea. To avoid confusion, and to provide a more accurate description of the underlying mechanism, it will be referred to here as the "Loan Pattern DSL".

The Loan Pattern DSL uses a mutable builder class that exposes its members through the Loan Pattern. This approach leverages the power of extension methods and trailing lambda syntax in Kotlin. It is particularly useful for creating deeply nested structures. In such cases, the code can quickly become cluttered and hard to read when using the classic builder pattern. It can also be easier to enforce constraints and ensure type safety with this approach compared to using builders. Sometimes the greater flexibility of Loan Pattern DSLs allows other DSL techniques to be incorporated, while the builder approach is often too rigid for such improvements. That's why it's often used as a scaffolding for hybrid DSLs, as will be discussed in <<chapter-11_hybrid.adoc#hybrid_dsls,Chapter 11>>.

In this chapter, we will first write a more convenient replacement for the `HttpRequest.Builder` introduced in the last chapter. If you have control over the business classes you want to construct, you can use libraries like AutoDSL to generate a DSL for you. We will explore this in the second part of this chapter.

=== Case Study: HttpRequest DSL

As discussed in the last chapter, `HttpRequest` already comes with a builder that looks like this:

[source,kotlin]
----
val request = HttpRequest
    .newBuilder(URI.create("https://acme.com:9876/products"))
    .GET()
    .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
    .header("Accept-Encoding", "gzip, deflate")
    .timeout(Duration.ofSeconds(5L))
    .build()
----

This doesn't look too bad, but there is some noise in the form of the `newBuilder()` and `build()` calls, and the other method calls are actually assignments in disguise. The question is how to improve this in Kotlin. Here is a suggestion for an improved syntax:

[source,kotlin]
----
val request = httpRequest("https://acme.com:9876/products") {
    method = GET
    headers {
        "Content-Type" .. "application/x-www-form-urlencoded; charset=UTF-8"
        "Accept-Encoding" .. "gzip, deflate"
    }
    timeout = 5 * SECONDS
}
----

There are no more `newBuilder()` and `build()` calls, the assignments are really assignments, headers have their own subsection, and durations can be calculated. For convenience, you can choose to specify the web address as either a string or a URI (the example shows the `String` version).

As you might have guessed, `httpRequest` is a method that uses the loan pattern: It initializes a builder class, exposes it as a receiver, and takes care of the final `build()` call. Also note how it takes care of a mandatory field (in our case, the address) by requiring it as an explicit argument. We have two versions of the function, depending on how the address is specified:

[source,kotlin]
----
fun httpRequest(uri: URI, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(uri).apply(block).build()

fun httpRequest(address: String, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(URI.create(address)).apply(block).build()
----

The builder contains some mutable fields, and a `build()`-Method to construct the `HttpRequest`:

[source,kotlin]
----
typealias HttpMethod = Pair<String, BodyPublisher?>

class HttpRequestBuilder(var uri: URI) {

    var method: HttpMethod? = null
    var timeout: Duration? = null
    var expectContinue: Boolean? = null
    var version: HttpClient.Version? = null
    private val headers = mutableMapOf<String, String>()

    ...

    fun build(): HttpRequest =
        with(HttpRequest.newBuilder(uri)) {
            // set the values
            // ...
            this.build()
        }

    ...
}
----

The `headers` field can't be set directly, because we want to use a nested structure here. The `headers()` method works analogous to the `httpRequest()` method, and exposes the inner `Headers` class, which in turn allows the `headers` field to be populated. The `..` range operator was chosen to collect the key-value pairs because it looks a bit like `:`. We don't want to expose all of the `HttpRequestBuilder` fields in its inner `Headers` class, so we use the `@DslMarker` (((@DslMarker))) mechanism that we had discussed in <<chapter-04_features.adoc#dslMarker,Chapter 4>> to limit the scope within `Headers`.

[source,kotlin]
----
@DslMarker
annotation class HttpRequestDsl

@HttpRequestDsl
class HttpRequestBuilder(var uri: URI) {
    ...
    private val headers = mutableMapOf<String, String>()
    ...
    fun headers(block: Headers.() -> Unit) {
        Headers().apply(block)
    }
    ...
    @HttpRequestDsl
    inner class Headers {
        operator fun String.rangeTo(value: String) {
            this@HttpRequestBuilder.headers[this@rangeTo] = value
        }
    }
   ...
}
----

Next, some fields and methods are required to assist in setting the HTTP method. However, you can still define your own, e.g. `method = "OPTION" to someBodyPublisher`:

[source,kotlin]
----
typealias HttpMethod = Pair<String, BodyPublisher?>

class HttpRequestBuilder(var uri: URI) {

    var method: HttpMethod? = null
    ...
    val GET: HttpMethod = "GET" to null
    val DELETE: HttpMethod = "DELETE" to null
    fun PUT(bp: BodyPublisher): HttpMethod = "PUT" to bp
    fun POST(bp: BodyPublisher): HttpMethod = "POST" to bp
    ...
}
----

Some operator overloading functions help to specify a `Duration` in a more natural way. Note that these are only visible within `HttpRequestBuilder`, so naming conflicts can be avoided.

[source,kotlin]
----
class HttpRequestBuilder(var uri: URI) {
    ...
    operator fun Long.times(unit: TemporalUnit): Duration =
        Duration.of(this, unit)

    operator fun Int.times(unit: TemporalUnit): Duration =
        Duration.of(this.toLong(), unit)
}
----

And that's almost it, we covered everything except some details of the `build()` method. Here is the complete code:

[source,kotlin]
----
fun httpRequest(uri: URI, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(uri).apply(block).build()

fun httpRequest(uri: String, block: HttpRequestBuilder.() -> Unit) =
    HttpRequestBuilder(URI.create(uri)).apply(block).build()

typealias HttpMethod = Pair<String, BodyPublisher?>

@DslMarker
annotation class HttpRequestDsl

@HttpRequestDsl
class HttpRequestBuilder(var uri: URI) {

    var method: HttpMethod? = null
    var timeout: Duration? = null
    var expectContinue: Boolean? = null
    var version: HttpClient.Version? = null
    private val headers = mutableMapOf<String, String>()

    val GET: HttpMethod = "GET" to null
    val DELETE: HttpMethod = "DELETE" to null
    fun PUT(bp: BodyPublisher): HttpMethod = "PUT" to bp
    fun POST(bp: BodyPublisher): HttpMethod = "POST" to bp

    fun headers(block: Headers.() -> Unit) {
        Headers().apply(block)
    }

    fun build(): HttpRequest =
        with(HttpRequest.newBuilder(uri)) {
            headers.forEach { (key, value) -> header(key, value) }
            timeout?.let { timeout(it) }
            expectContinue?.let { expectContinue(it) }
            version?.let { version(it) }
            method?.let {
                when (method) {
                    GET -> GET()
                    DELETE -> DELETE()
                    else -> method(method!!.first, method!!.second)
                }
            }
            this.build()
        }

    @HttpRequestDsl
    inner class Headers {
        operator fun String.rangeTo(value: String) {
            this@HttpRequestBuilder.headers[this@rangeTo] = value
        }
    }

    operator fun Long.times(unit: TemporalUnit): Duration =
        Duration.of(this, unit)

    operator fun Int.times(unit: TemporalUnit): Duration =
        Duration.of(this.toLong(), unit)
}
----

Retrofitting HttpRequestBuilder with a Loan Pattern DSL proved to be a relatively simple task, but the resulting DSL is convenient and idiomatic. By customizing existing libraries in this way, especially those written in Java, it becomes easier to meet user needs and integrate them more seamlessly into the Kotlin ecosystem.

=== Case Study: HttpRequest with AutoDSL (((AutoDSL)))

Since this type of DSL is very common, and its structure is quite predictable, it shouldn't be surprising that there are libraries for automatically deriving such DSLs. At this point we will discuss the https://github.com/F43nd1r/autodsl[AutoDSL]footnote:[AutoDSL: https://github.com/F43nd1r/autodsl] library, which has to be set up as an annotation processor (either via kapt (((kapt))) or (((KSP))) (((Kotlin Symbol Processing API))) KSP). Please follow the description on the GitHub project page.

WARNING: Please make sure you are using the correct GitHub project. There is an older library called "AutoDsl" which was the inspiration for this project. Unfortunately, it is no longer maintained and does not work with Kotlin 1.4 or newer.

Remember the work we put into `HttpRequestBuilder` in the last section? Let's see what we can get "for free" instead. Note that we can't annotate the `HttpRequest` class itself, so we automatically generate an intermediate class instead, and therefore we have to call the `build()` method at the end. Normally, we wouldn't do this for classes under our control, but would annotate them directly.

[source,kotlin]
----
typealias HttpMethod = Pair<String, HttpRequest.BodyPublisher?>

val GET: HttpMethod = "GET" to null
val DELETE: HttpMethod = "DELETE" to null
fun PUT(bp: HttpRequest.BodyPublisher): HttpMethod = "PUT" to bp
fun POST(bp: HttpRequest.BodyPublisher): HttpMethod = "POST" to bp

@AutoDsl
data class Header(val key: String, val value: String)

@AutoDsl
data class HttpRequestBuilder(
    val uri: URI,
    val method: HttpMethod = GET,
    val timeout: Duration? = null,
    val expectContinue: Boolean? = null,
    val version: HttpClient.Version? = null,
    @AutoDslSingular("header")
    val headers: List<Header> = listOf()
) {

    fun build(): HttpRequest =
        with(HttpRequest.newBuilder(uri)) {
            headers.forEach { (key, value) -> header(key, value) }
            timeout?.let { timeout(it) }
            expectContinue?.let { expectContinue(it) }
            version?.let { version(it) }
            method.let {
                when (method) {
                    GET -> GET()
                    DELETE -> DELETE()
                    else -> method(method.first, method.second)
                }
            }
            this.build()
        }
}
----

It doesn't get much easier than that: All classes that should be included in the DSL are marked with the `@AutoDsl` annotation, and if there are lists that should be specified element-wise rather than as a whole, you add an `@AutoDslSingular` annotation containing the name of the helper method.

If you compile the project using IntelliJ IDEA, you should normally find the generated classes `HeaderDsl` and `HttpRequestBuilderDsl` in a `generated-sources/...` folder, but of course this depends on how you have integrated the AutoDSL processor and how you have set up your project.

The sample call from the previous section would now look like this:

[source,kotlin]
----
val request = httpRequestBuilder {
    uri = URI.create("https://acme.com:9876/products")
    method = GET
    header {
        key = "Content-Type"
        value = "application/x-www-form-urlencoded; charset=UTF-8"
    }
    header {
        key = "Accept-Encoding"
        value = "gzip, deflate"
    }
    timeout = Duration.ofSeconds(5)
}.build()
----

Granted, the code isn't quite as convenient and concise as the manually written DSL, but it comes close, and definitely looks nicer and more intuitive than a traditional builder. AutoDSL also keeps track of mandatory fields like `uri` and throws an `IllegalStateException` if they are not set.

=== Builder Type Inference (((Builder Type Inference)))

In some cases, the compiler can improve its type inference by inspecting the method calls inside the trailing lambda block. As of Kotlin 1.7.0, this feature is enabled by default, but in older versions you can turn it on using the `-Xenable-builder-inference` compiler option. There are no real drawbacks to using this feature, but if you want to look into the details, you can check out https://kotlinlang.org/docs/using-builders-with-builder-inference.html[Kotlin Documentation - Using builders with builder type inference]footnote:[Kotlin Documentation, Using builders with builder type inference: https://kotlinlang.org/docs/using-builders-with-builder-inference.html].

=== Conclusion

The Loan Pattern DSL has several advantages over the classic Builder Pattern style, and is very common in Kotlin. It really shines when dealing with nested structures, and allows other DSL techniques to be integrated more easily. The Kotlin language provides several features to improve the user experience, such as the `@DslMarker` mechanism and builder type inference.

==== Preferable Use Cases

* Creating data
* Transforming data
* Execute actions
* Configuring systems
* Generating code
* Testing

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* easy to read, especially for nested constructions
* very flexible and intuitive
* can be autogenerated (e.g. using https://github.com/F43nd1r/autodsl[AutoDSL])


|* behavior is harder to control than for the Builder Pattern
* safe usage can't be always guaranteed
* might be more difficult to use from Java client code
|===