[#relevant_language_features]
== Relevant Language Features

> I suppose it is tempting, if the only tool you have is a hammer, to treat everything as if it were a nail.
-- Abraham Maslow, Toward a Psychology of Being

Kotlin is a modern and beautiful programming language that offers several key features not found in Java. Here are some of the most notable features that set Kotlin apart:

* *Null-Safe Type System:* Kotlin's null-safety feature is a major improvement over Java, where null values can cause null pointer exceptions. This feature ensures that a variable cannot be null unless explicitly declared as such, reducing the risk of runtime errors.
* *Concise Syntax:* Kotlin's syntax is designed to be as concise as possible, reducing the amount of boilerplate code that developers need to write. Optional semicolons, operator overloading, and expression body functions are just a few examples of the syntactic sugar that not only makes Kotlin code easier to read and maintain, but also helps you write expressive DSLs.
* *Object-Oriented Design:* Kotlin takes a more object-oriented approach than Java, replacing static members with object declarations that can be used in a more flexible and modular way.
* *Functional Programming Features:* Kotlin also supports functional programming, including top-level and local functions, as well as trailing lambda syntax.
* *Multiplatform Support:* Kotlin can be compiled to run on multiple platforms, including the JVM, JavaScript, and as a native application

In addition, Kotlin has excellent interoperability with Java(((Java Interoperability)))(((Interoperability))), making it easy to call Java code from Kotlin and vice versa. Kotlin also includes several annotations that make it easier to call Kotlin code from Java, ensuring that the two languages can work together seamlessly.

As mentioned in the preface, this book assumes that the reader has a basic knowledge of Kotlin. However, DSLs often use little-known language features, or they use some features in a different way than ordinary code. Sometimes even the users of the DSL may not be aware of the kind of "machinery" that makes it work.

This chapter gives a brief overview of language features that may be relevant to writing DSLs. After reading this chapter, you should have a better understanding of how some common DSL "tricks" work.

[#backtick_identifiers]
=== Backtick Identifiers (((Backtick Notation)))

Kotlin allows almost arbitrary identifiers as long as they are enclosed in backticks. The main reason for introducing this feature was to allow the use of identifiers that are keywords in Kotlin but not in Java, such as `fun` or `when`. For DSLs, we can use them when we need descriptive identifiers that don't follow the usual syntactic rules.

Backtick identifiers start and end with a backtick `{backtick}` and can contain almost any character. Note that the backticks themselves are not part of the identifier, just delimiters. A typical use case for backticks are DSLs for test libraries. While Java limits you to underscores and camel case, Kotlin allows very descriptive names for test functions by using the backtick syntax:

[source]
----
fun `check that the slithy toves gyre and gimble in the wabe`() {
   ...
}
----

For Kotlin on the JVM, all characters except `\r` `\n` `,` `.` `;` `:` `\` `|` `/` `[` `?` `]` `<` `>` `{backtick}` are allowed, and you will get a compiler error if you try to use an identifier that contains one of these characters. However, if you need to use some of them anyway, you can rename the method on the JVM with a valid identifier, and suppress the compiler check:

[source,kotlin]
----
@Suppress("INVALID_CHARACTERS")
@JvmName("diamond")
fun `<>`() {
   println("this works!")
}
----

This is especially useful when simulating an operator with an infix function, see the section <<infix_notation, Infix Notation for Functions>> for details.

=== Named Arguments (((Named Arguments))) and Default Values (((Default Values)))

Java relies on the order of the parameters when calling a method or constructor, which can quickly become confusing. In contrast, Kotlin allows you to refer to arguments by name, which is much more readable and doesn't require you to remember the order of the parameters:

[source,kotlin]
----
fun makeColor(red: Int, green: Int, blue: Int, alpha: Int)
   = Color(red, green, blue, alpha)

// call by argument order
val color1 =
    makeColor(220, 200, 100, 128)

// call by named argument
val color2 =
    makeColor(
        alpha = 128,
        red = 220,
        green = 200,
        blue = 100
    )
----

In Java, a similar naming behavior can be mimicked using the builder pattern, but in many cases Kotlin's built-in solution is more convenient.

In Kotlin, you can also assign default values to function and constructor arguments, which greatly simplifies the code compared to Java, where you have to write multiple methods or constructors with different combinations of default values to achieve the same effect. Therefore, Kotlin's default value approach reduces boilerplate code and improves readability. In the example above, it would make sense to set the alpha value to 255, since it is more common to define an opaque color than a translucent one:

[source,kotlin]
----
fun makeColor(
        red: Int,
        green: Int,
        blue: Int,
        alpha: Int = 255 // setting a default value
    ) = Color(red, green, blue, alpha)

// setting all parameters
val color1 =
    makeColor(220, 200, 100, 128)

// using the default value 255 for alpha
val color2 =
    makeColor(220, 200, 100)
----

Both language features are useful on their own, but they complement each other very well. A nice example is the autogenerated `copy()` method (((Copy Method))) in data classes: (((Data Classes)))

[source,kotlin]
----
data class Person(val firstName: String, val lastName: String, val age: Int) {
    // the method is autogenerated, but would look roughly like this:
    fun copy(firstName: String = this.firstName,
             lastName: String = this.lastName,
             age: Int = this.age
        ) = Person(firstName, lastName, age)
}

val person = Person("John", "Doe", 23)

val agedPerson = person.copy(age = person.age + 1)
----

In the `copy()` method, the values of the current object are set as default values of the new instance, and thanks to the named argument feature you can pick just the arguments which should be changed, and leave all others untouched.

(((Lenses))) (((Optics))) (((Arrow Optics)))
[TIP]
====
While the `copy()` method is convenient when working with immutable data classes, it doesn't scale well for nested data classes: Imagine you need a copy of a company, with the email of the address of the CEO changed. That means you need nested `copy()` calls as well, going down level by level. This is lengthy, hard to read and error-prone.

In functional programming, this problem is often solved with an "optics" package, which contains lenses and similar abstractions that allow to easily compose copy operations for different nesting levels. If you want to learn more about this topic, I suggest you have a look at https://arrow-kt.io/learn/immutable-data/intro[ArrowKt Optics]footnote:[ArrowKt Optics: https://arrow-kt.io/learn/immutable-data/intro](((Arrow-KT))).
====

=== Trailing Lambda Arguments (((Trailing Lambda)))

If a method expects an argument of a function type, you can use the usual curly bracketed lambda syntax when calling it. For example, you can merge a list of strings using the `fold()` method like this:

[source,kotlin]
----
listOf("one", "two", "three").fold("", { s, t -> s + t })
----

However, if such an argument comes last, you can pull it out of the argument list, and append it after the closing parenthesis:

[source,kotlin]
----
listOf("one", "two", "three").fold("") {
   s, t -> s + t
}
----

In case the function type is the only argument, you don't have to write the empty parentheses. The `map()` method is an example for a method with a single lambda argument:

[source,kotlin]
----
listOf("one", "two", "three").map {
    s -> s.length
}
----

While this syntactic sugar might not look very impressive at first glance, it allows to write very natural looking DSLs for nested structures. Here is an example from the Kotlin documentation:

[source,kotlin]
.https://kotlinlang.org/docs/type-safe-builders.html#how-it-works
----
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
----

=== Varargs (((Varargs)))

Varargs (from "variable arguments") are a useful feature in both Java and Kotlin, allowing methods to take a variable number of arguments. However, Kotlin has made several improvements to varargs that make them safer and more convenient to use.

One of the most important improvements in Kotlin is that the syntax for varargs is now unambiguous. In Java, it was sometimes difficult to tell whether an array was intended to be a single argument to a vararg, or whether its elements should be used as individual arguments. Kotlin addresses this problem by introducing the unary "spread operator" `*`(((Spread Operator))), which indicates that the elements of an array (rather than the array itself) should be used as arguments to a vararg.

In addition, Kotlin allows more flexible use of varargs. You can freely combine single-value arguments with elements of spread arrays:

[source,kotlin]
----
val someArray = arrayOf(4, 6, 8)
val list = listOf(2, 0, *someArray, 5) // contains 2, 0, 4, 6, 8, 5
----

==== Vararg Position and Trailing Lambda Syntax

Unlike Java, where a vararg must always be the last argument, Kotlin allows you to put the vararg anywhere, although you may need to use named arguments to avoid ambiguity:

[source,kotlin]
----
fun varargMethod(vararg numbers: Int, someString: String) { ... }

varargMethod(1, 2, 3, someString = "Hi!")
----

Note that vararg elements can't be assigned individually when referenced by a named argument, but must be bundled into an array instead:

[source,kotlin]
----
varargMethod(
    someString = "Hi!",
    numbers = intArrayOf(1, 2, 3)
)
----

At first glance, having the ability to put varargs wherever you want doesn't seem very useful. But there is one particular use case that is very interesting from a DSL design perspective: You can put a vararg as the second-to-last argument before a trailing lambda argument.

[source,kotlin]
----
fun varargAndLambda(someString: String, vararg numbers: Int, block: () -> Unit) { ... }

varargAndLambda("Hi!", 1, 2, 3) {
    ...
}
----

As the code snippet shows, no named arguments are required in this case.

=== Property-Syntax (((Properties)))

Kotlin allows you to control how properties are read and written. This makes it easy to hide DSL functionality. An easy example is checking preconditions before setting a value:

[source,kotlin]
----
class TemperatureSensor {
    var celsius: Double = 0.0
        set(value) {
            require(value >= -273.15) {
                "Temperature is under absolute zero."
            }
            field = value
        }
}
----

In the same way, you can perform additional actions when you read a value, or even change the return value itself:

[source,kotlin]
----
class SensitiveData {
    val logger = Logger.getLogger(this::class.java.name)

    var secretValue: Int = 42
        get() {
            logger.info("Access to secret value $field at ${LocalDateTime.now()}")
            return field
        }
}
----

There are many other things you can do with properties, such as caching, lazy evaluation, delegation to other properties, or input sanitization. Later in the <<extensions_and_receivers, Extensions and Receivers>> section, we'll discuss another use of the property syntax.

[#extensions_and_receivers]
=== Extensions (((Extensions))) and Receivers (((Receivers)))

One of Kotlin's most important features for DSL design are extension functions, lambdas, and properties, which allow you to add functionality to existing classes - even final ones - without touching them. These extensions are standalone constructs that operate on a _receiver_, which is the target class they are extending. The function body is placed in the scope of the receiver, so you can access its public fields, methods, etc., and you can also refer to the receiver itself with `this`. Here is what an extension function looks like:

[source,kotlin]
----
fun Int.digits(base: Int = 10): List<Int> =
    generateSequence(this.absoluteValue) {
        (it / base).takeIf { it > 0 }
    }
    .map { it % base }
    .toList()
    .reversed()

val zero = 0.digits() // [0]
val taxiCab = 1729.digits() // [1, 7, 2, 9]
val taxiBin = 1729.digits(2) // [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1]
val taxiHex = 1729.digits(16) //[6, 12, 1]
----

From the user's point of view, the call with receiver looks exactly like a normal method call (or property access) on a receiver instance. This makes extension functions a great tool for adding DSL functionality to classes over which you have no control. A great example is the so-called "scope functions" `apply()`, `run()`, `let()`, and `also()` in the Kotlin API, which make it easier to use e.g. expression body syntax for functions or concise variable assignment.

On the JVM where Kotlin is typically compiled, extension functions are implemented using static methods with the receiver instance as the first argument. This means that extension methods can also be called from Java, although it looks less elegant:

[source,java]
.Java
----
List<Integer> digits = IntUtilsKt.digits(1729, 10); // [1, 7, 2, 9]
----

.Extension Functions in Different Languages
****
Extension methods, originally introduced in C#, found their way into Kotlin as "extension functions", specifically with the goal of seamlessly integrating Java classes into the Kotlin ecosystem. This approach was chosen over Scala's _implicit conversion_ approach, which, while more powerful, was considered more complex to understand and manage. The benefits of extension methods became so apparent that they were also introduced in Scala 3. Plain Java doesn't provide support for extension methods, but there are Java libraries that do, such as http://manifold.systems/docs.html#the-extension-manifold[Manifold]footnote:[Manifold Extension Methods: http://manifold.systems/docs.html#the-extension-manifold](((Manifold))), https://projectlombok.org/features/experimental/ExtensionMethod[Project Lombok]footnote:[Project Lombok Extension Methods: https://projectlombok.org/features/experimental/ExtensionMethod](((Project Lombok))), or https://github.com/rogerkeays/fluent[Fluent]footnote:[Fluent: https://github.com/rogerkeays/fluent](((Fluent))). It is safe to say that extension methods are an important and successful advancement in modern object-oriented programming.
****

[#type_narrowing]
==== Type Narrowing (((Type Narrowing)))

Interestingly, generic extension functions have a feature that normal instance methods don't have: They can bind generic parameters to a particular type, thus limiting the range of possible recipients. Here is an example for calculating the product of numbers as an extension function for a list:

[source,kotlin]
----
fun List<Double>.product() = fold(1.0, Double::times)

val p = listOf(1.0, 2.0, 3.0).product()  // p == 6.0
----

The call to `Double::times` is only possible because the receiver is not just any list, but specifically a `List<Double>`, and this additional type information is also passed to the function body. This feature of extension methods can be used in DSLs to perform compile-time checks.

[#loan_pattern]
==== Loan Pattern (((Loan Pattern)))

.What is the Loan Pattern?
****
The Loan Pattern is a design pattern in object-oriented programming that involves encapsulating the use of a resource (such as a database connection or file handle) within a limited scope or block of code. The pattern is designed to ensure that the resource is properly acquired, used, and released without the risk of resource leakage or conflicts with other code that may be accessing the same resource.

In essence, the Loan Pattern involves creating a resource object or acquiring a resource handle at the beginning of a block of code, using the resource as needed within the block, and then releasing or disposing of the resource at the end of the block. This ensures that the resource is only used for the duration of the block, and that it is properly cleaned up when the block is finished, even if an error or exception occurs during the block.

The Loan Pattern is particularly useful when resources are limited or expensive to acquire. It can also help improve the maintainability and robustness of code by making it easier to reason about the use of resources and to ensure that they are properly managed throughout the program.
****

Lambdas can also have receivers, which is useful when using the Loan pattern. Using this pattern can be beneficial in DSLs, as it helps to control the lifecycle of the receiver class and hide the steps necessary to initialize and finalize the instance creation or operation.

For example, consider the well-known `java.util.StringBuilder` class. It allows you to perform complex string operations, but to use it, you need to construct it and call its `toString()` method at the end. When using the Loan pattern, these steps can be hidden and the code looks cleaner:

[source,kotlin]
----
val theUsualWay: String = StringBuilder()
    .append("World")
    .insert(0, "Hello ")
    .append('!')
    .toString()

// the extension function
fun sb(block: StringBuilder.() -> Unit): String =
    StringBuilder()
        .apply { block(this) }
        .toString()

val usingTheLoanPattern: String = sb {
    append("World")
    insert(0, "Hello ")
    append('!')
}
----

Building DSLs using this pattern is very common, as it has several advantages over the classic builder pattern.

[#dsl_marker]
==== The @DslMarker annotation (((@DslMarker)))

When you nest multiple extension functions, overlapping scopes can be a problem: things visible in the outer code blocks are also visible in the inner ones. For example, in a DSL for HTML generation, you might write:

[source,kotlin]
----
html {
    head {...}
    body {
        head {} // ouch, head() is defined in html's scope, but also visible here
    }
}
----

To avoid this problem, Kotlin provides a scope control mechanism:

* Define a custom annotation
* Annotate that annotation with `@DslMarker`
* Mark all involved receiver classes (or a common superclass) with your annotation
* Now you can't access outer scope elements directly. You can still reference them indirectly, e.g. using the syntax `this@html.head{...}`

In our example, such an annotation might look like this

[source,kotlin]
----
@DslMarker
annotation class HtmlMarker
----

If the receiver classes of the lambda arguments of the `head()` and `body()` functions are annotated with `@HtmlMarker`, the above example would no longer compile.

==== Extension properties (((Extension Property)))

You can not only define extension functions and lambdas, but also extension properties. Generally, they aren't used nearly as much as extension functions, but they can help to beautify DSLs, as they don't require to write empty parentheses. In the following example, we want to create a custom `Amount` class by adding extension properties for the different currencies to `Double`:

[source,kotlin]
----
data class Amount(val value: BigDecimal, val currency: String)

val Double.USD
    get() = Amount(this.toBigDecimal(), "USD")

val Double.EUR
    get() = Amount(this.toBigDecimal(), "EUR")

val usdAmount: Amount = 22.46.USD

val eurAmount: Amount = 17.11.EUR
----

With an extension function, the best syntax we could achieve is `22.46.USD()`, but the parentheses are no longer needed when using extension properties.

Extension properties are especially useful when the result of the computation is a function. Consider currying, which is a technique for turning functions that take multiple arguments into a chain of functions that take single arguments. Written as an extension property, it could be implemented like this (for functions with two arguments):

[source,kotlin]
----
val <A, B, R> ((A, B) -> R).curry: (A) -> (B) -> R
    get() = { a -> { b -> this@curry(a, b) } }

fun someFunction(i: Int, s: String): String = s.repeat(i)

val sf3 = ::someFunction.curry(3)
println(sf3("Abc")) // AbcAbcAbc
println(sf3("x")) // xxx
----

If we had written `curry` as a function, we would have to write `val sf3 = ::someFunction.curry()(3)` instead, which looks very confusing.

=== Operator Overloading (((Operator Overloading)))

Kotlin allows operator overloading, but is conservative in the sense that it only allows a fixed set of operators.

[NOTE]
.Overloading Restrictions
====
The boolean operators `&&` and `||`, the access operators `.`, `?.` and `!!`, the unary spread operator `*`, the Elvis operator `?:` and the property delegation operators `provideDelegate`, `getValue` and `setValue` cannot be overloaded.
====

Some overloading functions require specific return types. The type `R` is used in the following tables to indicate that there are no such restrictions.

==== Unary Operators (((Unary Operator)))

[cols="1a,2a,3a"]
|===
|Operator |Overwriting Function | Remarks

| `+a` | `fun A.unaryPlus(): R` |
| `-a` | `fun A.unaryMinus(): R` |
| `!a` | `fun A.not(): R` |
| `++a` | `fun A.inc(): A`| Assigns the result to `a` and returns it
| `a++` | `fun A.inc(): A`| Assigns the result to `a` and returns the original value
| `--a` | `fun A.dec(): A`| Assigns the result to `a` and returns it
| `a--` | `fun A.dec(): A`| Assigns the result to `a` and returns the original value
|===

==== Binary Arithmetic Operators (((Binary Operator)))

[cols="1a,2a,3a"]
|===
|Operator |Overwriting Function | Remarks

| `a + b` | `fun A.plus(b: B): R` |
| `a - b` | `fun A.minus(b: B): R` |
| `a * b` | `fun A.times(b: B): R` |
| `a / b` | `fun A.div(b: B): R`|
| `a % b` | `fun A.rem(b: B): R`| Until Kotlin 1.1, `mod` was used, but is now deprecated.
|===

If these operators are defined, `a` is mutable, and the left and right sides have matching types (`B` is a subtype of `A`), they can also be used in the assignments `+=`, `-=`, `*=`, `/=`, and `%=`.

If you don't want the normal binary form, but only the assignment, you can define it explicitly:

[cols="1a,2a,2a"]
|===
|Operator |Overwriting Function | Remarks

| `a += b` | `fun A.plusAssign(b: B): Unit` |
| `a -= b` | `fun A.minusAssign(b: B): Unit` |
| `a *= b` | `fun A.timesAssign(b: B): Unit` |
| `a /= b` | `fun A.divAssign(b: B): Unit`|
| `a %= b` | `fun A.remAssign(b: B): Unit`|
|===

Again, `a` must be mutable, `B` must be a subtype of `A`. Also, the return type of the function must be `Unit`. Having both the binary and assignment versions of an operator in scope results in an ambiguity error.

==== Range (((Range Operator))) and In Operators (((In Operator)))

[cols="1a,2a,2a"]
|===
|Operator |Overwriting Function | Remarks

| `a .. b` | `fun A.rangeTo(b: B): R` |
| `a ..< b` | `fun A.rangeUntil(b: B): R` | Introduced in Kotlin 1.8, experimental in 1.7.20
| `a in b` | `fun B.contains(a: A): R` | Defines also `!in`.
|===

The `..<` operator was introduced as a replacement for the `until` infix function.

==== Index Access (((Index Access Operator))) and Invoke Operators (((Invoke Operator)))

[cols="1a,2a,2a"]
|===
|Operator |Overwriting Function | Remarks

| `a[b]` | `fun A.get(b: B): R` |
| `a[b, c]` | `fun A.get(b: B, c: C): R` | Or more arguments
| `a[b] = x` | `fun A.set(b: B, x: X): Unit` |
| `a[b, c] = x` | `fun A.set(b: B, c: C, x: X): Unit` | Or more arguments
| `a()` | `fun A.invoke(): R` |
| `a(b)` | `fun A.invoke(b: B): R` |
| `a(b, c)` | `fun A.invoke(b: B, c: C): R` | Or more arguments
|===

Note that the index access operator `[]` requires at least one element, while the invoke operator `()` can be also used without arguments.

==== Equality (((Equality Operator))) and Comparison Operators (((Comparison Operator)))

[cols="1a,2a,2a"]
|===
|Operator |Overwriting Function | Remarks

| `a == b` | `fun equals(b: Any): Boolean` | Must be defined in `class A`. Also defines `!=`.
| `a < b` | `fun A.compareTo(b: B): Int` | Evaluates `a.compareTo(b) < 0`
| `a <{zwsp}= b` | `fun A.compareTo(b: B): Int` | Evaluates `a.compareTo(b) <{zwsp}= 0`
| `a > b` | `fun A.compareTo(b: B): Int` | Evaluates `a.compareTo(b) > 0`
| `a >= b` | `fun A.compareTo(b: B): Int` | Evaluates `a.compareTo(b) >= 0`
|===

==== Overload Responsibly

While overloaded operators can be a powerful tool in DSL design, it is important to use them judiciously and with care. While there are many potential applications for overloaded operators, it is important to ensure that there is a clear association or analogy between the operation being performed and the operator chosen.

For example, using the `/` operator to concatenate file paths makes sense because it is a common path separator. Similarly, using the unary `+` operator to "add" a single value within a trailing lambda block has become a standard convention. And using `..` instead of `:` may be acceptable because of its visual similarity.

At some point, however, overloading operators can become confusing or even counterproductive. For example, using the `!` operator to invert a matrix may be a stretch since it has no clear association with matrix inversion. In general, it is important to avoid being too clever when designing a DSL, as users may not have the same associations or understanding of certain symbols or operators.

One solution is to use meaningful infix functions (((Infix Notation))) with expressive names, rather than relying solely on overloaded operators. While this may be less concise, it can make code easier to understand and less prone to confusion. Ultimately, the goal should be to create a DSL that is intuitive and easy to use without sacrificing clarity or consistency.

[#infix_notation]
=== Infix Notation for Functions (((Infix Notation)))

Infix notation allows function names to be used like binary operators. Well-known examples in the Kotlin API include `to` for creating pairs, and `until` and `downTo` for creating ranges.

The corresponding function must be an extension function with one argument, the receiver becomes the left side and the argument becomes the right side of the operator. Note that you can still use the normal function call syntax. Here is an example of checking preconditions:

[source,kotlin]
----
infix fun <T> T.shouldBe(expected: T) {
    require(this == expected)
}

fun testIfExpected(s: String) {
    s.shouldBe("expected") // normal syntax
    s shouldBe "expected" // infix syntax
}
----

One weakness of infix notation is that you can't explicitly specify generics. In this case, you can fall back on the normal function call syntax - but users of the DSL may not know this.

As mentioned above, the combination of infix and backtick notation allows you to define new "operators", at least visually:

[source,kotlin]
----
infix fun Double.`^`(exponent: Int) = this.pow(exponent)

val result = 1.2 `^` 3
----

Infix functions can also help make the trailing lambda syntax more readable. For example, we can write a function that takes a pair of lists and combines them using a given lambda:

[source,kotlin]
----
infix fun <P, Q, R> Pair<List<P>, List<Q>>.zipWith(
    body: (P, Q) -> R
): List<R> = first.zip(second).map { (p, q) -> body(p, q) }

val numbers = listOf(1, 2, 3, 4)
val strings = listOf("x", "y", "z")
val result = numbers to strings zipWith { i, c -> "$i -> $c" }
println(result) // [1 -> x, 2 -> y, 3 -> z]
----

Without `infix`, we would have to write `(numbers to strings).zipWith { i, c -> "$i -> $c" }` instead, which looks quite cluttered.

[#functional_interfaces]
=== Functional Interfaces (((Functional Interfaces))) (((SAM))) (((Single Abstract Method)))

Imagine you have an interface for checking strings, with a single abstract function, and you need an anonymous implementation:

[source,kotlin]
----
interface StringCheck {
    fun check(s: String): Boolean
}

val stringCheck = object : StringCheck {
    override fun check(s: String) = s.length < 10
}
----

Such code is pretty ugly, and far too verbose to expect a DSL user to implement your interface that way. But since the interface has only a single abstract method (abbreviated as "SAM"), it can be written as a functional interface, which allows a simplified syntax to implement it anonymously:

[source,kotlin]
----
// note the "fun" keyword
fun interface StringCheck {
    fun check(s: String): Boolean
}

val shortStringCheck = StringCheck { s -> s.length < 10 }
----

I think you will agree that this syntax looks much better, making it useful for DSLs. However, the lambda-like syntax is just syntactic sugar: Under the hood, the compiler translates it into an implementation equivalent to the first example.

=== Generics (((Generics)))

Generics are a useful abstraction over concrete types in all sorts of contexts, including DLS design. A specific use case is the implementation of compile-time checks. Here is a simple example that models currencies (similar to the code shown for extension properties):

[source,kotlin]
----
import java.math.BigDecimal

interface Euro
interface BritishPound

data class Currency<T>(val value: BigDecimal)

val Double.EUR
    get() = Currency<Euro>(this.toBigDecimal())

val Double.GBP
    get() = Currency<BritishPound>(this.toBigDecimal())

operator fun <T> Currency<T>.plus(that: Currency<T>) =
    copy(value = this.value + that.value)

val works = 3.1.EUR + 4.5.EUR // 7.6 €
val worksToo = 2.1.GBP + 4.2.GBP // 6.3 £

//this doesn't compile:
//val oops = 3.1.EUR + 4.5.GBP
----

You can't add amounts of different currencies together, because the definition of `+` ensures that both amounts belong to the same currency. The generic type parameter `T` is called a "phantom type", and this code is a very simple example of type-level programming.

[#type_level_programming]
.Type-Level Programming (((Type-Level Programming))) and Phantom Types (((Phantom Type)))
****
*Type-Level Programming* is a programming paradigm in which types themselves are used as values that can be manipulated and computed at compile time, rather than being used only to check the correctness of program syntax and logic. In other words, type-level programming involves using types to encode complex computations and algorithms that are evaluated by the compiler at compile time rather than at runtime. Type-level programming can be used to achieve a variety of goals, such as improving program performance and enforcing stronger type constraints.

*Phantom Types* are a type-level programming technique in which a type is used to encode additional information about the data it represents without actually storing any data at runtime. Phantom types are types that have no values, but are used only for their type-level information. They can be used to enforce stronger type constraints, such as ensuring that only certain operations are performed on certain types of data. This can help reduce runtime errors and improve the safety of the program.
****

==== Resolving Type Erasure Conflicts

Because of type erasure, two different generic functions can end up with the same signature in the JVM. Consider the following example:

[source,kotlin]
----
// DOES NOT COMPILE

fun average(list: List<Int>): Double =
    list.sum().toDouble() / list.size

fun average(list: List<Double>): Double =
    list.sum() / list.size
----

The compiler complains `The following declarations have the same JVM signature (average(Ljava/util/List;)D)`. In Java, the only solution is to rename the functions. In Kotlin, we can keep the same names in the code, and just rename them in the JVM:

[source,kotlin]
----
@JvmName("averageInt")
fun average(list: List<Int>): Double =
    list.sum().toDouble() / list.size

@JvmName("averageDouble")
fun average(list: List<Double>): Double =
    list.sum() / list.size

println(average(listOf(1, 2, 3))) // 2.0
println(average(listOf(7.0, 8.0, 9.0))) // 8.0
----

[#reified_generics]
==== Reified Generics (((Generics))) (((Reified Generics)))

Kotlin offers an interesting feature called "reified generics" that helps to overcome Java's type erasure for generics on the JVM in some situations. Type erasure is a JVM technique that allows Java to check generics at compile time, while discarding type information at runtime. In contrast, reified generics in Kotlin allow type information to be preserved at runtime. This means that developers can perform type-safe operations at runtime without having to resort to workarounds or unsafe casts.

[source,kotlin]
----
inline fun <reified T> List<T>.combine(): Unit = when(T::class) {
    Int::class -> (this as List<Int>).sum()
    String::class -> (this as List<String>).joinToString()
    else -> this.toString()
}.let { println(it) }

fun main() {
    listOf<Int>().combine() // 0
    listOf(1,2,3).combine()  // 6
    listOf("x","y","z").combine() // xyz
    listOf(true, false).combine() // [true, false]
}
----

Note the expression `T::class`, which shouldn't work, considering that type erasure removes all generic type information at runtime. However, the function is defined as an `inline` function, and the generic parameter `T` is marked as "reified". The details are beyond the scope of this book, but basically the inlining allows the compiler to get the generic type information from where the inlining occurs, and make it look like there was no type erasure. It should be noted that inline functions are subject to some restrictions and behave slightly differently than normal functions, e.g. in handling returns.

[WARNING]
.Java Interoperability
====
Functions with reified type parameters cannot be called from Java because it has no mechanism for inlining functions, and only inlining allows Kotlin to capture the generic type. This issue will be discussed in <<#reified_generics_bridge,Chapter 13>>.
====

=== Value Classes (((Value Classes))) (((@JvmInline)))

Value classes are a feature introduced in Kotlin 1.5 that allows developers to create lightweight, efficient classes that represent simple values. Value classes are designed to be used for values that are commonly used and require little to no additional functionality beyond what is already provided by the underlying data type.

In Kotlin, a value class is defined using the "value" modifier and must have a single primary constructor with exactly one parameter. The parameter must be of a non-nullable type, such as `Int`, `Long`, or `String`. Value classes cannot extend other classes, and they cannot be extended by other classes.

Value classes are optimized for performance, as they are designed to avoid the overhead of creating a full object instance whenever possible, very similar to the handling of primitive types such as `Int`, which are generally used in their "unboxed" state on the JVM, unless a "boxed" instance is really required.

One of the main advantages of value classes is that they can be used to create more expressive and type-safe APIs. For example, a value class representing a particular unit of measurement can help ensure that only valid unit conversions are performed, and can help catch errors at compile time rather than at runtime.

[NOTE]
.@JvmInline
====
The JVM backend requires a `@JvmInline` annotation, which may be obsolete in the future. Also, the single constructor argument restriction may be dropped. This depends on the introduction of https://openjdk.org/projects/valhalla/[Project Valhalla]footnote:[OpenJDK Project Valhalla: https://openjdk.org/projects/valhalla](((Project Valhalla))), which aims to introduce value class functionality to Java.
====

[source,kotlin]
----
@JvmInline
value class Kilometers(val value: Double)

@JvmInline
value class Miles(val value: Double)

fun Kilometers.toMiles() : Miles =
    Miles(this.value * 0.6214)

val marathonInMiles = Kilometers(42.195).toMiles() // Miles(value=26.219973)
----

[#anonymous_objects]
=== Anonymous Objects (((Anonymous Objects)))

While anonymous objects have no name, they still have their own type, which is also unnamed. Here is a somewhat silly example to illustrate this point:

[source,kotlin]
----
object {
    fun sayHi() = "Hello!"
}.sayHi()
----

The anonymous object is not of type `Any`, otherwise we couldn't call `sayHi()` on it. It defines its own (unnamed) type that exposes the variables and functions defined within it. For this reason, anonymous objects can be used in DSLs as a setup or environment for later computations.

A DSL with a method that measures the duration of several calls and returns the average time taken could be written as follows:

[source,kotlin]
----
fun <T:Any> T.measureTime(block: T.() -> Unit): Double {
   val start = System.nanoTime()
   repeat(1000) { block() }
   val end = System.nanoTime()
   return (end - start) / 1000.0
}

val env = object { val x = complicatedStuff() }

val nsSomeCall = env.measureTime { someCall(x) }
val nsOtherCall = env.measureTime { otherCall(x) }
----

The necessary setup information for the measurement phase is stored inside an anonymous object in the `env` variable.

[#annotations]
=== Annotations (((Annotations)))

You can write entire DSLs using annotations, but more often annotations can support DSLs by describing how certain fields or classes should be handled. They are especially powerful if your DSL has a certain default behavior, but needs to take some edge cases or exceptions into account, such as "do not persist this property".

Another useful application for annotations is code generation(((Code Generation))). For example, the AutoDSL library (((AutoDSL))) uses the information provided via annotations to construct the DSL classes for you.

.Annotation Processors (((Annotation Processors))) (((KSP))) (((kapt))) (((Kotlin Symbol Processing API)))
****
Annotation processors allow custom processor code to be executed during the build process according to the annotations present in the application code. Kotlin provides two annotation processors, the older https://kotlinlang.org/docs/kapt.html[kapt]footnote:[kapt: https://kotlinlang.org/docs/kapt.html], which is no longer actively developed, and the recommended https://kotlinlang.org/docs/ksp-overview.html[Kotlin Symbol Processing API]footnote:[KSP: https://kotlinlang.org/docs/ksp-overview.html] (KSP), which will be discussed in <<#annotation_processor,Chapter 12>>.
****

Finally, Kotlin includes annotations to support Java access. DSL code is often more difficult to call from Java, so we'll discuss this topic in <<#java_interoperability,Chapter 13>>.

[#reflection]
=== Reflection (((Reflection))) (((Kotlin-Reflect)))

Sometimes you need to inspect or deconstruct classes, call unknown methods, react to annotations, etc., which can be done using reflection. If you need more than the most basic reflection in Kotlin, you need to import a separate dependency:

[source,kotlin]
.Gradle (.kts)
----
dependencies {
    implementation(kotlin("reflect"))
}
----

[source,xml]
.Maven
----
<dependencies>
  <dependency>
      <groupId>org.jetbrains.kotlin</groupId>
      <artifactId>kotlin-reflect</artifactId>
  </dependency>
</dependencies>
----

Depending on your use case, you might also consider alternatives like https://github.com/Kotlin/kotlinx.reflect.lite[kotlinx.reflect.lite].

=== Experimental Features (((Experimental Features)))

Kotlin allows you to try experimental features (via compiler argument or `@OptIn` annotation). Some of these features are quite stable and may be useful for DSL design, so it may be worth taking the risk of using them before they become an official part of the language.

[#context_parameters]
==== Context Parameters (((Context Parameters))) (((Context Receivers)))

https://github.com/Kotlin/KEEP/blob/context-parameters/proposals/context-parameters.md[Context Parameters]footnote:[Context Parameters: https://github.com/Kotlin/KEEP/blob/context-parameters/proposals/context-parameters.md]] - formerly known as "Context Receivers" - are an experimental feature introduced in Kotlin 1.6.2, and at the writing of this book, its beta phase is planned for Kotlin 2.2.

The basic idea of Context Parameters is to get a class in scope that provides a certain service:

[source,kotlin]
----
interface EnvironmentContext {
    fun getProperty(name: String): String
}

context(EnvironmentContext)
fun methodWithContext() {
    val userName = getProperty("userName")
    ...
}
----

In this scenario, `methodWithContext()` gets access to members of the specified `EnvironmentContext` class, similar to an extension function. However, there is not only a syntactic difference, but also a semantic one: The function does not extend a receiver class, but is executed in the scope of an unrelated class that provides additional functionality. This design also allows you to have multiple contexts in scope, or to provide a context for an extension function.

To call `methodWithContext()`, you must provide an implementation of `EnvironmentContext`. If the calling function isn't already in the same context, you can use the `with()` function.

[source,kotlin]
----
fun test() {
    val environmentContext = EnvironmentContextImpl()
    with(environmentContext) {
        methodWithContext()
    }
}
----

[TIP]
====
Using multiple context parameters is a great way to decouple unrelated aspects of the environment while maintaining a high degree of flexibility. Unfortunately, with multiple receivers, the `with()` calls must be nested, although this may change in the future. For now, if you find this impractical, you can use this function presented in the Kotlin Discussions forum:

[source,kotlin]
.https://discuss.kotlinlang.org/t/using-with-function-with-multiple-receivers/2062/6
----
@OptIn(ExperimentalContracts::class)
@Suppress("SUBTYPING_BETWEEN_CONTEXT_RECEIVERS")
inline fun <A, B, R> with(a: A, b: B, block: context(A, B) () -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block(a, b)
}
----
====

Context parameters come into play when there's a need to include global information within a specific scope while maintaining the flexibility to accommodate different versions. By using a context parameter to provide DSL functionality, you gain control over the scope, you can influence the overall behavior of the DSL, and you can avoid potential naming conflicts.

You can opt in to context parameters by specifying the compiler argument `-Xcontext-receivers`.

[#contracts]
==== Contracts (((Contracts)))

https://github.com/Kotlin/KEEP/blob/master/proposals/kotlin-contracts.md[Kotlin Contracts]footnote:[Kotlin Contracts: https://github.com/Kotlin/KEEP/blob/master/proposals/kotlin-contracts.md] are a way to give the compiler additional information about the result of functions, allowing it to perform smart casts it couldn't do with just static code analysis.

Here is an example taken from the documentation:

[source,kotlin]
.https://kotlinlang.org/docs/whatsnew13.html#custom-contracts
----
fun String?.isNullOrEmpty(): Boolean {
    contract {
        returns(false) implies (this@isNullOrEmpty != null)
    }
    return this == null || isEmpty()
}

...

fun bar(x: String?) {
    if (!x.isNullOrEmpty()) {
        println("length of '$x' is ${x.length}") // smart cast
    }
}
----

You can also narrow the type when you perform a boolean check:

[source,kotlin]
----
sealed class ContactData {
    @OptIn(ExperimentalContracts::class)
    fun isEmail(): Boolean {
        contract {
            returns(true) implies (this@ContactData is Email)
            returns(false) implies (this@ContactData is Phone)
        }
        return this is Email
    }
}

data class Email(val address: String): ContactData() {
    fun send(msg: String) = println("sending '$msg' to $address")
}

data class Phone(val number: String): ContactData() {
    fun call(msg: String) = println("calling $number telling '$msg'")
}

fun sendMessage(cd: ContactData, msg: String) =
    if (cd.isEmail()) cd.send(msg) else cd.call(msg) // smart casts
----

At the moment, contracts are still quite limited, but in some situations you can use them to protect the DSL user from boilerplate checks, casts, or explicit specification of generics.

You can opt in to experimental contracts using

* the compiler argument `-Xopt-in=kotlin.contracts.ExperimentalContracts` or
* the annotation `@OptIn(ExperimentalContracts::class)`.

=== Conclusion

This chapter has provided a concise, high-level overview of many of the features of the Kotlin language that are relevant from a DSL perspective. While further details can be explored in the extensive Kotlin documentation, this brief tour should have given you a solid understanding of the extensive toolkit available for building DSLs. Kotlin offers remarkable creative freedom in this area, allowing you to use your imagination to create powerful and intuitive DSLs.

