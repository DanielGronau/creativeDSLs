== Builder Pattern DSLs

A common task is the initialization of a complex, sometimes nested object. The classical solution for this is the Builder Pattern. The builder class is mutable, uses method chaining (a.k.a. "Fluent Interfaces") to simplify value assignments, and contains a terminal build method, which constructs (hopefully after some sanity checks) the domain object.

This chapter covers the classical builder as often used in Java. Sometimes this is overkill is Kotlin, as named arguments can be used for smaller classes. Next, we will address the problem of mandatory fields in builders by presenting the Typesafe Builder Pattern. The next three sections cover some more exotic extensions: Builders that can count, chains of builders and chameleon builders. In the conclusion section we discuss why builders are not as widely used in Kotlin as in Java.

=== Classical Builder

As an example for a classical builder with realistic complexity, we can use `java.net.http.HttpRequest`, which is written in Java. A typical builder call could look like this:

[source,kotlin]
----
val request = HttpRequest.newBuilder(URI.create("https://acme.com:9876/products"))
    .GET()
    .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
    .header("Accept-Encoding", "gzip, deflate")
    .timeout(Duration.ofSeconds(5L))
    .build()
----

There are several alternatives or extension for the Builder Pattern. We will discuss these with shorter examples, and close this chapter with a case study for improving the builder above using extension methods.

=== Named Arguments instead of Builders

In Kotlin, you might not need a builder, because the language has already features like named and default arguments. E.g. take this implementation of an RGBA color:

[source,kotlin]
----
data class Color(val red: Int, val green: Int, val blue: Int, val alpha: Int = 255)

val c = Color(0, 100, 130, 200)
----

Written like this, the four `Int` values might be a little confusing to read, especially when you expect only three values as for RGB colors. However, instead on relying on a builder, you can simply clarify the meaning by rewriting the last line as follows:

[source,kotlin]
----
val c = Color(red = 0, green = 100, blue = 130, alpha = 200)
----

=== The Typesafe Builder Pattern

A common weakness of builders is that you can't enforce that mandatory fields are set. Of course, conditions like these should be always checked in the build method, but it would be nice if already the compiler could prevent you from attempting to build incomplete objects.

Although it requires some boilerplate code, you can use generics to keep track of the state of mandatory fields, and adapt the build method to accept only correctly filled out builders. As the generic signature of the builder must change for this to work, you can't use a single mutable builder, so the setter methods return new builders.

As an example, consider the following class for a product, which needs to have product id, name and price set, while the other attributes are optional:

[source,kotlin]
----
 data class Product(
    val id: UUID,
    val name: String,
    val price: BigDecimal,
    val description: String?,
    val images: List<URI>)
----

The first ingredient to our builder are three classes as a common prerequisite. They are similar to `Optional`, with the difference that the empty and full state are represented by different classes. In case you wonder why `T: Any` was used instead of simply `T`, this prevents `T` from being inhabited by a nullable type.

[source,kotlin]
----
sealed class Val<T: Any>
class Without<T: Any> : Val<T>()
class With<T: Any>(val value: T): Val<T>()
----

With the help of these classes, we can write the builder:

[source,kotlin]
----
data class ProductBuilder<ID: Val<UUID>, NAME: Val<String>, PRICE: Val<BigDecimal>>(
    val id: ID,
    val name: NAME,
    val price: PRICE,
    val description: String?,
    val images: List<URI>) {
    ...
}
----

That's a scary looking generic signature, but it isn't really hard to understand: Every mandatory field gets a separate type parameter, which keeps track whether it is already set or not. We could use the constructor to start the building process, but a helper function is more convenient:

[source,kotlin]
----
fun productBuilder() = ProductBuilder(
    id = Without(),
    name = Without(),
    price = Without(),
    description = null,
    images = listOf()
)
----

Thankfully, we don't have to write all the generic signatures, but the inferred return type of this function is `ProductBuilder<Without<UUID>, Without<String>, Without<BigDecimal>>`.

Now you can hopefully anticipate how the generics keep track of the mandatory fields. Basically, when an optional field is set, the type parameters don't change, but when a mandatory field is set, the signature will change from `Without` to `With` for this particular field. Here is the complete builder class:

[source,kotlin]
----
data class ProductBuilder<ID : Val<UUID>, NAME : Val<String>, PRICE : Val<BigDecimal>>(
    val id: ID,
    val name: NAME,
    val price: PRICE,
    val description: String?,
    val images: List<URI>) {
        fun id(uuid: UUID) =
            ProductBuilder(With(uuid), name, price, description, images)
        fun name(n: String) =
            ProductBuilder(id, With(n), price, description, images)
        fun price(p: BigDecimal) =
            ProductBuilder(id, name, With(p), description, images)
        fun description(desc: String) = copy(description = desc)
        fun addImage(img: URI) = copy(images = images + img)
}
----

Again, type inference saves us from a lot of typing, but the setters for the mandatory fields return a builder with a changed signature. That's why you can't use the `copy()` methods in this case.

Of course, one crucial part is missing: The `build()` method. However, we can't write it as part of the builder class, as it needs to inspect the generic signature. It has to be an extension method, because only there you can "fix" the type parameters to concrete types:

[source,kotlin]
----
fun ProductBuilder<With<UUID>, With<String>, With<BigDecimal>>.build() =
    Product(id.value, name.value, price.value, description, images)
----

Note how you can access the `value` fields of the `With` classes, because the extension method is only applicable on a fully set builder. Now we have a builder with a `build()` method that can be only called if all mandatory fields are set.

NOTE: The Typesafe Builder Pattern is an example of type-level programming. The pattern was pioneered by http://blog.rafaelferreira.net/2008/07/type-safe-builder-pattern-in-scala.html[Rafael Ferreira] in Scala, using ideas from Haskell. The code shown here is based on the implementation of http://dcsobral.blogspot.de/2009/09/type-safe-builder-pattern.html[Daniel Sobral].

=== Counting Builder

I have to admit that this is one of the more exotic builder variations, but I decided to include it because it is an interesting technique, and because this kind of construction might be useful in other contexts.

Consider the following `Polygon` class, which could be part of a graphics library:

[source,kotlin]
----
data class Polygon(val points: List<Point2D>)
----

It is very easy to write a builder to collect all points, and to construct the polygon from it, but there is a problem: A polygon with less than three points isn't really a polygon. Therefore, we would need a builder which can "count" how often a point is added, and only allows to construct polygons with at least three points.

One possible solution is to keep track of the number of points using a recursive type parameter. While this sounds strange at first, the implementation of the idea is straightforward:

[source,kotlin]
----
sealed class PB
object PolygonBuilder : PB() {
    fun add(point: Point2D) =
        PointPB<PolygonBuilder>(listOf(point))
}
class PointPB<T : PB>(val points:List<Point2D>) : PB() {
    fun add(point: Point2D) =
        PointPB<PointPB<T>>(points + point)
}
----

The `PolygonBuilder` is both starting point and marker for an empty builder. The `PointPB` builder takes a list of points as arguments, but it also keeps track of the type of the calling builder in its type parameter.

After the first `PolygonBuilder.add()` call, you get a `PointPB<PolygonBuilder>` back. Calling `add()` again gives you a `PointPB<PointPB<PolygonBuilder>>`. The next call returns a `PointPB<PointPB<PointPB<PolygonBuilder>>>`. And as in the Typesafe Builder Pattern example, we can use an extension method to make sense of these signatures:

[source,kotlin]
----
fun <T: PB> PointPB<PointPB<PointPB<T>>>.build() =
    Polygon(points)
----

As you can see, the `build()` method is quite literally counting the points by inspecting the type signature of the receiver.

=== Builder Chain

Sometimes you want to construct an object in stages, either for better readability or for more control over the life cycle. E.g. for a SQL query, you might want to define separate builders for the SELECT part, for the FROM part and for the WHERE part.

=== Chameleon Builder


=== Conclusion