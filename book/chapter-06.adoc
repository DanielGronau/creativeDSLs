== Builder Pattern DSLs

A common task is the initialization of a complex, sometimes nested object. The classical solution for this is the Builder Pattern. The builder class is mutable, uses method chaining (a.k.a. "((Fluent Interfaces))") to simplify value assignments, and contains a terminal build method, which constructs the domain object.

This chapter covers the classical builder as often used in Java. Sometimes this is overkill is Kotlin, as named arguments can be used for smaller classes. Next, we will address the problem of mandatory fields in builders by presenting the Typesafe Builder Pattern. The following three sections cover some more exotic variations: Builders that can count, chains of builders and chameleon builders. In the conclusion section we discuss why in Kotlin builders are not as widely used as in Java.

=== Classical Builder

As an example for a classical builder with realistic complexity, we can use `java.net.http.HttpRequest`, which is written in Java. A typical builder call could look like this:

[source,kotlin]
.See https://docs.oracle.com/en/java/javase/18/docs/api/java.net.http/java/net/http/HttpRequest.Builder.html
----
val request = HttpRequest.newBuilder(URI.create("https://acme.com:9876/products"))
    .GET()
    .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
    .header("Accept-Encoding", "gzip, deflate")
    .timeout(Duration.ofSeconds(5L))
    .build()
----

If you want to write a builder in Kotlin, you can take advantage of the `apply()` or `also()` method. Consider this example:

[source,kotlin]
----
class Person(val firstName: String, val lastName: String, val age: Int?)

class PersonBuilder {
    private var firstName: String? = null
    private var lastName: String? = null
    private var age: Int? = null

    fun setFirstName(firstName: String): PersonBuilder {
        this.firstName = firstName
        return this
    }

    fun setLastName(lastName: String): PersonBuilder {
        this.lastName = lastName
        return this
    }

    fun setAge(age: Int): PersonBuilder {
        this.age = age
        return this
    }

    fun build() = Person(firstName!!, lastName!!, age)
}
----

This looks pretty much like you would write the builder in Java, but using `apply()` is shorter and looks more idiomatic:

[source,kotlin]
----
class PersonBuilder {
    private var firstName: String? = null
    private var lastName: String? = null
    private var age: Int? = null

    fun setFirstName(firstName: String) = apply {
        this.firstName = firstName
    }

    fun setLastName(lastName: String) = apply {
        this.lastName = lastName
    }

    fun setAge(age: Int) = apply {
        this.age = age
    }

    fun build() = Person(firstName!!, lastName!!, age)
}
----

=== Named Arguments instead of Builders

In Kotlin, you might not need a builder, because the language has already features like named and default arguments. E.g. take this implementation of an RGBA color:

[source,kotlin]
----
data class Color(val red: Int, val green: Int, val blue: Int, val alpha: Int = 255)

val c = Color(0, 100, 130, 200)
----

Written like this, the four `Int` values might be a little confusing to read, especially when you expect only three values as for RGB colors. However, instead on relying on a builder, you can simply clarify the meaning by rewriting the last line as follows:

[source,kotlin]
----
val c = Color(red = 0, green = 100, blue = 130, alpha = 200)
----

`Color` is immutable, but if you want to get changed copies of it, you can use the `copy()` method, like this:

[source,kotlin]
----
val c = Color(0, 100, 130, 200)
val c1 = c.copy(red = 120)
----

The `copy()` method is autogenerated for all data classes. In Java, you would have to write a method equivalent to `fun withRed(r: Int): Color`. Such methods might be necessary in Kotlin when you can't use data classes, but they are less common than in Java.

=== The Typesafe Builder Pattern

A common weakness of builders is that you can't enforce that mandatory fields are set. Of course, conditions like these should be always checked in the build method, but it would be nice if already the compiler could prevent you from attempting to build incomplete objects.

Although it requires some boilerplate code, you can use generics to keep track of the state of mandatory fields, and adapt the build method to accept only correctly filled out builders. As the generic signature of the builder must change for this to work, you can't use a single mutable builder, so the setter methods return new builders.

As an example, consider the following class for a product, which requires a product id, the name and the price, while the other attributes are optional:

[source,kotlin]
----
 data class Product(
    val id: UUID,
    val name: String,
    val price: BigDecimal,
    val description: String?,
    val images: List<URI>)
----

The first ingredient to our builder are three classes as a common prerequisite. They are similar to `Optional`, with the difference that the empty and full state are represented by different subclasses. The type parameter `T: Any` was used instead of just `T`, because it prevents `T` from being inhabited by a nullable type.

[source,kotlin]
----
sealed class Val<T: Any>
class Without<T: Any> : Val<T>()
class With<T: Any>(val value: T): Val<T>()
----

With the help of these classes, we can write the builder:

[source,kotlin]
----
data class ProductBuilder<
      ID: Val<UUID>,
      NAME: Val<String>,
      PRICE: Val<BigDecimal>>(
    val id: ID,
    val name: NAME,
    val price: PRICE,
    val description: String?,
    val images: List<URI>) {
    ...
}
----

That's a scary looking generic signature, but the basic idea is simple: Every mandatory field gets a separate type parameter, which keeps track whether it is already set or not. We could use the constructor to start the building process, but a helper function is more convenient:

[source,kotlin]
----
fun productBuilder() = ProductBuilder(
    id = Without(),
    name = Without(),
    price = Without(),
    description = null,
    images = listOf()
)
----

Thankfully, we don't have to write all the generic signatures, but the inferred return type of this function is `ProductBuilder<Without<UUID>, Without<String>, Without<BigDecimal>>`. When an optional field is set, these type parameters don't change, but when a mandatory field is set, the signature will change from `Without` to `With` for this particular field. Here is the complete builder class:

[source,kotlin]
----
data class ProductBuilder<
      ID: Val<UUID>,
      NAME: Val<String>,
      PRICE: Val<BigDecimal>>(
    val id: ID,
    val name: NAME,
    val price: PRICE,
    val description: String?,
    val images: List<URI>) {
        fun id(uuid: UUID) =
            ProductBuilder(With(uuid), name, price, description, images)
        fun name(n: String) =
            ProductBuilder(id, With(n), price, description, images)
        fun price(p: BigDecimal) =
            ProductBuilder(id, name, With(p), description, images)
        fun description(desc: String) = copy(description = desc)
        fun addImage(img: URI) = copy(images = images + img)
}
----

Again, type inference saves us from a lot of typing, but the setters for the mandatory fields return a builder with a changed signature. That's why you can't use the `copy()` methods in this case.

Of course, one crucial part is missing: The `build()` method. However, we can't write it as part of the builder class, as it needs to inspect the generic signature. It has to be an extension method, because only there you can "fix" the type parameters to concrete types (a.k.a. <<chapter-04.adoc#typeNarrowing, Type Narrowing>>):

[source,kotlin]
----
fun ProductBuilder<With<UUID>, With<String>, With<BigDecimal>>.build() =
    Product(id.value, name.value, price.value, description, images)
----

Note how you can access the `value` fields of the `With` classes, because the extension method is only applicable on a fully set builder. Now we have a builder with a `build()` method that can be only called if all mandatory fields are set.

NOTE: The Typesafe Builder Pattern is an example of type-level programming. The pattern was pioneered by http://blog.rafaelferreira.net/2008/07/type-safe-builder-pattern-in-scala.html[Rafael Ferreira] in Scala, using ideas from Haskell. The code shown here is based on the implementation of http://dcsobral.blogspot.de/2009/09/type-safe-builder-pattern.html[Daniel Sobral].

=== Counting Builder

I have to admit that this is one of the more exotic builder variations, but I decided to include it because it is an interesting technique, and because this kind of construction might be useful in other contexts.

Consider the following `Polygon` class, which could be part of a graphics library:

[source,kotlin]
----
import java.awt.geom.Point2D

data class Polygon(val points: List<Point2D>)
----

However, a problem arises when we want to ensure that polygons are constructed with at least three points. To solve this issue, we could create a builder that counts the number of points added and only allows the construction of polygons with three or more points.

While the obvious solution is to check the number of points at runtime, we can achieve better safety by preventing the creation of an invalid builder at compile time. This can be achieved by using a recursive type parameter to keep track of the number of points. Though this may seem odd at first, the implementation is quite simple:

[source,kotlin]
----
sealed interface Nat
interface Z : Nat
interface S<N : Nat> : Nat

class PolygonBuilder<N : Nat> private constructor() {

    companion object {
        operator fun invoke() =
            PolygonBuilder<Z>()
    }

    val points: MutableList<Point2D> =
        mutableListOf()

    @Suppress("UNCHECKED_CAST")
    fun add(point: Point2D) =
        (this as PolygonBuilder<S<N>>)
            .also { points += point }
}

fun <N : Nat> PolygonBuilder<S<S<S<N>>>>.build() = Polygon(points)
----

First, we create a sealed interface `Nat` to represent the natural numbers, and two sub-interfaces, `Z` representing zero and `S<N>` representing the successor of a natural number `N`. For instance, the number 3 would be written as `S<S<S<Z>>>`. This is called the Peano representation of the natural numbers. Note that even if we don't know the innermost part of `S<S<S<...>>>`, we can still deduce that the given number is greater or equal to 3, which is exactly what we need to check our condition. These recursively constructed numbers are used by the builder class as a generic "counter" parameter holding the number of points in the list.

The builder class must hide its constructor, because a call like `PolygonBuilder<S<S<Z>>>()` would initialize the builder with a wrong counter. That's why we build a "fake constructor" using the `invoke()` operator in the companion object, which returns only builders with the counter initially set to 0. The `add()` method appends a point to the list, but also casts the instance to one with an incremented counter. This is safe, as the counter is a phantom type(((Phantom Type))). Alternatively, we also could have constructed a new builder object on every `add()` call.

The last part is the `build()` method, which has to be an extension function, for the same reasons as in the typesafe builder example. The function is "counting" the points by inspecting the type signature of the builder. This is how a usage of our builder could look like:

[source,kotlin]
----
val polygon = PolygonBuilder()
    .add(Point2D.Double(1.0, 2.3))
    .add(Point2D.Double(2.1, 4.5))
    .add(Point2D.Double(2.4, 5.0))
    .build()
----

If one of the `add()` calls is removed, the code will no longer compile, as the type of the `PolygonBuilder` does no longer comply with the signature of the `build()` extension function.

=== Builder Chain

Sometimes you want to construct an object in stages, either for better readability or for more control over the life cycle. E.g. for a SQL query, you might want to define separate builders for the SELECT, FROM and WHERE part. As the SQL language is very complex, this is just a simplified example. A show-case for a serious implementation of SQL queries and expressions using builders is the Java library https://www.jooq.org/[jOOQ].

The final DSL will allow to write basic SQL queries like this:

[source,kotlin]
----
val query = select("p.firstName", "p.lastName", "p.income")
    .from("Person", "p")
    .join("Address", "a").on("p.addressId","a.id")
    .where("p.age > 20")
    .and("p.age <= 40")
    .and("a.city = 'London'")
----

Let's start with the SELECT part, which is straightforward:

[source,kotlin]
----
fun select(vararg columns: String) = SelectClause(*columns)

class SelectClause(vararg val columns: String) {

    fun from(tableName: String) =
        FromClause(columns.asList(), tableName to null)

    fun from(tableName: String, alias: String) =
        FromClause(columns.asList(), tableName to alias)
}
----

There is no `build()` method, the only way forward is going into the `FromClause`, which is a bit more involved, as there might be multiple tables joined together:

[source,kotlin]
----
data class FromClause(
    val columns: List<String>,
    val tableName: NameWithAlias,
    val joinClauses: List<Triple<NameWithAlias, String, String>> = emptyList()
) {

    fun join(tableName: String) =
        JoinClause(this, tableName to null)

    fun join(tableName: String, alias: String) =
        JoinClause(this, tableName to alias)

    fun where(condition: String) =
        WhereClause(columns, tableName, joinClauses, listOf(condition))

    fun build() = build(columns, tableName, joinClauses, emptyList())
}
----

From here, you can go to a `JoinClause`, which mimics the SQL syntax by permitting to write something like `fromClause.join("Address","a").on("p.addressId", "a.id")`. The other exit point is to start a `WhereClause`. Additionally, the `FromClause` has a `build()` method, because the where part is optional.

The `JoinClause` offers just an `on()` method, which leads back to the `FromClause`. Note that when constructing the `JoinClause`, it gets the calling `FromClause` as an argument, which is a neat trick to avoid passing around all the data separately, and allows to employ the power of the `copy()` method:

[source,kotlin]
----
data class JoinClause(val fromClause: FromClause, val tableName: NameWithAlias) {

    fun on(firstColumn: String, secondColumn: String) =
        fromClause.copy(joinClauses =
           fromClause.joinClauses + Triple(tableName, firstColumn, secondColumn))
}
----

The `WhereClause` is quite simple, but of course using `String` to represent the different conditions is not very safe and should be avoided in production code. The SQL syntax allows other clauses like `HAVING` and `ORDER BY` after `WHERE`, but for brevity the example stops here, so after all conditions are set, the only thing to do is calling the `build()` method:

[source,kotlin]
----
data class WhereClause(
    val columns: List<String>,
    val tableName: NameWithAlias,
    val joinClauses: List<Triple<NameWithAlias, String, String>>,
    val conditions: List<String>
) {

    fun and(condition: String) =
        copy(conditions = conditions + condition)

    fun build() =
        build(columns, tableName, joinClauses, conditions)
}
----

The only missing part is the common `build()` method used by `FromClause` and `WhereClause`:

[source,kotlin]
----
private fun build(
    columns: List<String>,
    tableName: NameWithAlias,
    joinClauses: List<Triple<NameWithAlias, String, String>>,
    conditions: List<String>
): String {

    val sb = StringBuilder()
        .append("SELECT ${columns.joinToString(", ")}")
        .append("\nFROM ")
        .append(nameWithAlias(tableName))

    joinClauses.forEach { (n, c1, c2) ->
        sb.append("\n  JOIN ${nameWithAlias(n)} ON $c1 = $c2")
    }

    if (conditions.isNotEmpty()) {
        sb.append("\nWHERE ${conditions.joinToString("\n  AND ")}")
    }

    sb.append(';')

    return sb.toString()
}

private fun nameWithAlias(name: NameWithAlias) = when (name.second) {
    null -> name.first
    else -> "${name.first} AS ${name.second}"
}
----

In the next section, we will look at an alternative implementation of the same DSL.

=== Chameleon Builder

A chained builder can get quite messy because of all the data being copied around. It would be nice to keep the data all in one class, but what is with all the guarantees a chained builder provides, e.g. that you can't call `build()` or `join()` in a select clause? To achieve this, we first need to translate our former chained builders into interfaces:

[source,kotlin]
----
typealias NameWithAlias = Pair<String, String?>

interface SelectClause {
    fun from(table: String): FromClause
    fun from(table: String, alias: String): FromClause
}

interface FromClause{
    fun join(tableName: String): JoinClause
    fun join(tableName: String, alias: String): JoinClause
    fun where(condition: String): WhereClause
    fun build(): String
}

interface JoinClause {
    fun on(firstColumn: String, secondColumn: String): FromClause
}

interface WhereClause {
    fun and(condition: String): WhereClause
    fun build(): String
}
----

Now all we need is to implement these interfaces in one builder class, and to keep track of the data. Also, we need a method to create this builder, which we place in the companion object:

[source,kotlin]
----
class QueryBuilder private constructor (val columns: List<String>):
        SelectClause, FromClause, JoinClause, WhereClause {

    var tableName : NameWithAlias = "" to null
    var joinTableName : NameWithAlias = "" to null
    val joinClauses = mutableListOf<Triple<NameWithAlias, String, String>>()
    val conditions = mutableListOf<String>()

    companion object {
        fun select(vararg columns: String): SelectClause =
            QueryBuilder(columns.asList())
    }

    //SelectClause
    override fun from(table: String): FromClause =
        this.apply { tableName = table to null }

    override fun from(table: String, alias: String): FromClause =
        this.apply { tableName = table to alias }

    //FromClause
    override fun join(table: String): JoinClause =
        this.apply { joinTableName = table to null }

    override fun join(table: String, alias: String): JoinClause =
        this.apply { joinTableName = table to alias }

    override fun where(condition: String): WhereClause =
        this.apply { conditions += condition }

    //JoinClause
    override fun on(firstColumn: String, secondColumn: String): FromClause =
        this.apply { joinClauses += Triple(joinTableName, firstColumn, secondColumn) }

    //WhereClause
    override fun and(condition: String): WhereClause =
        this.apply { conditions += condition }

    //FromClause and WhereClause
    override fun build(): String {
        // same as in previous section
    }
}
----

For the compiler, it doesn't matter that you give back the same object over and over again at runtime, because the static type decides which methods can be called, and this static type is never `QueryBuilder`, but always one of the interfaces for the SQL clauses. Calling the DSL looks as before, and you still can't call methods out of order (at least not without casting).

While the chained builder approach is conceptually simple, it leads to a lot of boilerplate code. The chameleon builder concept might look somewhat strange at first, but results usually in more readable code. However, be aware that this approach is susceptible to name clashes, which occur when the same method signature is used with different return types by multiple interfaces.

=== Conclusion

The Builder Pattern is quite popular in Java - there are even libraries like https://projectlombok.org/[Project Lombok] which generate builders for you. The downside is that builders are quite inflexible and might be not very safe to use (although variations like the Typesafe Builder Pattern can help). The next chapter will present an approach which is more common in Kotlin, and has some advantages over the Builder Pattern.

==== Preferable Use Cases

* Creating data
* Generating code
* Configuring systems
* Testing
* Logging

==== Rating

* image:4_sun.png[] - for Simplicity of DSL design
* image:2_sun.png[] - for Elegance
* image:3_sun.png[] - for Usability
* image:4_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* easy to understand
* applicable for a wide range of construction tasks
* variations of the pattern can fix some of its shortcomings
* can be autogenerated (e.g. using https://projectlombok.org[Project Lombok])
* easy to use from Java client code

|* often not the most natural syntax for the problem
* nested builders don't look nice
* inflexible structure
* boilerplate code (e.g. need for a `build()` method)
* assignments are disguised as method calls
|===
