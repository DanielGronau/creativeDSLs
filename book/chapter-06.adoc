== Builders

A common task is the initialization of a complex, sometimes nested object. The classical solution for this is the Builder Pattern. The builder class is mutable, uses method chaining (a.k.a. "Fluent Interfaces") to simplify value assignments, and contains a terminal build method, which constructs (hopefully after some sanity checks) the domain object.

As an example for a classical builder with a bit of realistic complexity, we can use `java.net.http.HttpRequest`, which is written in Java. A typical builder call could look like this:

[source,kotlin]
----
val request = HttpRequest.newBuilder(URI.create("https://acme.com:9876/products"))
    .GET()
    .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
    .header("Accept-Encoding", "gzip, deflate")
    .timeout(Duration.ofSeconds(5L))
    .build()
----

There are several alternatives or extension for the Builder Pattern. We will discuss these with shorter examples, and close this chapter with a case study for improving the builder above using extension methods.

=== Named Arguments instead of Builders

In Kotlin, you might not need a builder, because the language has already features like named and default arguments. E.g. take this implementation of an RGBA color:

[source,kotlin]
----
data class Color(val red: Int, val green: Int, val blue: Int, val alpha: Int = 255)

val c = Color(0, 100, 130, 200)
----

Written like this, the four `Int` values might be a little confusing to read, especially when you expect only three values as for RGB colors. But you don't need a builder in this case, you can clarify the meaning by rewriting the last line as follows:

[source,kotlin]
----
val c = Color(red = 0, green = 100, blue = 130, alpha = 200)
----

=== The Typesafe Builder Pattern

A common weakness of builders is that you can't enforce that mandatory fields are set. Of course, conditions like these should be always checked in the build method, but it would be nice if already the compiler could prevent you from attempting to build incomplete objects.

Although it requires some boilerplate code, you can use generics to keep track of the state of mandatory fields, and adapt the build method to accept only correctly filled out builders. As the generic signature of the builder must change for this to work, you can't use a single mutable builder, so the setter methods return new builders.

As an example, consider the following class for a product, which needs to have product id, name and price set, while the other attributes are optional:

[source,kotlin]
----
 data class Product(
    val id: UUID,
    val name: String,
    val price: BigDecimal,
    val description: String?,
    val images: List<URI>)
----

The first ingredient to our builder are three classes as a common prerequisite. They are similar to `Optional`, with the difference that the empty and full state are represented by different classes. In case you wonder why `T: Any` was used instead of simply `T`, this prevents `T` from being inhabited by a nullable type.

[source,kotlin]
----
sealed class Mandatory<T: Any>
class Without<T: Any> : Mandatory<T>()
class With<T: Any>(val value: T): Mandatory<T>()
----

With the help of these classes, we can write the builder:

[source,kotlin]
----
data class ProductBuilder<ID: Mandatory<UUID>, NAME: Mandatory<String>, PRICE: Mandatory<BigDecimal>>(
val id: ID, val name: NAME, val price: PRICE, val description: String?, val images: List<URI>) {
    ...
}
----

That's a scary looking signature, but it isn't really hard to understand: Every mandatory field gets a separate type parameter, which keeps track whether it is already set or not. We could use the constructor to start the building process, but a helper function is more convenient:

[source,kotlin]
----
fun productBuilder() = ProductBuilder(
    id = Without(),
    name = Without(),
    price = Without(),
    description = null,
    images = listOf()
)
----

Thankfully, we don't have to write all the generic signatures, but the inferred return type of this function is `ProductBuilder<Without<UUID>, Without<String>, Without<BigDecimal>>`.

Now you can hopefully anticipate how the generics keep track of the mandatory fields. Basically, when an optional field is set, the type parameters don't change, but when a mandatory field is set, the signature will change from `Without` to `With` for this particular field. Here is the complete builder class:

[source,kotlin]
----
data class ProductBuilder<ID : Mandatory<UUID>, NAME : Mandatory<String>, PRICE : Mandatory<BigDecimal>>(
    val id: ID, val name: NAME, val price: PRICE, val description: String?, val images: List<URI>
) {
    fun id(uuid: UUID) = ProductBuilder(With(uuid), name, price, description, images)
    fun name(n: String) = ProductBuilder(id, With(n), price, description, images)
    fun price(p: BigDecimal) = ProductBuilder(id, name, With(p), description, images)
    fun description(desc: String) = copy(description = desc)
    fun addImage(img: URI) = copy(images = images + img)
}
----

Again, type inference safes us from a lot of typing, but the setters for the mandatory fields return a builder with a changed signature. That's why you can't use the `copy()` methods in this case.

Of course, one crucial part is missing: The `build()` method. However, we can't write it as part of the class, as it needs to inspect the generic signature. It has to be an extension method, because there you can "fix" the type parameters to concrete types:

[source,kotlin]
----
fun ProductBuilder<With<UUID>, With<String>, With<BigDecimal>>.build() =
    Product(id.value, name.value, price.value, description, images)
----

Note how you can access the `value` fields of the `With` classes, because the extension method is only applicable on a fully set builder. Now we have a builder with a `build()` method that can be only called if all mandatory fields are set.

NOTE: The Typesafe Builder Pattern is an example of type-level programming, where the compiler is used to perform checks or even calculations, and hence giving more control over the behavior of the affected classes. The pattern was pioneered by http://blog.rafaelferreira.net/2008/07/type-safe-builder-pattern-in-scala.html[Rafael Ferreira] in Scala, using ideas from Haskell. The code shown here is based on the implementation of http://dcsobral.blogspot.de/2009/09/type-safe-builder-pattern.html[Daniel Sobral].

=== Chameleon Builders


## Fallstudie: HttpRequest

Als ein realistisches Beispiel kann `java.net.http.HttpRequest` dienen, dessen
Aufruf etwa so aussehen kann:

```kotlin
val request = HttpRequest.newBuilder(URI.create("https://acme.com:9876/products"))
    .GET()
    .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
    .header("Accept-Encoding", "gzip, deflate")
    .timeout(Duration.ofSeconds(5L))
    .build()
```
Das sieht schon nicht schlecht aus, aber es gibt immer noch die störenden Aufrufe
von newBuilder() und build(), und in der Syntax wird nicht deutlich, dass die
Methodenaufrufe eigentlich nur Wertzuweisungen sind. Die Frage ist, ob wir es in
Kotlin besser machen können.

Wenn wir uns an den Prozess zum DSL-Design erinnern, folgt auf die Anforderungsanalyse
(hier wäre das einfach, `HttpRequest` komfortabler zu konstruieren) das Brainstorming
für eine ideale Syntax. Natürlich ist immer subjektiv, was als "ideal" angesehen wird,
aber ich hoffe, dass der folgende Vorschlag wenigstens eine Verbesserung
gegenüber dem Original darstellt:

```kotlin
val request = httpRequest(URI.create("https://acme.com:9876/products")) {
      method = GET
      headers {
        "Content-Type" .. "application/x-www-form-urlencoded; charset=UTF-8"
        "Accept-Encoding" .. "gzip, deflate"
      }
      timeout = 5 * SECONDS
    }
```
Es stellt sich heraus, dass diese Syntax auch so umsetzbar ist.

Dabei ist `httpRequest` eine Methode, die uns unsere Version des Builders zur Verfügung
stellt, aber Konstruktion und Finalisierung für uns übernimmt. Damit handelt es sich
um eine Anwendung des Loan-Patterns, dass sich in vielen Fällen als nützlich beim
DSL-Design erweist. Die Implementierung der Methode ist trivial:

```kotlin
fun httpRequest(uri: URI, block: HttpRequestBuilder.() -> Unit): HttpRequest =
    HttpRequestBuilder(uri).apply(block).build()
```

Unser Builder hält intern einen "originalen" Builder, und delegiert auch den Aufruf der
`build()`-Methode:

```kotlin
class HttpRequestBuilder(val uri: URI) {
    private val peer = HttpRequest.newBuilder(uri)
    ...
    fun build(): HttpRequest {
        ...
        peer.build()
    }
}
```

Für die HTTP-Methode wird es ein wenig komplizierter, da sie mit oder ohne Body kommen
kann. Zuerst definieren wir einen Typ-Alias, und dann ein paar vorgefertigte Konstanten
und Methoden. In der build-Methode werden die Variable dann ausgelesen, wobei wir
leider nicht um eine Fallunterscheidung herumkommen:

```kotlin
typealias HttpMethod = Pair<String, BodyPublisher?>

class HttpRequestBuilder(uri: URI) {
    private val peer = HttpRequest.newBuilder(uri)

    val GET: HttpMethod = "GET" to null
    val DELETE: HttpMethod = "DELETE" to null
    fun PUT(bp: BodyPublisher): HttpMethod = "PUT" to bp
    fun POST(bp: BodyPublisher): HttpMethod = "POST" to bp

    var method: HttpMethod? = null
    ...
    fun build(): HttpRequest {
        method?. let {
            when (method) {
                GET -> peer.GET()
                DELETE -> peer.DELETE()
                else -> peer.method(method!!.first, method!!.second)
            }
        }
        ...
        peer.build()
    }
}
```

Es sei angemerkt, dass man nicht auf die vier vorgegebenen HTTP-Methoden
GET, DELETE, PUT und POST beschränkt ist, man kann auch einfach etwas wie
`method = "OPTION" to someBodyPublisher` schreiben.

Für die Header verwenden wir dieselbe Loan-Pattern-Technik wie zuvor. Durch
Verwendung einer inneren Klasse braucht man den originalen Builder nicht
"durchzureichen", sondern kann direkt darauf zugreifen. Ob man den
Range-Operator `..` hier so zweckentfremden sollte, ist eine Geschmacksfrage,
mich persönlich erinnert er an einen Doppelpunkt.

```kotlin
class HttpRequestBuilder(uri: URI) {
    private val peer = HttpRequest.newBuilder(uri)
    ...
    fun headers(block: Headers.() -> Unit) {
        Headers().apply(block)
    }
    ...
    inner class Headers {
        operator fun String.rangeTo(value: String) {
            peer.header(this@rangeTo, value)
        }
    }
}
```

Alle anderen Variablen werden einfach in der build-Methode ausgelesen und
am originalen Builder gesetzt. Für die `Duration` wurde noch eine vereinfachte
Schreibweise unterstützt (es gibt ab auch ein experimentelles Feature in
`kotlin.time`, das die Syntax `5.seconds` unterstützt, aber als "deprected"
gekennzeichnet ist). Hier ist die gesamte Implementierung:

```kotlin
import java.net.URI
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpRequest.BodyPublisher
import java.time.Duration
import java.time.temporal.TemporalUnit

fun httpRequest(uri: URI, block: HttpRequestBuilder.() -> Unit): HttpRequest =
    HttpRequestBuilder(uri).apply(block).build()

typealias HttpMethod = Pair<String, BodyPublisher?>

class HttpRequestBuilder(uri: URI) {

    private val peer = HttpRequest.newBuilder(uri)

    val GET: HttpMethod = "GET" to null
    val DELETE: HttpMethod = "DELETE" to null
    fun PUT(bp: BodyPublisher): HttpMethod = "PUT" to bp
    fun POST(bp: BodyPublisher): HttpMethod = "POST" to bp

    var method: HttpMethod? = null
    var timeout: Duration? = null
    var expectContinue: Boolean? = null
    var version: HttpClient.Version? = null

    fun headers(block: Headers.() -> Unit) {
        Headers().apply(block)
    }

    fun build(): HttpRequest {
        timeout?.let { peer.timeout(it) }
        expectContinue?.let { peer.expectContinue(it) }
        version?.let { peer.version(it) }
        method?. let {
            when (method) {
                GET -> peer.GET()
                DELETE -> peer.DELETE()
                else -> peer.method(method!!.first, method!!.second)
            }
        }
        return peer.build()
    }

    inner class Headers {
        operator fun String.rangeTo(value: String) {
            peer.header(this@rangeTo, value)
        }
    }

    operator fun Long.times(unit: TemporalUnit): Duration = Duration.of(this, unit)
    operator fun Int.times(unit: TemporalUnit): Duration = Duration.of(this.toLong(), unit)
}
```

