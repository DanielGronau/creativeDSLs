== Builder Pattern DSLs

A common task is the initialization of a complex, sometimes nested object. The classical solution for this is the Builder Pattern. The builder class is mutable, uses method chaining (a.k.a. "((Fluent Interfaces))") to simplify value assignments, and contains a terminal build method, which constructs the domain object.

This chapter covers the classical builder pattern as often used in Java. Sometimes this is overkill is Kotlin, as named arguments can be used for smaller classes. We will also discuss nesting builders. Next, we will address the problem of mandatory fields in builders by presenting the _Typesafe Builder Pattern_. Finally, we will cover the more exotic _Counting Builder_. In the conclusion section we discuss why in Kotlin builders are not as widely used as in Java.

=== Classical Builder

As an example for a classical builder with realistic complexity, we can use `java.net.http.HttpRequest`, which is written in Java. A typical builder call could look like this:

[source,kotlin]
.See https://docs.oracle.com/en/java/javase/18/docs/api/java.net.http/java/net/http/HttpRequest.Builder.html
----
val request = HttpRequest.newBuilder(URI.create("https://acme.com:9876/products"))
    .GET()
    .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
    .header("Accept-Encoding", "gzip, deflate")
    .timeout(Duration.ofSeconds(5L))
    .build()
----

As this example illustrates, a builder has three parts:

* *Builder Initialization:* The builder requires a starting point, which can be achieved through a constructor or a factory method. This initializes the builder instance and prepares it for data collection.
* *Data Collection:* Through method chaining, the builder instance accumulates the necessary data and configuration options. Each method call adds a specific attribute or behavior to the final object being constructed.
* *Target Object Construction*: To finalize the construction process, a terminal method, often named `build()`, is invoked. This method performs any necessary validation on the collected data and proceeds to instantiate the target object with the provided configuration.

By following this pattern, builders offer a structured approach to construct objects with customizable parameters, providing a convenient and readable way to initialize complex objects in a flexible manner.

If you want to write a builder in Kotlin, you can take advantage of the `apply()` or `also()` method. Consider this example:

[source,kotlin]
----
class Person(val firstName: String, val lastName: String, val age: Int?)

class PersonBuilder {
    private var firstName: String? = null
    private var lastName: String? = null
    private var age: Int? = null

    fun setFirstName(firstName: String): PersonBuilder {
        this.firstName = firstName
        return this
    }

    fun setLastName(lastName: String): PersonBuilder {
        this.lastName = lastName
        return this
    }

    fun setAge(age: Int): PersonBuilder {
        this.age = age
        return this
    }

    fun build() = Person(firstName!!, lastName!!, age)
}
----

This looks pretty much like you would write the builder in Java, but using `apply()` is shorter and more idiomatic:

[source,kotlin]
----
class PersonBuilder {
    private var firstName: String? = null
    private var lastName: String? = null
    private var age: Int? = null

    fun setFirstName(firstName: String) = apply {
        this.firstName = firstName
    }

    fun setLastName(lastName: String) = apply {
        this.lastName = lastName
    }

    fun setAge(age: Int) = apply {
        this.age = age
    }

    fun build() = Person(firstName!!, lastName!!, age)
}
----

=== Named Arguments instead of Builders

In Kotlin, you might not need a builder, because the language contains features like named and default arguments, which can provide a similar functionality. Take this implementation of an RGBA color:

[source,kotlin]
----
data class Color(
    val red: Int,
    val green: Int,
    val blue: Int,
    val alpha: Int = 255
)

val c = Color(0, 100, 130, 200)
----

Written like this, the four `Int` values might be a little confusing to read, especially when you expect only three values as for RGB colors. However, instead on relying on a builder, you can simply clarify the meaning by rewriting the last line as follows:

[source,kotlin]
----
val c = Color(
    red = 0,
    green = 100,
    blue = 130,
    alpha = 200
)
----

The syntax differs, but functionality-wise this code resembles closely a builder. Of course, as for a builder, the arguments can be listed in any order. A noteworthy difference of named arguments is that every argument can be set only once, while a builder allows to set and - depending on the implementation - possibly overwrite an argument value multiple times.

`Color` is immutable, but if you want to get modified copies of it, you can use the `copy()` method, like this:

[source,kotlin]
----
val c = Color(0, 100, 130, 200)
val c1 = c.copy(red = 120)
----

The `copy()` method is autogenerated for all data classes. In Java, you would have to write a method equivalent to `fun withRed(r: Int): Color` (sometimes called _wither_ similar to "getter" and "setter"). Such methods might be necessary in Kotlin when you can't use data classes, but they are less common than in Java.

=== Nesting Builders

When an object has complex components, it makes sense to have not only a top-level builder, but also builders for these components, their own subcomponents, etc. A typical example for such nested builders is the DSL of the https://square.github.io/kotlinpoet/[KotlinPoet] library:

[source,kotlin]
.https://square.github.io/kotlinpoet/
----
val file = FileSpec.builder("", "HelloWorld")
  .addType(
    TypeSpec.classBuilder("Greeter")
      .primaryConstructor(
        FunSpec.constructorBuilder()
          .addParameter("name", String::class)
          .build()
      )
      .addProperty(
        PropertySpec.builder("name", String::class)
          .initializer("name")
          .build()
      )
      .addFunction(
        FunSpec.builder("greet")
          .addStatement("println(%P)", "Hello, \$name")
          .build()
      )
      .build()
  )
  .addFunction(
    FunSpec.builder("main")
      .addParameter("args", String::class, VARARG)
      .addStatement("%T(args[0]).greet()", greeterClass)
      .build()
  )
  .build()
----

As this example demonstrates, the necessity to call `build()` at the end of every nested builder leads to a lot of visual clutter. To avoid this issue, some DSLs make builder nesting more convenient by having two versions of every "nested" method: One version that takes as usual the constructed object as argument, and another version that accepts a builder of the object instead. This way, the user doesn't need to call repeatedly `build()` methods for the nested builders.

=== Flattening instead of Nesting

An alternative to nesting builders is to handle everything in the top-level builder, by putting the nested content between a start and end method. In KotlinPoet, control flows are implemented this way:

[source,kotlin]
----
val funSpec = FunSpec.constructorBuilder()
    .addParameter("value", String::class)
    .beginControlFlow("require(value.isNotEmpty())")
    .addStatement("%S", "value cannot be empty")
    .endControlFlow()
    .build()
----

Using this approach can make the DSL code more readable, but it requires more discipline from the user, who has to ensure that the start and end methods are placed properly.

To give an example implementation, consider a person class containing a name, a phone number and a list of contacts, which in turn also have a name, and optionally a phone:

[source,kotlin]
----
data class Contact(val name: String, val phone: String?)

data class Person(val name: String, val phone: String, val contacts: List<Contact>)

class PersonBuilder {
    private var name: String? = null
    private var phone: String? = null
    private var addingContact = false
    private var contactName: String? = null
    private var contactPhone: String? = null
    private val contacts: MutableList<Contact> = mutableListOf()

    fun beginContact() = apply {
        require(!addingContact)
        addingContact = true
    }

    fun endContact() = apply {
        require(addingContact)
        contacts.add(Contact(contactName!!, contactPhone))
        contactName = null
        contactPhone = null
        addingContact = false
    }

    fun setName(name: String) = apply {
        if (addingContact) this.contactName = name else this.name = name
    }

    fun setPhone(phone: String) = apply {
        if (addingContact) this.contactPhone = phone else this.phone = phone
    }

    fun build(): Person {
        require(!addingContact)
        return Person(name!!, phone!!, contacts)
    }
}
----

And this is how the DSL could be used:

[source,kotlin]
----
val superman = PersonBuilder()
    .setName("Superman")
    .beginContact()
    .setName("Wonder Woman")
    .endContact()
    .setPhone("555-3213-125")
    .beginContact()
    .setName("Lois Lane")
    .setPhone("555-4112-423")
    .endContact()
    .build()
----

The process flow of a flattened builder can be also regarded as a very simple state transition, namely from the outer level to the inner level and back. xref:chapter-08.adoc[Chapter 8] demonstrates techniques to implement such state transitions in a safe way, so the code wouldn't compile when start and end methods are placed incorrectly.

While there are certainly valid use cases for a flattening builder, the usual approach based on nesting is both conceptually and implementation-wise simpler, it also scales better, and should be therefore preferred.

=== The Typesafe Builder Pattern

A common issue with builders is the inability to enforce the setting of mandatory fields. While it's possible to check for these conditions in the build method, it would be better if the compiler could already prevent to build incomplete objects. To achieve this, we can use <<chapter-04.adoc#typeLevelProgramming, type-level programming>>(((Type Level Programming))), although it requires some boilerplate code.

By using generics to track the state of mandatory fields, the build method can be adapted to only accept builders with all mandatory values set. As an example, consider the following class for a product, which requires a product id, the name and the price, while the other attributes are optional:

[source,kotlin]
----
 data class Product(
    val id: UUID,
    val name: String,
    val price: BigDecimal,
    val description: String?,
    val images: List<URI>)
----

The first prerequisite for our builder are three classes for representing the state of the mandatory fields. They are similar to `Optional`, with the difference that the empty and full states are represented by different subclasses. The type parameter `T: Any` was used because it prevents `T` from being inhabited by a nullable type.

[source,kotlin]
----
sealed class Val<T: Any>

class Without<T: Any> : Val<T>()

class With<T: Any>(val value: T): Val<T>()
----

With the help of these classes, we can write the builder:

[source,kotlin]
----
data class ProductBuilder<
      ID: Val<UUID>,
      NAME: Val<String>,
      PRICE: Val<BigDecimal>> private constructor(
    val id: ID,
    val name: NAME,
    val price: PRICE,
    val description: String?,
    val images: List<URI>) {
    ...
}
----

That's a scary looking generic signature, but the basic idea is simple: Every mandatory field gets a separate generic type parameter, which keeps track whether it is already set or not. The constructor was made private, because we want to ensure to start with an empty builder. The construction of the builder class can be delegated to its companion object, where we can "simulate" a constructor using the `invoke` operator:

[source,kotlin]
----
data class ProductBuilder<
      ID: Val<UUID>,
      NAME: Val<String>,
      PRICE: Val<BigDecimal>> private constructor(
    val id: ID,
    val name: NAME,
    val price: PRICE,
    val description: String?,
    val images: List<URI>) {

        companion object {
                inline fun invoke() = ProductBuilder(
                id = Without(),
                name = Without(),
                price = Without(),
                description = null,
                images = listOf()
            )
        }

        fun id(uuid: UUID) =
            ProductBuilder(With(uuid), name, price, description, images)

        fun name(name: String) =
            ProductBuilder(id, With(name), price, description, images)

        fun price(price: BigDecimal) =
            ProductBuilder(id, name, With(price), description, images)

        fun description(desc: String) =
            copy(description = desc)

        fun addImage(image: URI) =
            copy(images = images + image)
}
----

The inferred return type of this `invoke()` operation is `ProductBuilder<Without<UUID>, Without<String>, Without<BigDecimal>>`, which we thankfully don't have to write out. When an optional field is set, these type parameters don't change, but when a mandatory field is set, the signature will change from `Without` to `With` for this particular field. As the setters for the mandatory fields return a builder with a changed signature, we can't use the `copy()` method in these cases (at least if we don't want to use casts).

Of course, one crucial part is missing: The `build()` method. However, we can't write it as part of the builder class, as it needs to inspect the generic signature. It _has_ to be an extension method, because only there you can "fix" the type parameters to concrete types, which is known as <<chapter-04.adoc#typeNarrowing, type narrowing>>(((Type Narrowing))):

[source,kotlin]
----
fun ProductBuilder<With<UUID>, With<String>, With<BigDecimal>>.build() =
    Product(id.value, name.value, price.value, description, images)
----

Note that you can access the `value` fields of the `With` classes, as the type inference matches on the "narrowed down" type. Now we have a builder with a `build()` method that can be only called if all mandatory fields are set:

[source,kotlin]
----
ProductBuilder()
    .id(UUID.randomUUID())
    .name("Comb")
    .description("Green plastic comb")
    .price(12.34.toBigDecimal())
    .build()
----

You can check that the code no longer compiles after removing one of the mandatory fields.

NOTE: The Typesafe Builder Pattern was pioneered by http://blog.rafaelferreira.net/2008/07/type-safe-builder-pattern-in-scala.html[Rafael Ferreira] in Scala, using ideas from Haskell. The code shown here is based on the implementation of http://dcsobral.blogspot.de/2009/09/type-safe-builder-pattern.html[Daniel Sobral].

=== Counting Builder

I have to admit that this is one of the more exotic builder variations, but I decided to include it because it is an interesting technique, and because this kind of construction might be useful in other contexts.

Consider the following `Polygon` class, which could be part of a graphics library:

[source,kotlin]
----
import java.awt.geom.Point2D

data class Polygon(val points: List<Point2D>)
----

However, a problem arises when we want to ensure that polygons are constructed with at least three points. To solve this issue, we could create a builder that counts the number of points added and only allows the construction of polygons with three or more points.

While the obvious solution is to check the number of points at runtime, we can achieve better safety by preventing the creation of an invalid builder at compile time. This can be achieved by using a recursive type parameter to keep track of the number of points, once again employing <<chapter-04.adoc#typeLevelProgramming, type level programming>>(((Type Level Programming))). Though this may seem odd at first, the implementation is quite simple:

[source,kotlin]
----
sealed interface Nat
interface Z : Nat
interface S<N : Nat> : Nat

class PolygonBuilder<N : Nat> private constructor() {

    companion object {
        operator fun invoke() =
            PolygonBuilder<Z>()
    }

    val points: MutableList<Point2D> =
        mutableListOf()

    @Suppress("UNCHECKED_CAST")
    fun add(point: Point2D) =
        (this as PolygonBuilder<S<N>>)
            .also { points += point }
}

fun <N : Nat> PolygonBuilder<S<S<S<N>>>>.build() = Polygon(points)
----

First, we create a sealed interface `Nat` to represent the natural numbers, and two sub-interfaces, `Z` representing zero and `S<N>` representing the successor of a natural number `N`. For instance, the number 3 would be written as `S<S<S<Z>>>`. This is called the "Peano Representation" of the natural numbers. Note that even if we don't know the innermost part of `S<S<S<...>>>`, we can still deduce that the given number is greater or equal to 3, which is exactly what we need to check our condition. These recursively constructed numbers are used by the builder class as a generic "counter" parameter holding the number of points in the list.

.The Peano Axioms
****
When asked to count, the usual response is "zero, one, two, three...", not "zero, successor of zero, successor of successor of zero...", so you might wonder where the strange Peano Representation comes from. In 1889 Giuseppe Peano published his famous nine axioms in order to define natural numbers and their properties in a formal way, and the Peano Representation follows directly from these axioms.

The first axiom covers the existence of zero, the following four axioms cover basic properties of equality (it is reflexive, symmetric, transitive and closed), but the next four axioms rely crucially on the use of the successor function:

* For any natural number, its successor is a natural number as well
* If the successors of two natural numbers are equal, then the numbers themselves are equal, too
* Zero is not the successor of a natural number
* Every natural number can be reached from zero by repeatedly applying the successor function (this is also known as "induction")

That's why from a mathematical point of view, the Peano Representation is the most basic way to write natural numbers, and our usual number systems (decimal, binary, hexadecimal...) could be regarded as convenient abbreviations.
****

The builder class must hide its constructor, because a call like `PolygonBuilder<S<S<Z>>>()` would initialize the builder with a wrong counter. That's why we "simulate" a constructor using the `invoke()` operator in the companion object, which returns only builders with a counter correctly initialized to 0. The `add()` method appends a point to the list, but also casts the instance to one with an incremented counter. This is safe, as the counter is a phantom type(((Phantom Types))). Alternatively, we also could have constructed a new builder object on every `add()` call.

The last ingredient is the `build()` method, which has to be an extension function, for the same reasons as in the typesafe builder example. The function is "counting" the points by inspecting the type signature of the builder. This is how a usage of our builder could look like:

[source,kotlin]
----
val polygon = PolygonBuilder()
    .add(Point2D.Double(1.0, 2.3))
    .add(Point2D.Double(2.1, 4.5))
    .add(Point2D.Double(2.4, 5.0))
    .build()
----

If one of the `add()` calls is removed, the code will no longer compile, as the type of the `PolygonBuilder` does no longer comply with the signature of the `build()` extension function.

Of course, you can use this pattern to count more than one thing, and you can combine it with the Typesafe Builder Pattern as well.

=== Builders with multiple stages

It is possible to build objects in different stages. However, as there are several ways to implement this use case, and as these techniques are not only applicable for builders, xref:chapter-08.adoc[Chapter 8] covers this topic in detail.

=== Conclusion

The Builder Pattern is quite popular in Java - there are  libraries like https://projectlombok.org/[Project Lombok] which generate builders for you. The downside is that builders are quite inflexible and might be not very safe to use (although variations like the Typesafe Builder Pattern can help). In Kotlin, using named and default parameters can already provide a functionality similar to a builder. The next chapter will present another common approach in Kotlin, which has some advantages over the Builder Pattern.

==== Preferable Use Cases

* Creating data
* Generating code
* Configuring systems
* Testing
* Logging

==== Rating

* image:4_sun.png[] - for Simplicity of DSL design
* image:2_sun.png[] - for Elegance
* image:3_sun.png[] - for Usability
* image:4_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* easy to understand
* applicable for a wide range of construction tasks
* variations of the pattern can fix some of its shortcomings
* can be autogenerated (e.g. using https://projectlombok.org[Project Lombok])
* easy to use from Java client code

|* often not the most natural syntax for the problem
* nested builders don't look nice
* inflexible structure
* boilerplate code (e.g. need for a `build()` method)
* assignments are disguised as method calls
|===
