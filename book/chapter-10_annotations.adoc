== Annotation-based DSLs

> I have discovered a truly marvelous proof of this, which however the margin is not large enough to contain.
-- Pierre de Fermat

Annotations can be used to bind specified actions or behaviors to classes, methods, fields, etc. Typical examples include dependency injection frameworks (such as Spring or Dagger), serializers to formats such as XML or JSON (such as Gson, Jackson, or JAXB), or authorization and access-control (such as Spring Security). In Java, https://projectlombok.org/[Project Lombok]footnote:[https://projectlombok.org](((Project Lombok))) aims to reduce the boilerplate of the language in many ways, and uses annotations to do so.

As mentioned in <<chapter-04_features.adoc#annotations,4.13 Annotations>>, you may want to look into annotation processors if you need to integrate your DSL into the build process in some way.

=== Case Study: Mapper DSL

Mapping between similar classes is a common and often tedious task. There are already many solutions, such as the https://mapstruct.org/[MapStruct]!footnote:mapstruct[MapStruct: https://mapstruct.org](((MapStruct))) library, which is a code generator for mapper classes.

In this case study, we will write a very simple mapper DSL to transform e.g. data classes at runtime. The actual transformation code is not for the faint of heart, it relies on reflection and is very insecure to keep it short. Explaining the details is beyond the scope of this book; the focus of the case study is on how to use annotations to express your intentions.

Let's start with an example. Suppose we have a `User' class and a `Person' class, and we want to convert users to persons:

[source,kotlin]
----
data class User(
    val id: UUID,
    val firstName: String,
    val familyName: String,
    val birthDay: ZonedDateTime)

data class Person(
    val firstName: String,
    val lastName: String,
    val age: Int)
----

We must consider the following cases:

1. If the source and target parameters have the same name and type, like `firstName`, the mapper should just pass the values.
2. If the source and target parameters have the same type but different names, like `familyName` and `lastName`, we need to specify a mapping between source and target.
3. If the source and target parameters have different types, like `birthday` and `age`, we need to specify some kind of transformer in addition to the source and target.

This is what our DSL might look like:

[source,kotlin]
----
@Mapping("familyName", "lastName")
@Mapping("birthDay", "age", AgeTransformer::class)
object UserToPerson : Mapper<User, Person>()

val person = UserToPerson.map(getSomeUser())
----

The definition of the `@Mapping` annotations is straightforward. They must be present at runtime, they should only be valid on classes, and it must be possible to use multiple of them (which requires the `@Repeatable` annotation). Since the annotation fields cannot be null, we need to use a dummy default class for the `transformer` field:

[source,kotlin]
----
@Repeatable
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class Mapping(
    val source: String,
    val target: String,
    val transformer: KClass<*> = Nothing::class
)
----

The `AgeTransformer` must be a subclass of a function from `ZonedDateTime` to `Int`. If the annotation specifies a class that isn't a function (like the default, which is `Nothing`), we will simply ignore it. Since the transformer is immutable and reusable, we can implement it as an `object`:

[source,kotlin]
----
object AgeTransformer : (ZonedDateTime) -> Int {
    override fun invoke(z: ZonedDateTime) =
        ChronoUnit.YEARS.between(z, ZonedDateTime.now()).toInt()
}
----

Alternatively, we could implement a helper class `Transformer`, which allows a slightly more concise definition of such transformer objects:

[source,kotlin]
----
open class Transformer<in A, out B>(val lambda: (A) -> B) : (A) -> B {
    override fun invoke(a: A): B = lambda(a)
}

object AgeTransformer : Transformer<ZonedDateTime, Int>({ z ->
    ChronoUnit.YEARS.between(z, ZonedDateTime.now()).toInt()
})
----

Now the only thing missing is the `Mapper` class, which has to figure out which fields to map and which transformers to use. As mentioned, this is neither pretty nor secure, but here goes:

[source,kotlin]
----
abstract class Mapper<S : Any, T : Any> {
    fun map(s: S): T {
        val annotations = this::class.findAnnotations(Mapping::class)

        val targetType = this::class.supertypes[0]
            .arguments[1]
            .type!!
            .classifier as KClass<*>

        val targetConstructor = targetType.primaryConstructor!!

        val targetArgs = targetConstructor.parameters.map { targetParam ->

            val ann = annotations.find { it.target == targetParam.name }

            val sourceParam = ann?.source ?: targetParam.name

            val sourceValue = s::class.memberProperties.find {
                it.name == sourceParam
            }!!.getter.call(s)

            ann?.transformer?.isSubclassOf(Function1::class)
                .takeIf { it == true }
                ?.let {
                    val transformer = ann!!.transformer.objectInstance
                        ?: ann.transformer.primaryConstructor!!.call()
                    transformer::class.memberFunctions
                        .find { it.name == "invoke" }!!
                        .call(transformer, sourceValue)
                } ?: sourceValue
        }.toTypedArray()

        @Suppress("UNCHECKED_CAST")
        return targetConstructor.call(*targetArgs) as T
    }
}
----

Since it uses reflection, you need to include a dependency on the `kotlin-reflect` library, as described in <<chapter-04_features.adoc#reflection,4.14 Reflection>>. Of course, the example could be improved in many ways, e.g. sometimes you need multiple source fields to calculate a target field.

.Convention over Code (((Convention over Code)))
****
One design choice in our example deserves attention: If the names and types of the source and target classes match, no `@Mapping` annotation is required. This implicit mapping behavior may seem obvious and trivial, but it highlights the principle of _Convention over Code_, which suggests that common use cases should work seamlessly without requiring explicit instructions or extra configuration. It applies to language design in general, but seems to apply more often to annotation-based DSLs than to other DSL categories. Adherence to this principle can improve the user experience and greatly enhance usability.
****

For serious applications, I would suggest checking out https://mapstruct.org[MapStruct]footnote:mapstruct[]. It is a Java library, but seems to work well with Kotlin, and has much more functionality than our example DSL. A major difference is that MapStruct generates source code, which avoids the performance hit of using reflection, and makes debugging much more convenient.

=== Synergy with String-based DSLs

Syntactically, annotation-based DSLs are quite limited: The structure of an annotation is fixed, and only a few data types are allowed as fields. Fortunately, one of these data types is `String`, and the last chapter showed how expressive string-based DSLs can be. It is therefore natural to overcome the limitations of the annotation-based approach by embedding string-based DSLs in annotations.

Implementing such a DSL wouldn't provide much new insight, but the Spring Data JPA can serve as an example:

[source,kotlin]
----
@Repository
interface UserRepository : JpaRepository<UserEntity, Long> {
    @Query("SELECT u FROM UserEntity u WHERE u.lastLame = :lastName")
    fun findAllByLastName(@Param("lastName") familyName: String):
       List<UserEntity>
}
----

The `@Query` annotation has no fields for the `FROM` and `WHERE` clauses, it allows the entire query to be specified as a string (which is itself a DSL). In my opinion, this is clearly the better approach for this use case.

=== Conclusion

In some cases, it feels very natural to integrate a DSL into the existing user code and use it to influence how certain structures are processed or translated. In these cases, annotation-based DSLs are a good choice. While these DSLs are often easy to use, the implementation overhead can be significant. Another problem can be overuse of annotations to the point of unreadability, and the use of annotations from different frameworks on the same class, method, or property, which can be very confusing.

*Common applications*

* Data creation and initialization
* Data transformation
* Data validation
* Execute actions
* Code generation
* Configuring systems
* Testing
* Logging
* Monitoring
* Reporting and analytics

*Pros*

* Can feel very natural and intuitive to use
* Uses a common, dedicated syntax
* Can support "convention over code" by marking only the special cases

*Cons*

* May pollute host code
* Can't be used for external code
* May conflict with other annotation-based DSLs
* Often relies heavily on reflection
* Hard to debug

