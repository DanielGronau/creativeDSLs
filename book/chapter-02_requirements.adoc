== Requirements Analysis (((Requirement Analysis)))

As a software engineer, it's easy to get caught up in the excitement of building a DSL and lose sight of the bigger picture. However, it's important to take a step back and carefully consider the goals and requirements of your DSL before diving into implementation. This will help ensure that your DSL is complete, well-behaved, maintainable, and extendable.

It is important to establish a clear understanding of the scope and purpose of your DSL among all stakeholders. This includes determining the target audience, and how the DSL will be used. Having everyone on the same page minimizes the risk that important details have been overlooked. However, this shouldn't be a long-winded and boring process. To simplify this task, this chapter is basically a check-list of decisions to make before you start implementing.

=== Defining the Problem Domain (((Problem Domain)))

The first question to answer is obviously which domain to tackle. For small domains and areas with existing standards, this question is usually easy to answer. For larger domains it can be tempting to over-generalize. Try to be specific. Sometimes, the deliberate decision to drop some lesser used and harder to implement parts of the problem domain can make the DSL more flexible and lean. As in other areas of software development, it can be helpful to specify non-goals explicitly. Also, don't forget to specify the target platform, the language level etc.

Generally, it is a good practice to organize your DSL in layers, so that the lower layers don't rely on the higher ones, and can therefore be used independently. E.g. if you design a DSL for linear algebra, the DSL part for working with matrices could be independent of the rest of the system, which allows to use this part in other contexts as well.

When the application already employs other DSLs, it should be considered whether a parallel use of the new DSL would be confusing or if it could yield unexpected results. In some cases it might be smart to imitate the syntax of an existing DSL in order to facilitate the experience the users already have. A real-world example for this approach is the KotlinPoet library mimicking its JavaPoet sister project.

=== Research

After specifying the problem domain, you should check out existing DSLs. You might be surprised by the plethora of existing solutions, and of course it makes little sense to reinvent the wheel. Even if the results don't fit your use case perfectly, they might serve as a base implementation, or as a source of inspiration.

TIP: There is an ongoing debate of how much software should depend on libraries, and you should be aware of related problems like the dreaded "dependency hell". On the other hand, you shouldn't fall into the "Not Invented Here" (((Not Invented Here))) trap, where an organization tries to build everything from scratch. As in most cases, it is important to find a good balance. A decision whether to use a library should be always deliberate, and the decision process should be documented.

If there is no existing DSL for your problem, you might also investigate whether using a DSL generator could be an option for you. Using such libraries can make designing a DSL a breeze. This book covers https://github.com/F43nd1r/autodsl[AutoDSL for Kotlin] to give you an impression of this approach.

=== Specifying the Output of the DSL

In most cases it is rather obvious which kind of output is expected. Sometimes you have a choice of executing some action (like a query) directly, or to create objects being able to perform that action instead. Most of the time, creating objects should be preferred. Usually this approach is easier to test and to debug, and sometimes it is convenient to be able to create these instances by other means.

Another potential question is whether to generate the target entities of an external API directly, or to follow the Adapter Pattern or similar approaches. In this case the decision depends on the intended architecture of your application (like Hexagonal Architecture, Onion Architecture etc.), but generally you should try to use non-essential external APIs only at the boundaries of the application, and DSLs should follow this guideline as well.

=== Syntactical Gap (((Syntactical Gap)))

Usually, an internal DSL can only be an approximation of the syntax you really wish for, there is a "syntactical gap". It is tempting to subordinate everything else in order to come as close as possible to the intended ideal syntax. But of course beauty has its price, pushing the limits of the host language's syntax can be problematic, and neglecting the other requirements can render a beautiful DSL useless.

That's why it is important to have a rough idea how close the internal DSL needs to come to the ideal syntax, and when to start compromising. One relevant question in this context is how "tech-savvy" users of the DSL are. Generally, people without coding experience need more streamlined DSLs than software engineers, who will often tolerate a few "warts" in the DSL syntax.

=== Learning Experience (((Learning Experience)))

Having a beautiful and concise Syntax for a DSL doesn't necessarily mean that it is easy to master. Once a DSL reaches a certain size and complexity, it is naive to assume that people can use it without any assistance. The learning experience of the users is often just an afterthought, but I think it is important to account for it already in the analysis process.

The DSL itself can be designed in a way to have a shallow learning curve, e.g. by mimicking known systems, or by emphasizing consistency over conciseness. An example for a "too concise" DSL might be regular expressions, as many users - including me - have to look up the syntax over and over again.

Of course, training and documentation are essential factors for a good learning experience. However, an often overlooked topic is the quality of error and warning messages, which can have a significant impact on how easily users can learn and understand a new DSL. In order to get those factors right, you have to know your target audience and their skill-set.

TIP: In the end it's not the DSL itself which generates value, but the people using it effectively, and this is something we should never forget. Planning for the required assistance upfront can help to improve the DSL, and empower the users to get the most out of it.

=== Safety of Use (((Safety of Use)))

An often overlooked requirement is how and how well the user has to be protected against pitfalls and misuses of the DSL. This includes questions like whether misuses should cause compile time or only runtime errors, or whether it is acceptable that the DSL can express some states that shouldn't be allowed.

Reasons for unsafe behavior can be e.g. an overly flexible syntax, missing sanity checks or mistakes stemming from operator precedences. In some cases the safety-of-use requirement is conflicting with the pursuit of the ideal syntax, and then you need to find a compromise between a beauty and safety.

Some level of unsafe behaviour might be acceptable for tech-savvy or experienced users, or in areas with lower safety requirements, like test data generation.

=== Ensuring Extensibility (((Extensibility)))

Insufficient extensibility is a common pitfall when designing internal DSLs, which usually operate with quite specialized techniques and language features. Sometimes new DSL requirements can't be properly implemented with the chosen feature set, which may render the whole DSL useless.

Therefore, it makes sense to get upfront a rough idea which extensions could be requested after the first version of the DSL. Later, in the implementation phase, this information helps to avoid using techniques that are not flexible enough to handle future requirements.

Another type of extensibility that is often overlooked is customization by users. For instance, consider a DSL for working with physical quantities: there are too many units to cover all of them, but users might have a particular set of units that they require in their daily work. Therefore, it would be beneficial if the DSL allows users to add custom units. Such considerations can significantly increase the usefulness and success of a DSL. If possible, it is recommended to open your DSL for extension by users, and also provide documentation on how to do it. However, it may be advisable to restrict extensibility when you can predict that extending the DSL may lead to unexpected or unsafe outcomes.

=== Maintainability (((Maintainability)))

The DSL has to be not only implemented, but must be maintained as well. It should be estimated how many resources are necessary to keep the code running and to update it. Knowing these expectations can help to decide e.g. which dependencies are acceptable, or if code generation (((Code Generation))) is required.

=== Performance (((Performance))) and Memory (((Memory))) Requirements

Often performance considerations don't get much attention. However, in most cases DSLs invoke additional operations, instantiate extra classes and may trigger garbage collections. When working with big data, or having a wasteful DSL design, you might run in performance and memory problems. That's why it is necessary to estimate performance requirements upfront, and to employ load tests and metrics accordingly.

=== Java Interoperability (((Java Interoperability)))

This is a Kotlin-specific question: There are plenty of environments using a mix of Java and Kotlin, so it might be required to use a DSL written in Kotlin from Java code. Usually, this direction is more challenging than using Java from Kotlin code, and depending on the language features, a Kotlin DSL might be practically unusable from Java. However, in many cases some "glue code" can help to bridge the gap, and the Kotlin language itself contains some features to increase the interoperability with Java.

If Java interoperability is required, it should be already considered in the design phase. The respective challenges and possible solution are discussed in <<chapter-13_java.adoc#javaInteroperability, chapter 13>> in more detail.

=== Closed or Open Source (((Closed Source))) (((Open Source)))

One important consideration that should be decided up-front is whether to make the DSL project open source. Doing so can have several benefits, including community contributions, increased exposure, and potential collaborations. However, it also means giving up control over the direction of the project, as well as potentially exposing any flaws or security vulnerabilities to the public. Additionally, open source projects require ongoing maintenance and support from the original developers, which can be time-consuming and resource-intensive. Ultimately, the decision to make a DSL project open source should be weighed carefully against the potential benefits and drawbacks.

=== Ready, Steady, Go?

After identifying the requirements for your DSL project, it is important to carefully consider its scope, complexity, and benefits before moving forward. While DSLs can be highly beneficial to build, it is important to ensure that they have a clear purpose and add tangible value for their users, and that the scope of the project is manageable for your organization.

If you find that the project does not meet these criteria, it may be best to cancel it. However, if you believe that the project is both feasible and useful, you can proceed with implementation. Keep the overall goals and purpose of the DSL in mind as you work, and be prepared to adapt and refine your approach as needed.

Remember that building a DSL is just a means to an end, and not an end in itself. It should ultimately serve the needs of its users and add value to your organization. As such, careful consideration of the project's feasibility, purpose, and value is critical before beginning implementation.