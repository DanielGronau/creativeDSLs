== Algebraic DSLs

A common class of problems deals with objects that exhibit numeric-like behavior. These "algebraic" structures include complex numbers, quaternions, vectors, matrices, physical and monetary quantities, and many more. With Kotlin, it is relatively easy to write DSLs for these problems, especially when the required operators match with the existing ones.

NOTE: As for many other categories of DSLs, there seems to be no established name for this kind of DSL in the literature. I think calling them "Algebraic DSLs" covers their behavior quite well, but you might find the same concept under different names elsewhere.

The Kotlin API itself contains some nice examples for small Algebraic DSLs, e.g. for `BigInteger` and `BigDecimal`, which can be used pretty much like "normal" numbers.

Even if your problem domain hasn't exactly an algebraic structure, some ideas in this chapter might be at least partially applicable. Take chemical formulas as an example: Although though they are not number-like, they contain concepts like (scalar) multiplication and addition, and can be modelled accordingly.

=== Case Study: A DSL for Complex Numbers

In order to keep things realistic, we will use an existing implementation, that you could find in a production environment. We will use the https://github.com/apache/commons-numbers/tree/master/commons-numbers-complex[Apache Commons Numbers: Complex] library, which is written in Java. The implementation behaves pretty much as expected:

[source,kotlin]
----
val a = Complex.ofCartesian(3.0, 4.0)
val b = Complex.ofCartesian(5.0, 6.0)
val c = a.add(b) // 8 + 10i
val d = a.times(b) // -9 + 38i
val e = a.pow(b) // -1.860 + 11.837i
----

There are some static factory methods to create `Complex` objects, like `Complex.ofCartesian()` or `Complex.ofPolar()`, and then you can use some methods like `add()` and `times()` on these objects.

If we follow the steps from chapter 3, we should now come up with an ideal syntax. This is easy, as in mathematics we would simply write `3.0 + 4.0i` instead of `Complex.ofCartesian(3.0, 4.0)`. I think it is acceptable to have no special syntax for other ways to initialize complex numbers, like the polar definition.

When we consider that `4.0i` is actually a multiplication, we are already there: A syntax like `3.0 + 4.0*i` can be implemented in Kotlin.

First, we need to define the imaginary unit `i` with `val i = Complex.I`. This is a bit risky because of possible name clashes, so it would be also an option to import `Complex.I` instead.

Next, the arithmetic operations can be written using operator overloading. We need not only operations between two `Complex` instances, but also between `Complex` and `Double`. Here is an example for addition:

[source,kotlin]
----
operator fun Complex.plus(that: Complex): Complex = this.add(that)
operator fun Complex.plus(that: Double): Complex = this.add(that)
operator fun Double.plus(that: Complex): Complex =
    Complex.ofCartesian(this, 0.0).add(that)
----

The other operations look basically the same. We could also support interoperability with `Int` in addition to `Double`, but it was omitted for the sake of brevity. A little improvement would be a helper method for the conversion from double to complex, instead of relying on the awkward `Complex.ofCartesian` factory.

Next, we need also to support negation of complex numbers (and probably the unary plus, too, for symmetry reasons). This looks very similar to the code above:

[source,kotlin]
----
operator fun Complex.unaryMinus(): Complex = this.negate()
----

When you can't find an appropriate operator to overload, you can use infix functions instead. In our example, we could define `pow` as exponentiation operation, so we can write e.g. `3.0 + 4.0*i pow 3.0`:

[source,kotlin]
----
infix fun Complex.pow(that: Complex): Complex = pow(that)
infix fun Complex.pow(that: Double): Complex = pow(that)
----

Alternatively, we could have used `{backtick}^{backtick}` in <<chapter-04.adoc#backtickIdentifiers, backtick notation>>(((Backtick Notation))), which may be more readable than `pow`, but is harder to type.

And that's already it, we have a basic DSL for complex numbers. Here is the complete code:

[source,kotlin]
----
import org.apache.commons.numbers.complex.Complex

val i = Complex.I

operator fun Complex.unaryPlus() = this

operator fun Complex.unaryMinus() = this.negate()

operator fun Complex.plus(that: Complex) = add(that)
operator fun Complex.plus(that: Double) = add(that)
operator fun Double.plus(that: Complex) = fromDouble(this).add(that)

operator fun Complex.minus(that: Complex) = subtract(that)
operator fun Complex.minus(that: Double) = subtract(that)
operator fun Double.minus(that: Complex) = fromDouble(this).subtract(that)

operator fun Complex.times(that: Complex) = multiply(that)
operator fun Complex.times(that: Double) = multiply(that)
operator fun Double.times(that: Complex) = fromDouble(this).multiply(that)

operator fun Complex.div(that: Complex) = divide(that)
operator fun Complex.div(that: Double) = divide(that)
operator fun Double.div(that: Complex) = fromDouble(this).divide(that)

infix fun Complex.pow(that: Complex) = pow(that)
infix fun Complex.pow(that: Double) = pow(that)

private fun fromDouble(d: Double) = Complex.ofCartesian(d, 0.0)
----

Now our usage example can be written as:
[source,kotlin]
----
val a = 3.0 + 4.0*i
val b = 5.0 + 6.0*i
val c = a + b
val d = a * b
val e = a pow b
----

Using complex numbers feels now as intuitive as using one of the built-in numeric types.

=== Conclusion

I hope the case study demonstrates that writing algebraic DLSs is usually not that difficult. There are still a few points to consider when deciding whether to use an algebraic DSL. For some use-cases it might be a stretch to use algebraic notation: Take e.g. sum and product types (a.k.a. `Either` and tuples), where using `+` and `*` would be surprising for some users, even though the underlying structure is algebraic. Even if the notation is appropriate for the use-case, there might be surprising behaviours like non-commutative multiplication (e.g. in case of quaternions and matrices) that could lead to usage errors.

==== Preferable Use Cases

* Define operations

==== Rating

* image:5_sun.png[] - for Simplicity of DSL design
* image:5_sun.png[] - for Elegance
* image:5_sun.png[] - for Usability
* image:2_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* easy to write
* intuitive to use
* can use infix functions when no operator fits

|* possible name clashes with other DSLs
* operator precedence can't be changed
* hard to use from Java client code
|===
