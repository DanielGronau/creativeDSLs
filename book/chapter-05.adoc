== Algebraic DSLs

A common class of problems deals with objects forming algebraic structures, in other words, objects that behave somewhat similar to numbers. This includes complex numbers, quaternions, vectors, matrices, physical and monetary quantities, and much more. Often, such DSLs can be easily designed in Kotlin, especially when the existing operators can be used.

NOTE: As for many other categories of DSLs, there seems to be no established name for this DSL category in the literature. I think calling them "Algebraic DSLs" covers their behavior quite well, but you might find the same concept under different names elsewhere.

The Kotlin API itself contains some nice examples for Algebraic DSLs, e.g. for `BigInteger` and `BigDecimal`, which can be used pretty much like "normal" numbers - something Java programmers can only dream of.

Even if your problem domain has not exactly an algebraic structure, you should know about these techniques. Take chemical equations as an example: Even though they are clearly not number-like, they contain concepts like (scalar) multiplication and addition.

=== Case Study: A DSL for Complex Numbers

In order to keep things realistic, we won't use our own implementation for complex numbers, but an existing one that you could very well find in a production environment. We will use the https://github.com/apache/commons-numbers/tree/master/commons-numbers-complex[Apache Commons Numbers: Complex] implementation, which is written in Java.

The implementation behaves pretty much as expected:

[source,kotlin]
----
val a = Complex.ofCartesian(3.0, 4.0)
val b = Complex.ofCartesian(5.0, 6.0)
val c = a.add(b) // 8 + 10i
val d = a.times(b) // -9 + 38i
val e = a.pow(b) // -1.860 + 11.837i
----

There are some static factory methods to create `Complex` objects, like `Complex.ofCartesian()` or `Complex.ofPolar()`, and then you can use some methods like `add()` and `times()` on these objects.

If we follow the steps from chapter 3, we should now come up with an ideal syntax. This is easy, as in maths we would simply write `3.0 + 4.0i` instead of `Complex.ofCartesian(3.0, 4.0)`. I think it is acceptable to have no special syntax for other ways to initialize complex numbers, like the polar definition.

When we consider that `4.0i` is actually a multiplication, we are already there: A syntax like `3.0 + 4.0*i` can be implemented in Kotlin.

First, we need to define the imaginary unit `i` with `val i = Complex.I`. This is a bit risky because of possible name clashes, so it would be also an option to import `Complex.I` instead.

Next, the arithmetic operations can be implemented using operator overloading. We need not only operations between two `Complex` instances, but also between `Complex` and `Double`. Here is an example for addition:

[source,kotlin]
----
operator fun Complex.plus(other: Complex): Complex = add(other)
operator fun Complex.plus(other: Double): Complex = add(other)
operator fun Double.plus(other: Complex): Complex =
    Complex.ofCartesian(this, 0.0).add(this)
----

The other operations look basically the same. We could also support interoperability with `Int` in addition to `Double` if we want, but it was omitted for the sake of brevity. A little improvement would be a helper method for the conversion from double to complex, instead of relying on the awkward `Complex.ofCartesian` factory.

Next, we need also to support negation of complex numbers (and probably the unary plus, too, for symmetry reasons). This looks very similar to the code above:

[source,kotlin]
----
operator fun Complex.unaryMinus(): Complex = this.negate()
----

When you can't find an appropriate operator to overload, you can use infix functions instead. In our example, we could define `pow` as exponentiation operation, so we can write e.g. `3.0 + 4.0*i pow 3.0`:

[source,kotlin]
----
infix fun Complex.pow(that: Complex): Complex = pow(that)
infix fun Complex.pow(that: Double): Complex = pow(that)
----

And that's already it, we have a basic DSL for complex numbers. Here is the complete code:

[source,kotlin]
----
import org.apache.commons.numbers.complex.Complex

val i = Complex.I

operator fun Complex.unaryPlus() = this

operator fun Complex.unaryMinus() = this.negate()

operator fun Complex.plus(that: Complex) = add(that)
operator fun Complex.plus(that: Double) = add(that)
operator fun Double.plus(that: Complex) = fromDouble(this).add(that)

operator fun Complex.minus(that: Complex) = subtract(that)
operator fun Complex.minus(that: Double) = subtract(that)
operator fun Double.minus(that: Complex) = fromDouble(this).subtract(that)

operator fun Complex.times(that: Complex) = multiply(that)
operator fun Complex.times(that: Double) = multiply(that)
operator fun Double.times(that: Complex) = fromDouble(this).multiply(that)

operator fun Complex.div(that: Complex) = divide(that)
operator fun Complex.div(that: Double) = divide(that)
operator fun Double.div(that: Complex) = fromDouble(this).divide(that)

infix fun Complex.pow(that: Complex) = pow(that)
infix fun Complex.pow(that: Double) = pow(that)

private fun fromDouble(d: Double) = Complex.ofCartesian(d, 0.0)
----

Now our very first example can be written as
[source,kotlin]
----
val a = 3.0 + 4.0*i
val b = 5.0 + 6.0*i
val c = a + b
val d = a * b
val e = a pow b
----

Of course, we could add more functionality. E.g. this function would allow to compare complex numbers by their absolute values:

[source,kotlin]
----
operator fun Complex.compareTo(that: Complex): Int =
    abs().compareTo(that.abs())

val cmp = 3.0 + 4.0*i < 5.0 - 1.0*i // true
----

This wasn't included in the DSL because it is somewhat dangerous, as it isn't consistent with the behavior of `Double` values: Of course `-5.0 < 4.0`, but with the code above, we would have `-5.0 + 0.0*i > 4.0 + 0.0*i`.

=== Conclusion

I hope the case study shows that writing algebraic DLSs is generally quite straightforward. There are still a few points to consider when deciding whether to use an algebraic DSL.

==== Preferable Use Cases

* Define operations

==== Rating

* image:5_sun.png[] - for Simplicity of DSL design
* image:5_sun.png[] - for Elegance
* image:5_sun.png[] - for Usability
* image:2_sun.png[] - for possible Applications

==== Pros & Cons

[cols="2a,2a"]
|===
|Pros |Cons

|* easy to write
* intuitive to use
* can use infix functions when no operator fits

|* possible name clashes with other DSLs
* operator precedence can't be changed
* hard to use from Java client code
|===
