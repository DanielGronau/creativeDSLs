[#java_interoperability]
== Java Interoperability (((Java Interoperability)))

> Translation is the art of failure.
-- Umberto Eco

Using a Kotlin DSL from Java can be challenging. While some Kotlin features, such as operator overloading, simply aren't available, there are ways to make other features more accessible from Java, and to create a DSL that is useful and convenient in both languages. Fortunately, Kotlin has a number of built-in features to improve its interoperability with Java, which are described in https://kotlinlang.org/docs/java-to-kotlin-interop.html[Kotlin Documentation: Calling Kotlin from Java]footnote:[Kotlin Documentation, Calling Kotlin from Java: https://kotlinlang.org/docs/java-to-kotlin-interop.html].

This chapter discusses Java interoperability from a purely DSL design perspective, presenting the relevant built-in features and useful techniques for solving DSL-specific problems. Note that retrofitting an existing DSL for Java interoperability is more expensive than designing for it from the beginning.

=== Renaming Identifiers (((@JvmName))) (((@JvmStatic)))

When writing DSLs, it is common to use unusual names that may not be allowed in Java, either because they use forbidden characters or because they match a Java keyword. In this case, the `@JvmName` annotation can help. Of course, sometimes additional annotations may be needed, such as `@JvmStatic` to expose object members as static class members in Java:

[source,kotlin]
----
object NamingTest {
    @JvmStatic
    @JvmName("checkThisOut")
    fun `check this out`() = println("backtick notation")

    @JvmStatic
    @JvmName("instanceOf")
    fun instanceof() = println("instanceof")
}
----

Calling these members is now trivial:

[source,java]
.Java code
----
public class CallStrangeNames {

    public static void main(String[] args) {
        NamingTest.checkThisOut();
        NamingTest.instanceOf();
    }
}
----

==== Value Classes (((Value Classes))) and Mangling (((Mangling)))

In Kotlin, value classes are represented by their underlying type in JVM bytecode. However, this approach can lead to naming conflicts, such as when there are multiple methods with the same name and value class parameters with the same underlying type. To avoid this problem, Kotlin uses a technique called "name mangling".

During compilation, the compiler renames the affected methods using a hashing algorithm that takes into account the package name, class name, and method name. This creates a unique name for each method, which prevents naming conflicts in the bytecode.

Kotlin users don't need to be aware of this behavior, as calls to the mangled methods are automatically translated correctly. However, if Java users want to call a mangled method, they would have to use the strange mangled name. To avoid this problem, you can explicitly name the method on the JVM using the `@JvmName` annotation:

[source,kotlin]
----
@JvmInline
value class Kilometers(val value: Double)

@JvmInline
value class Miles(val value: Double)

@JvmName("displayKm")
fun display(x: Kilometers) { println("${x.value} km") }

@JvmName("displayMiles")
fun display(x: Miles) { println("${x.value} miles") }
----

From Java, you can call the example methods by their JVM names and with `double` arguments, e.g. `displayKm(23.0);` and `displayMiles(42.3);`.

=== Package Level Definitions of Functions and Variables (((@file:JvmName)))

Java does not allow you to define functions and variables outside of classes, so Kotlin puts them as static functions and variables in an artificial class. The default name of this class is derived from the filename, including the `kt` ending, and follows the upper-camel-case naming convention for classes. Consider the following example:

[source,kotlin]
.utils.kt
----
package com.acme

fun someFunction() {
    ...
}
----

The function could be called from Java as `com.acme.UtilsKt.someFunction()`. Often, you would prefer to use another class name for your DSL, e.g. `Utils` instead of `UtilsKt`. This can be easily achieved by including a `JvmName` annotation:

[source,kotlin]
.utils.kt
----
@file:JvmName("Utils")
package com.acme

fun someFunction() {
    ...
}
----

It is even possible to map the contents of multiple Kotlin files to the same Java class, but then an additional `@file:JvmMultifileClass` annotation is needed in every file.

=== Generate Overloaded Methods (((@JvmOverloads)))

Java doesn't have default arguments, they are "simulated" by having several overloaded methods. The Kotlin compiler can generate such overloaded methods when requested via the `@JvmOverloads` annotation. Consider the following Kotlin function:

[source,kotlin]
----
@JvmOverloads
fun withOverloading(
    s: String = "one",
    i: Int = 42,
    d: Double,
    b: Boolean = false
) {
    println("$s $i $d $b")
}
----

In a Java class, you can see now four methods of this name. If you call the different implementations, you get the following results:

[source,java]
.Java Code
----
withOverloading("two", 12, 17.0, true);  // "two 12 17 true"
withOverloading("two", 12, 17.0);        // "two 12 17 false"
withOverloading("two", 17.0);            // "two 42 17 false"
withOverloading(17.0);                   // "one 42 17 false"
----

As you can see, you can either call the method with all arguments, or you can leave the right-most arguments with default values off. Of course, you have always to specify the argument `d`, which has no default.

You can also annotate constructors with `@JvmOverloads`.

=== Accessing Fields (((@JvmField)))

In Kotlin, fields are exposed as properties, and even if it looks like you are accessing a field with a call like `somePerson.name`, behind the scenes you are accessing a getter or setter of this property. Of course, you can use these getters and setters from Java as well, e.g. by using `somePerson.getName()`, but if you want to allow direct field access, you need to use the `@JvmField` annotation, e.g. like this:

[source,kotlin]
----
data class Person(@JvmField val name: String, @JvmField val age: Int)
----

Now you can call the fields directly, as in Kotlin.

=== Generics (((@JvmSuppressWildcards))) (((@JvmWildcards)))

A common problem is that due to its declaration-side variance, Kotlin often generates generic signatures with wildcards like `List<? extends String>` on the JVM. Such types can be awkward to use from the Java side, can prevent the use of certain Java libraries (such as https://dagger.dev[Dagger]footnote:[Dagger: https://dagger.dev]), or even lead to cryptic compile-time errors. The solution is to annotate the offending type with `@JvmSuppressWildcards`, so that you get the type signature like `List<String>` on the JVM.

In some cases, you may have the opposite problem, where it would be more convenient to have wildcards on the JVM when the Kotlin compiler doesn't produce them. In this case, you can use the `@JvmWildcards` annotation instead.

[#reified_generics_bridge]
==== Calling Functions with Reified Type Parameters

I am afraid I have some bad news for you: Java has no inlining mechanism, and without inlining, the resolution of reified type parameters simply doesn't work. As a consequence, you can't call such functions from Java, not even via reflection.

A workaround is to write a version of the function with an explicit class parameter:

[source,kotlin]
----
inline fun <reified T> tellType(list: List<T>) {
    println(T::class.qualifiedName)
}

// for Java calls
fun <T: Any> tellTypeJava(list: List<T>, clazz: Class<T>) {
    println(clazz.kotlin.qualifiedName)
}
----

You can call the second function as usual from Java, e.g. `tellTypeJava(List.of(1,2,3), Integer.class);`.

This approach will work for many use cases, but it should be noted that a reified type contains information about its own type parameters, while a class parameter just denotes a raw type. If this type information is needed, our simplistic approach won't work. It is difficult to give a general solution for the more complicated cases, but replacing the class parameter with e.g. `TypeToken` (from either https://github.com/google/guava[Guava]footnote:[Guava: https://github.com/google/guava](((Guava))) or https://github.com/google/gson[Gson]footnote:[Gson: https://github.com/google/gson](((Gson))) ) might help.

=== Checked Exceptions

Kotlin doesn't have the concept of "checked exceptions", but if a function that might throw such an exception is called from Java, the Java compiler expects that the exception is declared in the function signature. In order to avoid problems in such cases, you can give the Kotlin compiler a hint to add a checked exception to the function signature in the byte-code by annotating the function with `Throws(SomeCheckedException::class)`.

=== Prevent Java Access

Using some parts of your DSL from Java can be cumbersome, unintuitive, or even lead to unsafe behavior. If you find yourself in a situation where certain parts of your DSL should only be accessible from Kotlin, you can use the `@JvmSynthetic` annotation on files, functions, fields, and property getters and setters.

For example, handling coroutine calls from Java is possible, but requires knowledge of the underlying architectural concepts, such as continuations. It's usually a better solution to provide dedicated functions for Java access, e.g. by wrapping the coroutine in a `CompletableFuture`, which is much easier to handle in Java:

[source,kotlin]
----
// hidden from Java
@JvmSynthetic
suspend fun getStuff(): String {
    ...
}

private val scope = CoroutineScope(EmptyCoroutineContext)

// dedicated Java API
fun getStuffForJava(): CompletableFuture<String> =
    scope.future { getStuff() }
----



=== Conclusion

Writing DSLs often requires the use of advanced language features, so it's no surprise that calling this code from Java can be challenging, and that the Kotlin compiler may need some pointers for good Java interoperability. If calling your DSL from Java is a requirement, you should consider it in your design from the beginning. In particular, writing tests not only in Kotlin but also in Java can help avoid problems down the road. Most interoperability issues are easy to fix, often the hard part is figuring out what's going wrong and knowing what language features you have at your disposal in these situations.


