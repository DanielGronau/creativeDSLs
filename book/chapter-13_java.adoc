[#javaInteroperability]
== Java Interoperability (((Java Interoperability)))

> Translation is the art of failure.
-- Umberto Eco

Using a Kotlin DSL from Java can be challenging. While some Kotlin features, such as operator overloading, simply aren't available, there are ways to make other features more accessible from Java, and to create a DSL that is useful and convenient in both languages. Fortunately, Kotlin has a number of built-in features to improve its interoperability with Java, which are described in https://kotlinlang.org/docs/java-to-kotlin-interop.html[Kotlin Documentation: Calling Kotlin from Java].

This chapter discusses Java interoperability from a purely DSL design perspective, presenting the relevant built-in features and useful techniques for solving DSL-specific problems. Note that retrofitting an existing DSL for Java interoperability is more expensive than designing for it from the beginning.

=== Renaming Identifiers (((@JvmName)))

When writing DSLs, it is common to use unusual names that may not be allowed in Java, either because they use forbidden characters or because they match a Java keyword. In this case, the `@JvmName` annotation can help. Of course, sometimes additional annotations may be needed, such as `@JvmStatic` to expose object members as static class members in Java:

[source,kotlin]
----
object NamingTest {
    @JvmStatic
    @JvmName("checkThisOut")
    fun `check this out`() = println("backtick notation")

    @JvmStatic
    @JvmName("instanceOf")
    fun instanceof() = println("instanceof")
}
----

Calling these members is now trivial:

[source,java]
.Java code
----
public class CallStrangeNames {

    public static void main(String[] args) {
        NamingTest.checkThisOut();
        NamingTest.instanceOf();
    }
}
----

=== Package Level Definitions of Functions and Variables

Java does not allow you to define functions and variables outside of classes, so Kotlin puts them as static functions and variables in an artificial class. The default name of this class is derived from the filename, including the `kt' ending, and follows the upper-camel-case naming convention for classes. Consider the following example:

[source,kotlin]
.utils.kt
----
package com.acme

fun someFunction() {
    ...
}
----

The function could be called from Java as `com.acme.UtilsKt.someFunction()`. Often, you would prefer to use another class name for your DSL, e.g. `Utils` instead of `UtilsKt`. This can be easily achieved by including a `JvmName` annotation:

[source,kotlin]
.utils.kt
----
@file:JvmName("Utils")
package com.acme

fun someFunction() {
    ...
}
----

It is even possible to map the contents of multiple Kotlin files to the same Java class, but then an additional `@file:JvmMultifileClass` annotation is needed in every file.

=== Generate Overloaded Methods (((@JvmOverloads)))

Java doesn't have default arguments, they are "simulated" by having several overloaded methods. The Kotlin compiler can generate such overloaded methods when requested via the `@JvmOverloads` annotation. Consider the following Kotlin function:

[source,kotlin]
----
@JvmOverloads
fun withOverloading(
    s: String = "one",
    i: Int = 42,
    d: Double,
    b: Boolean = false
) {
    println("$s $i $d $b")
}
----

In a Java class, you can see now four methods of this name. If you call the different implementations, you get the following results:

[source,java]
.Java Code
----
withOverloading("two", 12, 17.0, true);  // "two 12 17 true"
withOverloading("two", 12, 17.0);        // "two 12 17 false"
withOverloading("two", 17.0);            // "two 42 17 false"
withOverloading(17.0);                   // "one 42 17 false"
----

As you can see, you can either call the method with all arguments, or you can leave the right-most arguments with default values off. Of course, you have always to specify the argument `d`, which has no default.

You can also annotate constructors with `@JvmOverloads`.

=== Value Classes (((Value Classes))) and Mangling (((Mangling)))

In Kotlin, value classes are represented by their underlying type in JVM bytecode. However, this approach can lead to naming conflicts, such as when there are multiple methods with the same name and value class parameters with the same underlying type. To avoid this problem, Kotlin uses a technique called "name mangling".

During compilation, the compiler renames the affected methods using a hashing algorithm that takes into account the package name, class name, and method name. This creates a unique name for each method, which prevents naming conflicts in the bytecode.

Kotlin users don't need to be aware of this behavior, as calls to the mangled methods are automatically translated correctly. However, if Java users want to call a mangled method, they would have to use the strange mangled name. To avoid this problem, you can explicitly name the method on the JVM using the `@JvmName` annotation:

[source,kotlin]
----
@JvmInline
value class Kilometers(val value: Double)

@JvmInline
value class Miles(val value: Double)

@JvmName("displayKm")
fun display(x: Kilometers) { println("${x.value} km") }

@JvmName("displayMiles")
fun display(x: Miles) { println("${x.value} miles") }
----

From Java, you can call the example methods by their JVM names and with `double` arguments, e.g. `displayKm(23.0);` and `displayMiles(42.3);`.

[#reifiedGenerics]
=== Calling Functions with Reified Type Parameters

I am afraid I have some bad news for you: Java has no inlining mechanism, and without inlining, the resolution of reified type parameters simply doesn't work. As a consequence, you can't call such functions from Java, not even via reflection.

A workaround is to write a version of the function with an explicit class parameter:

[source,kotlin]
----
inline fun <reified T> tellType(list: List<T>) {
    println(T::class.qualifiedName)
}

// for Java calls
fun <T: Any> tellTypeJava(list: List<T>, clazz: Class<T>) {
    println(clazz.kotlin.qualifiedName)
}
----

You can call the second function as usual from Java, e.g. `tellTypeJava(List.of(1,2,3), Integer.class);`.

This approach will work for many use cases, but it should be noted that a reified type contains information about its own type parameters, while a class parameter just denotes a raw type. If this type information is needed, our simplistic approach won't work. It is difficult to give a general solution for the more complicated cases, but replacing the class parameter with e.g. `TypeToken` (from either https://github.com/google/guava[Guava] or https://github.com/google/gson[Gson]) might help.

=== Checked Exceptions

Kotlin doesn't have the concept of "checked exceptions", but if a function that might throw such an exception is called from Java, the Java compiler expects that the exception is declared in the function signature. In order to avoid problems in such cases, you can give the Kotlin compiler a hint to add a checked exception to the function signature in the byte-code by annotating the function with `Throws(SomeCheckedException::class)`.



